/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 1;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 1;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const SAPUCRFC_H: &[u8; 46] = b"$Id: //bas/753_REL/src/include/sapucrfc.h#4 $\0";
pub const SAPwithINT_LITTLEENDIAN: u32 = 1;
pub const SAPonLIN: u32 = 1;
pub const SAPonUNIX: u32 = 1;
pub const SAPonSYS5: u32 = 1;
pub const SAPonSYS5_4: u32 = 1;
pub const SAPwithFLOAT_IEEE: u32 = 1;
pub const SAPwithCHAR_ASCII: u32 = 1;
pub const _UCHAR_H: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const SAP_SHORT_BYTES: u32 = 2;
pub const SAP_LLONG_BYTES: u32 = 8;
pub const SAP_ULLONG_BYTES: u32 = 8;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const SAP_DATE_LN: u32 = 8;
pub const SAP_TIME_LN: u32 = 6;
pub const DECF_16_MAX_STRLEN: u32 = 25;
pub const DECF_34_MAX_STRLEN: u32 = 43;
pub const _WCHAR_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _WCTYPE_H: u32 = 1;
pub const _BITS_WCTYPE_WCHAR_H: u32 = 1;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const WINT_EOF: u32 = 4294967295;
pub const SAP_UC_LN: u32 = 2;
pub const SAP_UC_SF: u32 = 1;
pub const SAP_UC_ALIGN_MASK: u32 = 1;
pub const FREEenvironR: u32 = 1;
pub const MB_CUR_MAX_U: u32 = 2;
pub const MB_CUR_MAX_NUC: u32 = 1;
pub const MB_CUR_MAX_UC: u32 = 2;
pub const MAX_ALIASES: u32 = 64;
pub const MAX_ADDRESSES: u32 = 64;
pub const MAX_PATH_LN: u32 = 4097;
pub const SAP_SYS_NMLN: u32 = 256;
pub const RFC_TID_LN: u32 = 24;
pub const RFC_UNITID_LN: u32 = 32;
pub type wchar_t = ::std::os::raw::c_int;
pub type __cfloat128 = __BindgenComplex<u128>;
pub type _Float128 = u128;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
    pub __unused_initialized_1: ::std::os::raw::c_uint,
    pub __unused_initialized_2: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 16usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 28usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 32usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_1"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_1) - 40usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_2"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_2) - 44usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub _short_backupbuf: [::std::os::raw::c_char; 1usize],
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_short_backupbuf"]
        [::std::mem::offset_of!(_IO_FILE, _short_backupbuf) - 119usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
impl _IO_FILE {
    #[inline]
    pub fn _flags2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set__flags2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flags2_raw(this: *const Self) -> ::std::os::raw::c_int {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set__flags2_raw(this: *mut Self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(_flags2: ::std::os::raw::c_int) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let _flags2: u32 = unsafe { ::std::mem::transmute(_flags2) };
            _flags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
    -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type SAP_DOUBLE = f64;
pub type mbstate_t = __mbstate_t;
pub type char16_t = __uint_least16_t;
pub type char32_t = __uint_least32_t;
unsafe extern "C" {
    pub fn mbrtoc16(
        __pc16: *mut char16_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn c16rtomb(
        __s: *mut ::std::os::raw::c_char,
        __c16: char16_t,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mbrtoc32(
        __pc32: *mut char32_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn c32rtomb(
        __s: *mut ::std::os::raw::c_char,
        __c32: char32_t,
        __ps: *mut mbstate_t,
    ) -> usize;
}
pub type SAP_CHAR = char16_t;
pub type SAP_UC = char16_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
pub type SAP_RAW = ::std::os::raw::c_uchar;
pub type SAP_SRAW = ::std::os::raw::c_schar;
pub type SAP_USHORT = ::std::os::raw::c_ushort;
pub type SAP_UINT = ::std::os::raw::c_uint;
pub type SAP_INT = ::std::os::raw::c_int;
pub type SAP_SHORT = ::std::os::raw::c_short;
pub type SAP_LLONG = ::std::os::raw::c_long;
pub type SAP_ULLONG = ::std::os::raw::c_ulong;
pub type SAP_BOOL = ::std::os::raw::c_uchar;
pub type LINE_USING_PROC = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut SAP_CHAR, number_of_chars: ::std::os::raw::c_int),
>;
pub type intU = ::std::os::raw::c_int;
pub type intR = ::std::os::raw::c_int;
pub type unsigned_intU = ::std::os::raw::c_uint;
pub type unsigned_intR = ::std::os::raw::c_uint;
pub type shortU = ::std::os::raw::c_short;
pub type shortR = ::std::os::raw::c_short;
pub type unsigned_shortU = ::std::os::raw::c_ushort;
pub type unsigned_shortR = ::std::os::raw::c_ushort;
pub type longU = ::std::os::raw::c_long;
pub type longR = ::std::os::raw::c_long;
pub type unsigned_longU = ::std::os::raw::c_ulong;
pub type unsigned_longR = ::std::os::raw::c_ulong;
pub type size_tU = usize;
pub type size_tR = usize;
pub type SAP_USHORT_U = SAP_USHORT;
pub type SAP_USHORT_R = SAP_USHORT;
pub type SAP_SHORT_U = SAP_SHORT;
pub type SAP_SHORT_R = SAP_SHORT;
pub type SAP_UINT_U = SAP_UINT;
pub type SAP_UINT_R = SAP_UINT;
pub type SAP_INT_U = SAP_INT;
pub type SAP_INT_R = SAP_INT;
pub type SAP_ULLONG_U = SAP_ULLONG;
pub type SAP_ULLONG_R = SAP_ULLONG;
pub type SAP_LLONG_U = SAP_LLONG;
pub type SAP_LLONG_R = SAP_LLONG;
pub type SAP_DATE = [SAP_CHAR; 8usize];
pub type SAP_TIME = [SAP_CHAR; 6usize];
pub type SAP_BCD = SAP_RAW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SAP_UUID {
    pub a: SAP_UINT,
    pub b: SAP_USHORT,
    pub c: SAP_USHORT,
    pub d: [SAP_RAW; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SAP_UUID"][::std::mem::size_of::<SAP_UUID>() - 16usize];
    ["Alignment of SAP_UUID"][::std::mem::align_of::<SAP_UUID>() - 4usize];
    ["Offset of field: SAP_UUID::a"][::std::mem::offset_of!(SAP_UUID, a) - 0usize];
    ["Offset of field: SAP_UUID::b"][::std::mem::offset_of!(SAP_UUID, b) - 4usize];
    ["Offset of field: SAP_UUID::c"][::std::mem::offset_of!(SAP_UUID, c) - 6usize];
    ["Offset of field: SAP_UUID::d"][::std::mem::offset_of!(SAP_UUID, d) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union SAP_MAX_ALIGN_T {
    pub align_1: ::std::os::raw::c_long,
    pub align_2: f64,
    pub align_3: *mut ::std::os::raw::c_void,
    pub align_4: SAP_DOUBLE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SAP_MAX_ALIGN_T"][::std::mem::size_of::<SAP_MAX_ALIGN_T>() - 8usize];
    ["Alignment of SAP_MAX_ALIGN_T"][::std::mem::align_of::<SAP_MAX_ALIGN_T>() - 8usize];
    ["Offset of field: SAP_MAX_ALIGN_T::align_1"]
        [::std::mem::offset_of!(SAP_MAX_ALIGN_T, align_1) - 0usize];
    ["Offset of field: SAP_MAX_ALIGN_T::align_2"]
        [::std::mem::offset_of!(SAP_MAX_ALIGN_T, align_2) - 0usize];
    ["Offset of field: SAP_MAX_ALIGN_T::align_3"]
        [::std::mem::offset_of!(SAP_MAX_ALIGN_T, align_3) - 0usize];
    ["Offset of field: SAP_MAX_ALIGN_T::align_4"]
        [::std::mem::offset_of!(SAP_MAX_ALIGN_T, align_4) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union DecFloat16 {
    pub bytes: [SAP_RAW; 8usize],
    pub align: SAP_DOUBLE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DecFloat16"][::std::mem::size_of::<DecFloat16>() - 8usize];
    ["Alignment of DecFloat16"][::std::mem::align_of::<DecFloat16>() - 8usize];
    ["Offset of field: DecFloat16::bytes"][::std::mem::offset_of!(DecFloat16, bytes) - 0usize];
    ["Offset of field: DecFloat16::align"][::std::mem::offset_of!(DecFloat16, align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union DecFloat34 {
    pub bytes: [SAP_RAW; 16usize],
    pub align: SAP_MAX_ALIGN_T,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DecFloat34"][::std::mem::size_of::<DecFloat34>() - 16usize];
    ["Alignment of DecFloat34"][::std::mem::align_of::<DecFloat34>() - 8usize];
    ["Offset of field: DecFloat34::bytes"][::std::mem::offset_of!(DecFloat34, bytes) - 0usize];
    ["Offset of field: DecFloat34::align"][::std::mem::offset_of!(DecFloat34, align) - 0usize];
};
pub const DecFloatRawLen_DecFloat16RawLen: DecFloatRawLen = 8;
pub const DecFloatRawLen_DecFloat34RawLen: DecFloatRawLen = 16;
pub type DecFloatRawLen = ::std::os::raw::c_uint;
pub type DecFloat16Raw = [SAP_RAW; 8usize];
pub type DecFloat34Raw = [SAP_RAW; 16usize];
pub const DecFloatLen_DecFloat16Len: DecFloatLen = 8;
pub const DecFloatLen_DecFloat34Len: DecFloatLen = 16;
pub type DecFloatLen = ::std::os::raw::c_uint;
pub type DecFloat34Buff = [SAP_UC; 43usize];
pub type DecFloat16Buff = [SAP_UC; 25usize];
pub type SAP_UINT_PTR = ::std::os::raw::c_ulong;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslcpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcslcat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcschr(
        __wcs: *const ::std::os::raw::c_int,
        __wc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslen(__s: *const ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn wmemchr(
        __s: *const ::std::os::raw::c_int,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wmemcmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wmemcpy(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wmemmove(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
unsafe extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
unsafe extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
unsafe extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
unsafe extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize) -> *mut __FILE;
}
unsafe extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
pub type wctype_t = ::std::os::raw::c_ulong;
pub const __ISwupper: _bindgen_ty_2 = 0;
pub const __ISwlower: _bindgen_ty_2 = 1;
pub const __ISwalpha: _bindgen_ty_2 = 2;
pub const __ISwdigit: _bindgen_ty_2 = 3;
pub const __ISwxdigit: _bindgen_ty_2 = 4;
pub const __ISwspace: _bindgen_ty_2 = 5;
pub const __ISwprint: _bindgen_ty_2 = 6;
pub const __ISwgraph: _bindgen_ty_2 = 7;
pub const __ISwblank: _bindgen_ty_2 = 8;
pub const __ISwcntrl: _bindgen_ty_2 = 9;
pub const __ISwpunct: _bindgen_ty_2 = 10;
pub const __ISwalnum: _bindgen_ty_2 = 11;
pub const _ISwupper: _bindgen_ty_2 = 16777216;
pub const _ISwlower: _bindgen_ty_2 = 33554432;
pub const _ISwalpha: _bindgen_ty_2 = 67108864;
pub const _ISwdigit: _bindgen_ty_2 = 134217728;
pub const _ISwxdigit: _bindgen_ty_2 = 268435456;
pub const _ISwspace: _bindgen_ty_2 = 536870912;
pub const _ISwprint: _bindgen_ty_2 = 1073741824;
pub const _ISwgraph: _bindgen_ty_2 = -2147483648;
pub const _ISwblank: _bindgen_ty_2 = 65536;
pub const _ISwcntrl: _bindgen_ty_2 = 131072;
pub const _ISwpunct: _bindgen_ty_2 = 262144;
pub const _ISwalnum: _bindgen_ty_2 = 524288;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn iswalnum(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswalpha(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswcntrl(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswgraph(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswlower(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswprint(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswpunct(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswspace(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswupper(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswxdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswblank(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctype(__property: *const ::std::os::raw::c_char) -> wctype_t;
}
unsafe extern "C" {
    pub fn iswctype(__wc: wint_t, __desc: wctype_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn towlower(__wc: wint_t) -> wint_t;
}
unsafe extern "C" {
    pub fn towupper(__wc: wint_t) -> wint_t;
}
pub type wctrans_t = *const __int32_t;
unsafe extern "C" {
    pub fn wctrans(__property: *const ::std::os::raw::c_char) -> wctrans_t;
}
unsafe extern "C" {
    pub fn towctrans(__wc: wint_t, __desc: wctrans_t) -> wint_t;
}
unsafe extern "C" {
    pub fn iswalnum_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswalpha_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswcntrl_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswdigit_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswgraph_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswlower_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswprint_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswpunct_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswspace_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswupper_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswxdigit_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswblank_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctype_l(__property: *const ::std::os::raw::c_char, __locale: locale_t) -> wctype_t;
}
unsafe extern "C" {
    pub fn iswctype_l(__wc: wint_t, __desc: wctype_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn towlower_l(__wc: wint_t, __locale: locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn towupper_l(__wc: wint_t, __locale: locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn wctrans_l(__property: *const ::std::os::raw::c_char, __locale: locale_t) -> wctrans_t;
}
unsafe extern "C" {
    pub fn towctrans_l(__wc: wint_t, __desc: wctrans_t, __locale: locale_t) -> wint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent"][::std::mem::size_of::<dirent>() - 280usize];
    ["Alignment of dirent"][::std::mem::align_of::<dirent>() - 8usize];
    ["Offset of field: dirent::d_ino"][::std::mem::offset_of!(dirent, d_ino) - 0usize];
    ["Offset of field: dirent::d_off"][::std::mem::offset_of!(dirent, d_off) - 8usize];
    ["Offset of field: dirent::d_reclen"][::std::mem::offset_of!(dirent, d_reclen) - 16usize];
    ["Offset of field: dirent::d_type"][::std::mem::offset_of!(dirent, d_type) - 18usize];
    ["Offset of field: dirent::d_name"][::std::mem::offset_of!(dirent, d_name) - 19usize];
};
pub const DT_UNKNOWN: _bindgen_ty_3 = 0;
pub const DT_FIFO: _bindgen_ty_3 = 1;
pub const DT_CHR: _bindgen_ty_3 = 2;
pub const DT_DIR: _bindgen_ty_3 = 4;
pub const DT_BLK: _bindgen_ty_3 = 6;
pub const DT_REG: _bindgen_ty_3 = 8;
pub const DT_LNK: _bindgen_ty_3 = 10;
pub const DT_SOCK: _bindgen_ty_3 = 12;
pub const DT_WHT: _bindgen_ty_3 = 14;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
unsafe extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
unsafe extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
unsafe extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
unsafe extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
unsafe extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
pub type SAP_UTF16 = char16_t;
pub type WINT_T = wint_t;
pub const unicodeId: &[u8; 17] = b"@(#)     Unicode\0";
unsafe extern "C" {
    pub fn dbgAlignCheckStringU16(arg1: *mut ::std::os::raw::c_char) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn UcnToFileLenR(data: *mut SAP_CHAR, n: size_tU) -> size_tR;
}
unsafe extern "C" {
    pub fn strcatU16(dest: *mut SAP_UTF16, src: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strchrU16(wcs: *const SAP_UTF16, c: ::std::os::raw::c_int) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strcmpU16(s1: *const SAP_UTF16, s2: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcpyU16(dest: *mut SAP_UTF16, src: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strcspnU16(ucs: *const SAP_UTF16, reject: *const SAP_UTF16) -> usize;
}
unsafe extern "C" {
    pub fn strdupU16(s: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strlenU16(s: *const SAP_UTF16) -> usize;
}
unsafe extern "C" {
    pub fn strncatU16(dest: *mut SAP_UTF16, src: *const SAP_UTF16, n: usize) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strncmpU16(
        s1: *const SAP_UTF16,
        s2: *const SAP_UTF16,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpyU16(dest: *mut SAP_UTF16, src: *const SAP_UTF16, n: usize) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strpbrkU16(ucs: *const SAP_UTF16, accept: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strrchrU16(wcs: *const SAP_UTF16, c: ::std::os::raw::c_int) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strspnU16(ucs: *const SAP_UTF16, accept: *const SAP_UTF16) -> usize;
}
unsafe extern "C" {
    pub fn strstrU16(haystack: *const SAP_UTF16, needle: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strtokU16(s: *mut SAP_UTF16, delim: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strtok_rRFB(
        s: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_rU16(
        s: *mut SAP_UTF16,
        delim: *const SAP_UTF16,
        save_ptr: *mut *mut SAP_UTF16,
    ) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strtodU16(str_: *const SAP_UTF16, endptr: *mut *mut SAP_UTF16) -> f64;
}
unsafe extern "C" {
    pub fn strtolU16(
        s: *const SAP_UTF16,
        end: *mut *mut SAP_UTF16,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoulU16(
        s: *const SAP_UTF16,
        end: *mut *mut SAP_UTF16,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtollU16(
        s: *const SAP_UTF16,
        end: *mut *mut SAP_UTF16,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoullU16(
        s: *const SAP_UTF16,
        end: *mut *mut SAP_UTF16,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strcasecmpU16(s1: *const SAP_UTF16, s2: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmpR(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmpU16(
        s1: *const SAP_UTF16,
        s2: *const SAP_UTF16,
        n: size_tU,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmpR(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getoptU(
        argc: ::std::os::raw::c_int,
        argv: *const *mut SAP_UC,
        optstr: *const SAP_UC,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optargU: *mut SAP_UC;
}
unsafe extern "C" {
    pub fn memcmpU16(s1: *const SAP_UTF16, s2: *const SAP_UTF16, n: usize)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchrU16(s: *const SAP_UTF16, c: ::std::os::raw::c_int, n: usize) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn memsetU16(s: *mut SAP_UTF16, c: ::std::os::raw::c_int, n: usize) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn dlopenU16(
        path: *const SAP_UTF16,
        mode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn dlsymU16(
        handle: *mut ::std::os::raw::c_void,
        name: *const SAP_UTF16,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn dlerrorU16() -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn accessU16(path: *const SAP_UTF16, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chdirU16(path: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdopenU16(filedes: ::std::os::raw::c_int, type_: *const SAP_UTF16) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopenU16(path: *const SAP_UTF16, mode: *const SAP_UTF16) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopen64U16(path: *const SAP_UTF16, mode: *const SAP_UTF16) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopenU16(
        path: *const SAP_UTF16,
        mode: *const SAP_UTF16,
        stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn gethostnameU16(name: *mut SAP_UTF16, len: size_tU) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openU16(
        wpath: *const SAP_UTF16,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perrorU16(program: *const SAP_UTF16);
}
unsafe extern "C" {
    pub fn popenU16(wcomm: *const SAP_UTF16, wtype: *const SAP_UTF16) -> *mut FILE;
}
unsafe extern "C" {
    pub fn removeU16(path: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameU16(from: *const SAP_UTF16, to: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmdirU16(wpath: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn systemU16(s: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strftimeU16(
        wcs: *mut SAP_UTF16,
        len: usize,
        format: *const SAP_UTF16,
        tmdate: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn unlinkU16(path: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utimbuf {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn utimeU16(wpath: *const SAP_UTF16, time: *const utimbuf) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chmodU16(wpath: *const SAP_UTF16, mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn creatU16(wpath: *const SAP_UTF16, mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdirU16(wpath: *const SAP_UTF16, mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstempU16(tmpl: *mut SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifoU16(wpath: *const SAP_UTF16, mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chownU16(
        path: *const SAP_UTF16,
        owner: SAP_UINT,
        group: SAP_UINT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkU16(path1: *const SAP_UTF16, path2: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkU16(
        path: *const SAP_UTF16,
        buf: *mut SAP_UTF16,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn symlinkU16(path1: *const SAP_UTF16, path2: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asctimeU16(timeptr: *const tm) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn asctime_rU16(timeptr: *const tm, bufptr: *mut SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn basenameU16(path: *mut SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn ctimeU16(timer: *const time_t) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn ctime_rU16(timer: *const time_t, bufptr: *mut SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn dirnameU16(path: *mut SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn ecvtU16(
        value: f64,
        ndig: ::std::os::raw::c_int,
        dptr: *mut ::std::os::raw::c_int,
        sign: *mut ::std::os::raw::c_int,
    ) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn getcwdU16(wbuf: *mut SAP_UTF16, size: size_tU) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn setlocaleU16(
        category: ::std::os::raw::c_int,
        w_inPtr: *const SAP_UTF16,
    ) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strerrorU16(errnum: ::std::os::raw::c_int) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn strerror_rU16(
        errnum: ::std::os::raw::c_int,
        buf: *mut SAP_UTF16,
        buflen: size_tU,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_rR(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttynameU16(filedes: ::std::os::raw::c_int) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn fgetcU16(stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputcU16(wc: ::std::os::raw::c_int, stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwriteU16(
        arg1: *const SAP_UTF16,
        arg2: size_tU,
        arg3: usize,
        stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn freadU16(buf: *mut SAP_UTF16, s: size_tU, n: usize, stream: *mut FILE) -> usize;
}
unsafe extern "C" {
    pub fn fgetsU16(wcs: *mut SAP_UTF16, n: intU, stream: *mut FILE) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn getsU16(s: *mut SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn fputsU16(wcs: *const SAP_UTF16, stream: *mut FILE) -> intU;
}
unsafe extern "C" {
    pub fn putsU16(wcs: *const SAP_UTF16) -> intU;
}
unsafe extern "C" {
    pub fn printfU16(format: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fprintfU16(s: *mut FILE, format: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintfU16(s: *mut SAP_UTF16, format: *const SAP_UTF16, ...) -> intU;
}
unsafe extern "C" {
    pub fn snprintfU16(s: *mut SAP_UTF16, n: usize, format: *const SAP_UTF16, ...) -> intU;
}
unsafe extern "C" {
    pub fn vprintfU16(format: *const SAP_UTF16, ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintfU16(
        s: *mut FILE,
        format: *const SAP_UTF16,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintfU16(s: *mut SAP_UTF16, format: *const SAP_UTF16, ap: *mut __va_list_tag)
    -> intU;
}
unsafe extern "C" {
    pub fn vsprintf_sRFB(
        s: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf_sU16(
        s: *mut SAP_UTF16,
        n: usize,
        format: *const SAP_UTF16,
        ap: *mut __va_list_tag,
    ) -> intU;
}
unsafe extern "C" {
    pub fn vsnprintfU16(
        s: *mut SAP_UTF16,
        n: usize,
        format: *const SAP_UTF16,
        ap: *mut __va_list_tag,
    ) -> intU;
}
unsafe extern "C" {
    pub fn vsnprintf_sRFB(
        s: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf_sU16(
        s: *mut SAP_UTF16,
        n: usize,
        format: *const SAP_UTF16,
        ap: *mut __va_list_tag,
    ) -> intU;
}
unsafe extern "C" {
    pub fn sscanfU16(s: *const SAP_UTF16, format: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanfU16(format: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanfU16(s: *mut FILE, format: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_strR(
        s: *mut ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        stream: *mut FILE,
        repl_char: SAP_UC,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_strU16(
        s: *mut SAP_UTF16,
        n: ::std::os::raw::c_int,
        stream: *mut FILE,
        repl_char: SAP_UTF16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_lineR(
        s: *mut ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        stream: *mut FILE,
        repl_char: SAP_UC,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_lineU16(
        s: *mut SAP_UTF16,
        n: ::std::os::raw::c_int,
        stream: *mut FILE,
        repl_char: SAP_UTF16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_longR(ptr: *mut ::std::os::raw::c_long, stream: *mut FILE)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_longU16(
        ptr: *mut ::std::os::raw::c_long,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_intR(ptr: *mut ::std::os::raw::c_int, stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fget_intU16(ptr: *mut ::std::os::raw::c_int, stream: *mut FILE)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlU16(path: *const SAP_UTF16, arg: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execleU16(path: *const SAP_UTF16, arg: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlpU16(file: *const SAP_UTF16, arg: *const SAP_UTF16, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvU16(path: *const SAP_UTF16, argv: *const *mut SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execveU16(
        path: *const SAP_UTF16,
        argv: *const *mut SAP_UTF16,
        wenv: *const *mut SAP_UTF16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvpU16(path: *const SAP_UTF16, argv: *const *mut SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getenvU16(wname: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn putenvU16(wcs: *const SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nlsui_getenvironU() -> *mut *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn nlsui_freeenvironU(arg1: *mut *mut SAP_UTF16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nlsui_main(argc: ::std::os::raw::c_int, argv: *mut *mut SAP_UC)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nlsui_main3(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut SAP_UC,
        envp: *mut *mut SAP_UC,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nlsui_initialize();
}
unsafe extern "C" {
    pub fn nlsui_alloc_wcsar(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut *mut SAP_UC;
}
unsafe extern "C" {
    pub fn nlsui_wcsar2mbsar(
        cnt: ::std::os::raw::c_int,
        wp: *mut *mut SAP_UC,
        p: *mut *mut ::std::os::raw::c_char,
        plen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nlsui_alloc_env(envp: *mut *mut ::std::os::raw::c_char) -> *mut *mut SAP_UC;
}
unsafe extern "C" {
    pub fn mblenU(mbptr: *const SAP_UC, units: size_tU) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utsnameU {
    pub sysname: [SAP_UC; 256usize],
    pub nodename: [SAP_UC; 256usize],
    pub release: [SAP_UC; 256usize],
    pub version: [SAP_UC; 256usize],
    pub machine: [SAP_UC; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of utsnameU"][::std::mem::size_of::<utsnameU>() - 2560usize];
    ["Alignment of utsnameU"][::std::mem::align_of::<utsnameU>() - 2usize];
    ["Offset of field: utsnameU::sysname"][::std::mem::offset_of!(utsnameU, sysname) - 0usize];
    ["Offset of field: utsnameU::nodename"][::std::mem::offset_of!(utsnameU, nodename) - 512usize];
    ["Offset of field: utsnameU::release"][::std::mem::offset_of!(utsnameU, release) - 1024usize];
    ["Offset of field: utsnameU::version"][::std::mem::offset_of!(utsnameU, version) - 1536usize];
    ["Offset of field: utsnameU::machine"][::std::mem::offset_of!(utsnameU, machine) - 2048usize];
};
unsafe extern "C" {
    pub fn unameU(name: *mut utsnameU) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn opendirU16(path: *const SAP_UTF16) -> *mut DIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct direntU16 {
    pub d_ino: ino_t,
    pub d_name: [SAP_UTF16; 4097usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of direntU16"][::std::mem::size_of::<direntU16>() - 8208usize];
    ["Alignment of direntU16"][::std::mem::align_of::<direntU16>() - 8usize];
    ["Offset of field: direntU16::d_ino"][::std::mem::offset_of!(direntU16, d_ino) - 0usize];
    ["Offset of field: direntU16::d_name"][::std::mem::offset_of!(direntU16, d_name) - 8usize];
};
unsafe extern "C" {
    pub fn readdirU16(dirp: *mut DIR) -> *mut direntU16;
}
unsafe extern "C" {
    pub fn readdir_rU16(
        dirp: *mut DIR,
        entry: *mut direntU16,
        result: *mut *mut direntU16,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwdU16 {
    pub pw_name: *mut SAP_UTF16,
    pub pw_passwd: *mut SAP_UTF16,
    pub pw_uid: SAP_UINT,
    pub pw_gid: SAP_UINT,
    pub pw_gecos: *mut SAP_UTF16,
    pub pw_dir: *mut SAP_UTF16,
    pub pw_shell: *mut SAP_UTF16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of passwdU16"][::std::mem::size_of::<passwdU16>() - 48usize];
    ["Alignment of passwdU16"][::std::mem::align_of::<passwdU16>() - 8usize];
    ["Offset of field: passwdU16::pw_name"][::std::mem::offset_of!(passwdU16, pw_name) - 0usize];
    ["Offset of field: passwdU16::pw_passwd"]
        [::std::mem::offset_of!(passwdU16, pw_passwd) - 8usize];
    ["Offset of field: passwdU16::pw_uid"][::std::mem::offset_of!(passwdU16, pw_uid) - 16usize];
    ["Offset of field: passwdU16::pw_gid"][::std::mem::offset_of!(passwdU16, pw_gid) - 20usize];
    ["Offset of field: passwdU16::pw_gecos"][::std::mem::offset_of!(passwdU16, pw_gecos) - 24usize];
    ["Offset of field: passwdU16::pw_dir"][::std::mem::offset_of!(passwdU16, pw_dir) - 32usize];
    ["Offset of field: passwdU16::pw_shell"][::std::mem::offset_of!(passwdU16, pw_shell) - 40usize];
};
unsafe extern "C" {
    pub fn getpwuidU16(uid: SAP_UINT) -> *mut passwdU16;
}
unsafe extern "C" {
    pub fn getpwnamU16(name: *const SAP_UTF16) -> *mut passwdU16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostentU16 {
    pub h_name: *mut SAP_UTF16,
    pub h_aliases: [*mut SAP_UTF16; 64usize],
    pub h_addrtype: SAP_INT,
    pub h_length: SAP_INT,
    pub h_addr_list: [*mut SAP_RAW; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hostentU16"][::std::mem::size_of::<hostentU16>() - 1040usize];
    ["Alignment of hostentU16"][::std::mem::align_of::<hostentU16>() - 8usize];
    ["Offset of field: hostentU16::h_name"][::std::mem::offset_of!(hostentU16, h_name) - 0usize];
    ["Offset of field: hostentU16::h_aliases"]
        [::std::mem::offset_of!(hostentU16, h_aliases) - 8usize];
    ["Offset of field: hostentU16::h_addrtype"]
        [::std::mem::offset_of!(hostentU16, h_addrtype) - 520usize];
    ["Offset of field: hostentU16::h_length"]
        [::std::mem::offset_of!(hostentU16, h_length) - 524usize];
    ["Offset of field: hostentU16::h_addr_list"]
        [::std::mem::offset_of!(hostentU16, h_addr_list) - 528usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serventU16 {
    pub s_name: *mut SAP_UTF16,
    pub s_aliases: [*mut SAP_UTF16; 64usize],
    pub s_port: SAP_INT,
    pub s_proto: *mut SAP_UTF16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of serventU16"][::std::mem::size_of::<serventU16>() - 536usize];
    ["Alignment of serventU16"][::std::mem::align_of::<serventU16>() - 8usize];
    ["Offset of field: serventU16::s_name"][::std::mem::offset_of!(serventU16, s_name) - 0usize];
    ["Offset of field: serventU16::s_aliases"]
        [::std::mem::offset_of!(serventU16, s_aliases) - 8usize];
    ["Offset of field: serventU16::s_port"][::std::mem::offset_of!(serventU16, s_port) - 520usize];
    ["Offset of field: serventU16::s_proto"]
        [::std::mem::offset_of!(serventU16, s_proto) - 528usize];
};
unsafe extern "C" {
    pub fn gethostbyaddrU16(
        addr: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut hostentU16;
}
unsafe extern "C" {
    pub fn gethostbynameU16(name: *const SAP_UTF16) -> *mut hostentU16;
}
unsafe extern "C" {
    pub fn rexecU16(
        host: *mut *mut SAP_UC,
        port: ::std::os::raw::c_int,
        name: *const SAP_UC,
        pass: *const SAP_UC,
        cmd: *const SAP_UC,
        fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct groupU16 {
    pub gr_name: *mut SAP_UTF16,
    pub gr_passwd: *mut SAP_UTF16,
    pub gr_gid: ::std::os::raw::c_ulong,
    pub gr_mem: *mut *mut SAP_UTF16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of groupU16"][::std::mem::size_of::<groupU16>() - 32usize];
    ["Alignment of groupU16"][::std::mem::align_of::<groupU16>() - 8usize];
    ["Offset of field: groupU16::gr_name"][::std::mem::offset_of!(groupU16, gr_name) - 0usize];
    ["Offset of field: groupU16::gr_passwd"][::std::mem::offset_of!(groupU16, gr_passwd) - 8usize];
    ["Offset of field: groupU16::gr_gid"][::std::mem::offset_of!(groupU16, gr_gid) - 16usize];
    ["Offset of field: groupU16::gr_mem"][::std::mem::offset_of!(groupU16, gr_mem) - 24usize];
};
unsafe extern "C" {
    pub fn getgrgidU16(gid: ::std::os::raw::c_ulong) -> *mut groupU16;
}
unsafe extern "C" {
    pub fn getpassU16(prompt: *const SAP_UTF16) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub static mut statvfsU: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statvfs {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn statvfsU16(path: *const SAP_UC, buf: *mut statvfs) -> ::std::os::raw::c_int;
}
pub type SAP_U2 = char16_t;
pub type SAP_U4 = SAP_UINT;
pub type SAP_B8 = ::std::os::raw::c_char;
pub type SAP_UTF8 = ::std::os::raw::c_uchar;
pub type SAP_CESU8 = ::std::os::raw::c_uchar;
pub type SAP_UTF7 = ::std::os::raw::c_uchar;
pub type SAP_A7 = ::std::os::raw::c_char;
pub type SAP_B7 = ::std::os::raw::c_char;
pub type SAP_E8 = ::std::os::raw::c_uchar;
pub type SAP_UC_MB = ::std::os::raw::c_char;
pub const NlsuiTraceLevel_none: NlsuiTraceLevel = 0;
pub const NlsuiTraceLevel_low: NlsuiTraceLevel = 1;
pub const NlsuiTraceLevel_medium: NlsuiTraceLevel = 4;
pub const NlsuiTraceLevel_high: NlsuiTraceLevel = 16;
pub type NlsuiTraceLevel = ::std::os::raw::c_uint;
pub type TRACE_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(buffer: *const SAP_B7, number_of_chars: ::std::os::raw::c_int),
>;
unsafe extern "C" {
    pub fn nlsui_set_trace(p: TRACE_FUNC_T, l: NlsuiTraceLevel);
}
unsafe extern "C" {
    pub fn nlsui_set_trace_func(p: TRACE_FUNC_T);
}
pub type ICU_BOOL = ::std::os::raw::c_schar;
unsafe extern "C" {
    pub static mut isalnumU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub static mut isalphaU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub static mut iscntrlU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub static mut islowerU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub static mut isprintU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub static mut isspaceU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub static mut isupperU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> ICU_BOOL>;
}
unsafe extern "C" {
    pub fn isgraphU(c: SAP_U4) -> ICU_BOOL;
}
unsafe extern "C" {
    pub fn ispunctU(c: SAP_U4) -> ICU_BOOL;
}
unsafe extern "C" {
    pub fn isxdigitU(c: SAP_U4) -> ICU_BOOL;
}
unsafe extern "C" {
    pub static mut tolowerU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> SAP_U4>;
}
unsafe extern "C" {
    pub static mut toupperU: ::std::option::Option<unsafe extern "C" fn(c: SAP_U4) -> SAP_U4>;
}
unsafe extern "C" {
    pub fn strnlenRFB(s: *const ::std::os::raw::c_char, maxsize: size_tR) -> usize;
}
unsafe extern "C" {
    pub fn strnlenU16(s: *const SAP_UTF16, maxsize: size_tU) -> usize;
}
unsafe extern "C" {
    pub fn strcpy_sRFB(
        s1: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcpy_sU16(
        dest: *mut SAP_UTF16,
        s1max: size_tU,
        src: *const SAP_UTF16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpy_sRFB(
        s1: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpy_sU16(
        dest: *mut SAP_UTF16,
        s1max: size_tU,
        src: *const SAP_UTF16,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcat_sRFB(
        s1: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcat_sU16(
        dest: *mut SAP_UTF16,
        s1max: size_tU,
        src: *const SAP_UTF16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncat_sRFB(
        s1: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        s2: *const ::std::os::raw::c_char,
        n: size_tR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncat_sU16(
        dest: *mut SAP_UTF16,
        s1max: size_tU,
        src: *const SAP_UTF16,
        n: size_tU,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gets_sRFB(s: *mut ::std::os::raw::c_char, n: size_tR) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gets_sU16(s: *mut SAP_UTF16, n: size_tU) -> *mut SAP_UTF16;
}
unsafe extern "C" {
    pub fn sprintf_sRFB(
        s: *mut ::std::os::raw::c_char,
        s1max: size_tR,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf_sU16(s: *mut SAP_UTF16, s1max: size_tU, format: *const SAP_UTF16, ...) -> intU;
}
unsafe extern "C" {
    pub fn snprintf_sRFB(
        s: *mut ::std::os::raw::c_char,
        n: size_tR,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf_sU16(s: *mut SAP_UTF16, n: size_tU, format: *const SAP_UTF16, ...) -> intU;
}
unsafe extern "C" {
    pub fn memcpy_sRFB(
        s1: *mut ::std::os::raw::c_void,
        s1max: size_tR,
        s2: *const ::std::os::raw::c_void,
        n: size_tR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy_sU16(
        s1: *mut SAP_UTF16,
        s1max: size_tU,
        s2: *const SAP_UTF16,
        n: size_tU,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memmove_sRFB(
        s1: *mut ::std::os::raw::c_void,
        s1max: size_tR,
        s2: *const ::std::os::raw::c_void,
        n: size_tR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memmove_sU16(
        s1: *mut SAP_UTF16,
        s1max: size_tU,
        s2: *const SAP_UTF16,
        n: size_tU,
    ) -> ::std::os::raw::c_int;
}
pub type RFC_INT8 = ::std::os::raw::c_long;
pub type RFC_CHAR = SAP_UC;
pub type RFC_NUM = RFC_CHAR;
pub type RFC_BYTE = SAP_RAW;
pub type RFC_BCD = SAP_RAW;
pub type RFC_INT1 = SAP_RAW;
pub type RFC_INT2 = ::std::os::raw::c_short;
pub type RFC_INT = ::std::os::raw::c_int;
pub type RFC_FLOAT = f64;
pub type RFC_DATE = [RFC_CHAR; 8usize];
pub type RFC_TIME = [RFC_CHAR; 6usize];
pub type RFC_DECF16 = DecFloat16;
pub type RFC_DECF34 = DecFloat34;
pub type RFC_UTCLONG = RFC_INT8;
pub type RFC_UTCSECOND = RFC_INT8;
pub type RFC_UTCMINUTE = RFC_INT8;
pub type RFC_DTDAY = ::std::os::raw::c_int;
pub type RFC_DTWEEK = ::std::os::raw::c_int;
pub type RFC_DTMONTH = ::std::os::raw::c_int;
pub type RFC_TSECOND = ::std::os::raw::c_int;
pub type RFC_TMINUTE = ::std::os::raw::c_short;
pub type RFC_CDAY = ::std::os::raw::c_short;
pub type RFC_TID = [SAP_UC; 25usize];
pub type RFC_UNITID = [SAP_UC; 33usize];
#[doc = "< 1-byte or multibyte character, fixed size, blank padded"]
pub const _RFCTYPE_RFCTYPE_CHAR: _RFCTYPE = 0;
#[doc = "< Date ( YYYYYMMDD )"]
pub const _RFCTYPE_RFCTYPE_DATE: _RFCTYPE = 1;
#[doc = "< Packed number, any length between 1 and 16 bytes"]
pub const _RFCTYPE_RFCTYPE_BCD: _RFCTYPE = 2;
#[doc = "< Time (HHMMSS)"]
pub const _RFCTYPE_RFCTYPE_TIME: _RFCTYPE = 3;
#[doc = "< Raw data, binary, fixed length, zero padded."]
pub const _RFCTYPE_RFCTYPE_BYTE: _RFCTYPE = 4;
#[doc = "< Internal table"]
pub const _RFCTYPE_RFCTYPE_TABLE: _RFCTYPE = 5;
#[doc = "< Digits, fixed size, leading '0' padded."]
pub const _RFCTYPE_RFCTYPE_NUM: _RFCTYPE = 6;
#[doc = "< Floating point, double precision"]
pub const _RFCTYPE_RFCTYPE_FLOAT: _RFCTYPE = 7;
#[doc = "< 4-byte integer"]
pub const _RFCTYPE_RFCTYPE_INT: _RFCTYPE = 8;
#[doc = "< 2-byte integer. Obsolete, not directly supported by ABAP/4"]
pub const _RFCTYPE_RFCTYPE_INT2: _RFCTYPE = 9;
#[doc = "< 1-byte integer, unsigned. Obsolete, not directly supported by ABAP/4"]
pub const _RFCTYPE_RFCTYPE_INT1: _RFCTYPE = 10;
#[doc = "< Not supported data type."]
pub const _RFCTYPE_RFCTYPE_NULL: _RFCTYPE = 14;
#[doc = "< ABAP object."]
pub const _RFCTYPE_RFCTYPE_ABAPOBJECT: _RFCTYPE = 16;
#[doc = "< ABAP structure"]
pub const _RFCTYPE_RFCTYPE_STRUCTURE: _RFCTYPE = 17;
#[doc = "< IEEE 754r decimal floating point, 8 bytes"]
pub const _RFCTYPE_RFCTYPE_DECF16: _RFCTYPE = 23;
#[doc = "< IEEE 754r decimal floating point, 16 bytes"]
pub const _RFCTYPE_RFCTYPE_DECF34: _RFCTYPE = 24;
#[doc = "< No longer used!"]
pub const _RFCTYPE_RFCTYPE_XMLDATA: _RFCTYPE = 28;
#[doc = "< Variable-length, null-terminated string"]
pub const _RFCTYPE_RFCTYPE_STRING: _RFCTYPE = 29;
#[doc = "< Variable-length raw string, length in bytes"]
pub const _RFCTYPE_RFCTYPE_XSTRING: _RFCTYPE = 30;
#[doc = "< 8-byte integer"]
pub const _RFCTYPE_RFCTYPE_INT8: _RFCTYPE = 31;
#[doc = "< timestamp/long, 8-byte integer"]
pub const _RFCTYPE_RFCTYPE_UTCLONG: _RFCTYPE = 32;
#[doc = "< timestamp/second, 8-byte integer"]
pub const _RFCTYPE_RFCTYPE_UTCSECOND: _RFCTYPE = 33;
#[doc = "< timestamp/minute, 8-byte integer"]
pub const _RFCTYPE_RFCTYPE_UTCMINUTE: _RFCTYPE = 34;
#[doc = "< date/day , 4-byte integer"]
pub const _RFCTYPE_RFCTYPE_DTDAY: _RFCTYPE = 35;
#[doc = "< date/week, 4-byte integer"]
pub const _RFCTYPE_RFCTYPE_DTWEEK: _RFCTYPE = 36;
#[doc = "< date/month, 4-byte integer"]
pub const _RFCTYPE_RFCTYPE_DTMONTH: _RFCTYPE = 37;
#[doc = "< time/second, 4-byte integer"]
pub const _RFCTYPE_RFCTYPE_TSECOND: _RFCTYPE = 38;
#[doc = "< time/minute, 2-byte integer"]
pub const _RFCTYPE_RFCTYPE_TMINUTE: _RFCTYPE = 39;
#[doc = "< calendar day, 2-byte integer"]
pub const _RFCTYPE_RFCTYPE_CDAY: _RFCTYPE = 40;
#[doc = "< boxed structure, note: not supported by NW RFC lib"]
pub const _RFCTYPE_RFCTYPE_BOX: _RFCTYPE = 41;
#[doc = "< boxed client dependent structure, note: not supported by NW RFC lib"]
pub const _RFCTYPE_RFCTYPE_GENERIC_BOX: _RFCTYPE = 42;
#[doc = "< the max. value of RFCTYPEs"]
pub const _RFCTYPE__RFCTYPE_max_value: _RFCTYPE = 43;
#[doc = " \\enum _RFCTYPE\n \\ingroup api\n\n RFCTYPE is used in field descriptions (#RFC_FIELD_DESC) and parameter descriptions\n (#RFC_PARAMETER_DESC) and denotes the ABAP data type of the corresponding field/parameter."]
pub type _RFCTYPE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFCTYPE\n \\ingroup api\n\n RFCTYPE is used in field descriptions (#RFC_FIELD_DESC) and parameter descriptions\n (#RFC_PARAMETER_DESC) and denotes the ABAP data type of the corresponding field/parameter."]
pub use self::_RFCTYPE as RFCTYPE;
#[doc = "< Everything O.K. Used by every function"]
pub const _RFC_RC_RFC_OK: _RFC_RC = 0;
#[doc = "< Error in Network & Communication layer"]
pub const _RFC_RC_RFC_COMMUNICATION_FAILURE: _RFC_RC = 1;
#[doc = "< Unable to logon to SAP system. Invalid password, user locked, etc."]
pub const _RFC_RC_RFC_LOGON_FAILURE: _RFC_RC = 2;
#[doc = "< SAP system runtime error (SYSTEM_FAILURE): Shortdump on the backend side"]
pub const _RFC_RC_RFC_ABAP_RUNTIME_FAILURE: _RFC_RC = 3;
#[doc = "< The called function module raised an E-, A- or X-Message"]
pub const _RFC_RC_RFC_ABAP_MESSAGE: _RFC_RC = 4;
#[doc = "< The called function module raised an Exception (RAISE or MESSAGE ... RAISING)"]
pub const _RFC_RC_RFC_ABAP_EXCEPTION: _RFC_RC = 5;
#[doc = "< Connection closed by the other side"]
pub const _RFC_RC_RFC_CLOSED: _RFC_RC = 6;
#[doc = "< No longer used"]
pub const _RFC_RC_RFC_CANCELED: _RFC_RC = 7;
#[doc = "< Time out"]
pub const _RFC_RC_RFC_TIMEOUT: _RFC_RC = 8;
#[doc = "< Memory insufficient"]
pub const _RFC_RC_RFC_MEMORY_INSUFFICIENT: _RFC_RC = 9;
#[doc = "< Version mismatch"]
pub const _RFC_RC_RFC_VERSION_MISMATCH: _RFC_RC = 10;
#[doc = "< The received data has an unsupported format"]
pub const _RFC_RC_RFC_INVALID_PROTOCOL: _RFC_RC = 11;
#[doc = "< A problem while serializing or deserializing RFM parameters"]
pub const _RFC_RC_RFC_SERIALIZATION_FAILURE: _RFC_RC = 12;
#[doc = "< An invalid handle was passed to an API call"]
pub const _RFC_RC_RFC_INVALID_HANDLE: _RFC_RC = 13;
#[doc = "< RfcListenAndDispatch did not receive an RFC request during the timeout period"]
pub const _RFC_RC_RFC_RETRY: _RFC_RC = 14;
#[doc = "< Error in external custom code. (E.g. in the function handlers or tRFC handlers.) Results in SYSTEM_FAILURE"]
pub const _RFC_RC_RFC_EXTERNAL_FAILURE: _RFC_RC = 15;
#[doc = "< Inbound tRFC Call already executed (needs to be returned from RFC_ON_CHECK_TRANSACTION in case the TID is already known and successfully processed before.)"]
pub const _RFC_RC_RFC_EXECUTED: _RFC_RC = 16;
#[doc = "< Function or structure definition not found (Metadata API)"]
pub const _RFC_RC_RFC_NOT_FOUND: _RFC_RC = 17;
#[doc = "< The operation is not supported on that handle"]
pub const _RFC_RC_RFC_NOT_SUPPORTED: _RFC_RC = 18;
#[doc = "< The operation is not supported on that handle at the current point of time (e.g. trying a callback on a server handle, while not in a call)"]
pub const _RFC_RC_RFC_ILLEGAL_STATE: _RFC_RC = 19;
#[doc = "< An invalid parameter was passed to an API call, (e.g. invalid name, type or length)"]
pub const _RFC_RC_RFC_INVALID_PARAMETER: _RFC_RC = 20;
#[doc = "< Codepage conversion error"]
pub const _RFC_RC_RFC_CODEPAGE_CONVERSION_FAILURE: _RFC_RC = 21;
#[doc = "< Error while converting a parameter to the correct data type"]
pub const _RFC_RC_RFC_CONVERSION_FAILURE: _RFC_RC = 22;
#[doc = "< The given buffer was to small to hold the entire parameter. Data has been truncated."]
pub const _RFC_RC_RFC_BUFFER_TOO_SMALL: _RFC_RC = 23;
#[doc = "< Trying to move the current position before the first row of the table"]
pub const _RFC_RC_RFC_TABLE_MOVE_BOF: _RFC_RC = 24;
#[doc = "< Trying to move the current position after the last row of the table"]
pub const _RFC_RC_RFC_TABLE_MOVE_EOF: _RFC_RC = 25;
#[doc = "< Failed to start and attach SAPGUI to the RFC connection"]
pub const _RFC_RC_RFC_START_SAPGUI_FAILURE: _RFC_RC = 26;
#[doc = "< The called function module raised a class based exception"]
pub const _RFC_RC_RFC_ABAP_CLASS_EXCEPTION: _RFC_RC = 27;
#[doc = "< \"Something\" went wrong, but I don't know what..."]
pub const _RFC_RC_RFC_UNKNOWN_ERROR: _RFC_RC = 28;
#[doc = "< Authorization check error"]
pub const _RFC_RC_RFC_AUTHORIZATION_FAILURE: _RFC_RC = 29;
#[doc = "< The authentication handler (RFC_ON_AUTHENTICATION_CHECK) failed to authenticate the user trying to log on"]
pub const _RFC_RC_RFC_AUTHENTICATION_FAILURE: _RFC_RC = 30;
#[doc = "< Error when dealing with functions provided by the cryptolibrary"]
pub const _RFC_RC_RFC_CRYPTOLIB_FAILURE: _RFC_RC = 31;
#[doc = "< Error when dealing with io functions, streams etc"]
pub const _RFC_RC_RFC_IO_FAILURE: _RFC_RC = 32;
#[doc = "< Requesting or freeing critical sections or mutex failed"]
pub const _RFC_RC_RFC_LOCKING_FAILURE: _RFC_RC = 33;
#[doc = "< Don't use"]
pub const _RFC_RC__RFC_RC_max_value: _RFC_RC = 34;
#[doc = " \\enum _RFC_RC\n \\ingroup api\n\n RFC return codes used by all functions that do not directly return a handle.\n Also used as error indicator in the structure #RFC_ERROR_INFO::code."]
pub type _RFC_RC = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_RC\n \\ingroup api\n\n RFC return codes used by all functions that do not directly return a handle.\n Also used as error indicator in the structure #RFC_ERROR_INFO::code."]
pub use self::_RFC_RC as RFC_RC;
#[doc = "< OK"]
pub const _RFC_ERROR_GROUP_OK: _RFC_ERROR_GROUP = 0;
#[doc = "< ABAP Exception raised in ABAP function modules"]
pub const _RFC_ERROR_GROUP_ABAP_APPLICATION_FAILURE: _RFC_ERROR_GROUP = 1;
#[doc = "< ABAP Message raised in ABAP function modules or in ABAP runtime of the backend (e.g Kernel)"]
pub const _RFC_ERROR_GROUP_ABAP_RUNTIME_FAILURE: _RFC_ERROR_GROUP = 2;
#[doc = "< Error message raised when logon fails"]
pub const _RFC_ERROR_GROUP_LOGON_FAILURE: _RFC_ERROR_GROUP = 3;
#[doc = "< Problems with the network connection (or backend broke down and killed the connection)"]
pub const _RFC_ERROR_GROUP_COMMUNICATION_FAILURE: _RFC_ERROR_GROUP = 4;
#[doc = "< Problems in the RFC runtime of the external program (i.e \"this\" library)"]
pub const _RFC_ERROR_GROUP_EXTERNAL_RUNTIME_FAILURE: _RFC_ERROR_GROUP = 5;
#[doc = "< Problems in the external program (e.g in the external server implementation)"]
pub const _RFC_ERROR_GROUP_EXTERNAL_APPLICATION_FAILURE: _RFC_ERROR_GROUP = 6;
#[doc = "< Problems raised in the authorization check handler provided by the external server implementation"]
pub const _RFC_ERROR_GROUP_EXTERNAL_AUTHORIZATION_FAILURE: _RFC_ERROR_GROUP = 7;
#[doc = "< Problems raised by the authentication handler (RFC_ON_AUTHENTICATION_CHECK)"]
pub const _RFC_ERROR_GROUP_EXTERNAL_AUTHENTICATION_FAILURE: _RFC_ERROR_GROUP = 8;
#[doc = "< Problems when dealing with functions provided by the cryptolibrary"]
pub const _RFC_ERROR_GROUP_CRYPTOLIB_FAILURE: _RFC_ERROR_GROUP = 9;
#[doc = "< Requesting or freeing critical sections or mutex failed"]
pub const _RFC_ERROR_GROUP_LOCKING_FAILURE: _RFC_ERROR_GROUP = 10;
#[doc = " \\enum _RFC_ERROR_GROUP\n \\ingroup api\n\n Groups several error conditions together, depending on the \"layer\" to which they belong.\n Used in the structure #RFC_ERROR_INFO::group."]
pub type _RFC_ERROR_GROUP = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_ERROR_GROUP\n \\ingroup api\n\n Groups several error conditions together, depending on the \"layer\" to which they belong.\n Used in the structure #RFC_ERROR_INFO::group."]
pub use self::_RFC_ERROR_GROUP as RFC_ERROR_GROUP;
#[doc = " \\struct _RFC_ERROR_INFO\n \\ingroup api\n\n Used in all functions of the NW RFC library to return detailed information about\n an error that has just occurred. This can be an error that the communication partner\n sent back to us, an error that occurred in the network layer or operating system,\n an internal error in the NW RFC library or an error that the application programmer\n (i.e. you) has committed...\n\n Within a server function implementation, the application programmer (you) can return\n this structure to the RFC library in order to specify the error type & message that\n you want to send back to the backend."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_ERROR_INFO {
    #[doc = "< Error code. Should be the same as the API returns if the API has return type RFC_RC"]
    pub code: RFC_RC,
    #[doc = "< Error group"]
    pub group: RFC_ERROR_GROUP,
    #[doc = "< Error key"]
    pub key: [SAP_UC; 128usize],
    #[doc = "< Error message"]
    pub message: [SAP_UC; 512usize],
    #[doc = "< ABAP message ID , or class"]
    pub abapMsgClass: [SAP_UC; 21usize],
    #[doc = "< ABAP message type, e.g. 'E', 'A' or 'X'"]
    pub abapMsgType: [SAP_UC; 2usize],
    #[doc = "< ABAP message number"]
    pub abapMsgNumber: [RFC_NUM; 4usize],
    #[doc = "< ABAP message details field 1, corresponds to SY-MSGV1"]
    pub abapMsgV1: [SAP_UC; 51usize],
    #[doc = "< ABAP message details field 2, corresponds to SY-MSGV2"]
    pub abapMsgV2: [SAP_UC; 51usize],
    #[doc = "< ABAP message details field 3, corresponds to SY-MSGV3"]
    pub abapMsgV3: [SAP_UC; 51usize],
    #[doc = "< ABAP message details field 4, corresponds to SY-MSGV4"]
    pub abapMsgV4: [SAP_UC; 51usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_ERROR_INFO"][::std::mem::size_of::<_RFC_ERROR_INFO>() - 1752usize];
    ["Alignment of _RFC_ERROR_INFO"][::std::mem::align_of::<_RFC_ERROR_INFO>() - 4usize];
    ["Offset of field: _RFC_ERROR_INFO::code"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, code) - 0usize];
    ["Offset of field: _RFC_ERROR_INFO::group"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, group) - 4usize];
    ["Offset of field: _RFC_ERROR_INFO::key"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, key) - 8usize];
    ["Offset of field: _RFC_ERROR_INFO::message"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, message) - 264usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgClass"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgClass) - 1288usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgType"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgType) - 1330usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgNumber"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgNumber) - 1334usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgV1"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgV1) - 1342usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgV2"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgV2) - 1444usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgV3"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgV3) - 1546usize];
    ["Offset of field: _RFC_ERROR_INFO::abapMsgV4"]
        [::std::mem::offset_of!(_RFC_ERROR_INFO, abapMsgV4) - 1648usize];
};
#[doc = " \\struct _RFC_ERROR_INFO\n \\ingroup api\n\n Used in all functions of the NW RFC library to return detailed information about\n an error that has just occurred. This can be an error that the communication partner\n sent back to us, an error that occurred in the network layer or operating system,\n an internal error in the NW RFC library or an error that the application programmer\n (i.e. you) has committed...\n\n Within a server function implementation, the application programmer (you) can return\n this structure to the RFC library in order to specify the error type & message that\n you want to send back to the backend."]
pub type RFC_ERROR_INFO = _RFC_ERROR_INFO;
#[doc = " \\struct _RFC_ATTRIBUTES\n \\ingroup connection\n\n Structure returned by RfcGetConnectionAttributes() giving some\n information about the partner system on the other side of this RFC connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_ATTRIBUTES {
    #[doc = "< RFC destination"]
    pub dest: [SAP_UC; 65usize],
    #[doc = "< Own host name"]
    pub host: [SAP_UC; 101usize],
    #[doc = "< Partner host name"]
    pub partnerHost: [SAP_UC; 101usize],
    #[doc = "< R/3 system number"]
    pub sysNumber: [SAP_UC; 3usize],
    #[doc = "< R/3 system ID"]
    pub sysId: [SAP_UC; 9usize],
    #[doc = "< Client (\"Mandant\")"]
    pub client: [SAP_UC; 4usize],
    #[doc = "< User"]
    pub user: [SAP_UC; 13usize],
    #[doc = "< Language"]
    pub language: [SAP_UC; 3usize],
    #[doc = "< Trace level (0-3)"]
    pub trace: [SAP_UC; 2usize],
    #[doc = "< 2-byte ISO-Language"]
    pub isoLanguage: [SAP_UC; 3usize],
    #[doc = "< Own code page"]
    pub codepage: [SAP_UC; 5usize],
    #[doc = "< Partner code page"]
    pub partnerCodepage: [SAP_UC; 5usize],
    #[doc = "< C/S: RFC Client / RFC Server"]
    pub rfcRole: [SAP_UC; 2usize],
    #[doc = "< 2/3/E/R: R/2,R/3,Ext,Reg.Ext"]
    pub type_: [SAP_UC; 2usize],
    #[doc = "< 2/3/E/R: R/2,R/3,Ext,Reg.Ext"]
    pub partnerType: [SAP_UC; 2usize],
    #[doc = "< My system release"]
    pub rel: [SAP_UC; 5usize],
    #[doc = "< Partner system release"]
    pub partnerRel: [SAP_UC; 5usize],
    #[doc = "< Partner kernel release"]
    pub kernelRel: [SAP_UC; 5usize],
    #[doc = "< CPI-C Conversation ID"]
    pub cpicConvId: [SAP_UC; 9usize],
    #[doc = "< Name of the calling APAB program (report, module pool)"]
    pub progName: [SAP_UC; 129usize],
    #[doc = "< Number of bytes per character in the backend's current codepage. Note this is different from the semantics of the PCS parameter."]
    pub partnerBytesPerChar: [SAP_UC; 2usize],
    #[doc = "<  Partner system code page"]
    pub partnerSystemCodepage: [SAP_UC; 5usize],
    #[doc = "< Partner IP"]
    pub partnerIP: [SAP_UC; 16usize],
    #[doc = "< Partner IPv6"]
    pub partnerIPv6: [SAP_UC; 46usize],
    #[doc = "< Reserved for later use"]
    pub reserved: [SAP_UC; 17usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_ATTRIBUTES"][::std::mem::size_of::<_RFC_ATTRIBUTES>() - 1118usize];
    ["Alignment of _RFC_ATTRIBUTES"][::std::mem::align_of::<_RFC_ATTRIBUTES>() - 2usize];
    ["Offset of field: _RFC_ATTRIBUTES::dest"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, dest) - 0usize];
    ["Offset of field: _RFC_ATTRIBUTES::host"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, host) - 130usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerHost"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerHost) - 332usize];
    ["Offset of field: _RFC_ATTRIBUTES::sysNumber"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, sysNumber) - 534usize];
    ["Offset of field: _RFC_ATTRIBUTES::sysId"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, sysId) - 540usize];
    ["Offset of field: _RFC_ATTRIBUTES::client"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, client) - 558usize];
    ["Offset of field: _RFC_ATTRIBUTES::user"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, user) - 566usize];
    ["Offset of field: _RFC_ATTRIBUTES::language"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, language) - 592usize];
    ["Offset of field: _RFC_ATTRIBUTES::trace"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, trace) - 598usize];
    ["Offset of field: _RFC_ATTRIBUTES::isoLanguage"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, isoLanguage) - 602usize];
    ["Offset of field: _RFC_ATTRIBUTES::codepage"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, codepage) - 608usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerCodepage"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerCodepage) - 618usize];
    ["Offset of field: _RFC_ATTRIBUTES::rfcRole"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, rfcRole) - 628usize];
    ["Offset of field: _RFC_ATTRIBUTES::type_"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, type_) - 632usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerType"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerType) - 636usize];
    ["Offset of field: _RFC_ATTRIBUTES::rel"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, rel) - 640usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerRel"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerRel) - 650usize];
    ["Offset of field: _RFC_ATTRIBUTES::kernelRel"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, kernelRel) - 660usize];
    ["Offset of field: _RFC_ATTRIBUTES::cpicConvId"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, cpicConvId) - 670usize];
    ["Offset of field: _RFC_ATTRIBUTES::progName"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, progName) - 688usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerBytesPerChar"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerBytesPerChar) - 946usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerSystemCodepage"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerSystemCodepage) - 950usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerIP"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerIP) - 960usize];
    ["Offset of field: _RFC_ATTRIBUTES::partnerIPv6"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, partnerIPv6) - 992usize];
    ["Offset of field: _RFC_ATTRIBUTES::reserved"]
        [::std::mem::offset_of!(_RFC_ATTRIBUTES, reserved) - 1084usize];
};
#[doc = " \\struct _RFC_ATTRIBUTES\n \\ingroup connection\n\n Structure returned by RfcGetConnectionAttributes() giving some\n information about the partner system on the other side of this RFC connection."]
pub type RFC_ATTRIBUTES = _RFC_ATTRIBUTES;
#[doc = " \\struct _RFC_ATTRIBUTES\n \\ingroup connection\n\n Structure returned by RfcGetConnectionAttributes() giving some\n information about the partner system on the other side of this RFC connection."]
pub type P_RFC_ATTRIBUTES = *mut _RFC_ATTRIBUTES;
#[doc = " \\struct _RFC_SECURITY_ATTRIBUTES\n \\ingroup connection\n\n Structure passed to the RFC_SERVER_AUTHORIZATION_HANDLER giving some\n security related information about the calling ABAP partner of an incoming RFC call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_SECURITY_ATTRIBUTES {
    #[doc = "< Name of the called function module"]
    pub functionName: *mut SAP_UC,
    #[doc = "< Calling ABAP system ID"]
    pub sysId: *mut SAP_UC,
    #[doc = "< ABAP Client (\"Mandant\")"]
    pub client: *mut SAP_UC,
    #[doc = "< ABAP User"]
    pub user: *mut SAP_UC,
    #[doc = "< Name of the calling APAB program (report, module pool)"]
    pub progName: *mut SAP_UC,
    #[doc = "< SNC name of the calling ABAP system, if SNC is enabled. Use this only for display or logging purposes."]
    pub sncName: *mut SAP_UC,
    #[doc = "< Logon ticket of the ABAP user, if SSO2 or assertion tickets are enabled"]
    pub ssoTicket: *mut SAP_UC,
    #[doc = "< Canonical representation of the SNC name of the calling ABAP system, if SNC is enabled. Use this for comparisons and access checks."]
    pub sncAclKey: *mut SAP_RAW,
    #[doc = "< Length of the above SNC AclKey"]
    pub sncAclKeyLength: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_SECURITY_ATTRIBUTES"]
        [::std::mem::size_of::<_RFC_SECURITY_ATTRIBUTES>() - 72usize];
    ["Alignment of _RFC_SECURITY_ATTRIBUTES"]
        [::std::mem::align_of::<_RFC_SECURITY_ATTRIBUTES>() - 8usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::functionName"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, functionName) - 0usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::sysId"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, sysId) - 8usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::client"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, client) - 16usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::user"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, user) - 24usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::progName"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, progName) - 32usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::sncName"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, sncName) - 40usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::ssoTicket"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, ssoTicket) - 48usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::sncAclKey"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, sncAclKey) - 56usize];
    ["Offset of field: _RFC_SECURITY_ATTRIBUTES::sncAclKeyLength"]
        [::std::mem::offset_of!(_RFC_SECURITY_ATTRIBUTES, sncAclKeyLength) - 64usize];
};
#[doc = " \\struct _RFC_SECURITY_ATTRIBUTES\n \\ingroup connection\n\n Structure passed to the RFC_SERVER_AUTHORIZATION_HANDLER giving some\n security related information about the calling ABAP partner of an incoming RFC call."]
pub type RFC_SECURITY_ATTRIBUTES = _RFC_SECURITY_ATTRIBUTES;
#[doc = " \\struct _RFC_SECURITY_ATTRIBUTES\n \\ingroup connection\n\n Structure passed to the RFC_SERVER_AUTHORIZATION_HANDLER giving some\n security related information about the calling ABAP partner of an incoming RFC call."]
pub type P_RFC_SECURITY_ATTRIBUTES = *mut _RFC_SECURITY_ATTRIBUTES;
#[doc = " \\struct _RFC_UNIT_ATTRIBUTES\n \\ingroup bgrfc\n\n If the external program is the sender of the bgRFC unit, this structure is used to set a\n bunch of special attributes that determine, how a bgRFC Unit will be processed in the backend.\n The fields user, client, tCode and program are optional. If left empty, the NW RFC lib will\n fill them with default values. The fields hostname, sendingDate and sendingTime should not be\n filled, the lib fills them, when the unit is submitted.\n\n If the external program is the receiver of the bgRFC unit, you can use RfcGetServerContext()\n to obtain the values that were sent by the backend."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_UNIT_ATTRIBUTES {
    #[doc = "< If != 0, the backend will write kernel traces, while executing this unit."]
    pub kernelTrace: ::std::os::raw::c_short,
    #[doc = "< If != 0, the backend will write statistic records, while executing this unit."]
    pub satTrace: ::std::os::raw::c_short,
    #[doc = "< If != 0, the backend will keep a \"history\" for this unit."]
    pub unitHistory: ::std::os::raw::c_short,
    #[doc = "< Used only for type Q: If != 0, the unit will be written to the queue, but not processed. The unit can then be started manually in the ABAP debugger."]
    pub lock: ::std::os::raw::c_short,
    #[doc = "< Per default the backend will check during execution of a unit, whether one\n< of the unit's function modules triggers an explicit or implicit COMMIT WORK.\n< In this case the unit is aborted with an error, because the transactional\n< integrity of this unit cannot be guaranteed. By setting \"noCommitCheck\" to\n< true (!=0), this behavior can be suppressed, meaning the unit will be executed\n< anyway, even if one of its function modules \"misbehaves\" and triggers a COMMIT WORK."]
    pub noCommitCheck: ::std::os::raw::c_short,
    #[doc = "< Sender User (optional). Default is current operating system User."]
    pub user: [SAP_UC; 13usize],
    #[doc = "< Sender Client (\"Mandant\") (optional). Default is \"000\"."]
    pub client: [SAP_UC; 4usize],
    #[doc = "< Sender Transaction Code (optional). Default is \"\"."]
    pub tCode: [SAP_UC; 21usize],
    #[doc = "< Sender Program (optional). Default is current executable name."]
    pub program: [SAP_UC; 41usize],
    #[doc = "< Sender hostname. Used only when the external program is server. In the client case the nwrfclib fills this automatically."]
    pub hostname: [SAP_UC; 41usize],
    #[doc = "< Sending date in UTC (GMT-0). Used only when the external program is server. In the client case the nwrfclib fills this automatically."]
    pub sendingDate: RFC_DATE,
    #[doc = "< Sending time in UTC (GMT-0). Used only when the external program is server. In the client case the nwrfclib fills this automatically."]
    pub sendingTime: RFC_TIME,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_UNIT_ATTRIBUTES"][::std::mem::size_of::<_RFC_UNIT_ATTRIBUTES>() - 278usize];
    ["Alignment of _RFC_UNIT_ATTRIBUTES"][::std::mem::align_of::<_RFC_UNIT_ATTRIBUTES>() - 2usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::kernelTrace"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, kernelTrace) - 0usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::satTrace"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, satTrace) - 2usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::unitHistory"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, unitHistory) - 4usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::lock"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, lock) - 6usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::noCommitCheck"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, noCommitCheck) - 8usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::user"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, user) - 10usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::client"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, client) - 36usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::tCode"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, tCode) - 44usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::program"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, program) - 86usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::hostname"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, hostname) - 168usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::sendingDate"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, sendingDate) - 250usize];
    ["Offset of field: _RFC_UNIT_ATTRIBUTES::sendingTime"]
        [::std::mem::offset_of!(_RFC_UNIT_ATTRIBUTES, sendingTime) - 266usize];
};
#[doc = " \\struct _RFC_UNIT_ATTRIBUTES\n \\ingroup bgrfc\n\n If the external program is the sender of the bgRFC unit, this structure is used to set a\n bunch of special attributes that determine, how a bgRFC Unit will be processed in the backend.\n The fields user, client, tCode and program are optional. If left empty, the NW RFC lib will\n fill them with default values. The fields hostname, sendingDate and sendingTime should not be\n filled, the lib fills them, when the unit is submitted.\n\n If the external program is the receiver of the bgRFC unit, you can use RfcGetServerContext()\n to obtain the values that were sent by the backend."]
pub type RFC_UNIT_ATTRIBUTES = _RFC_UNIT_ATTRIBUTES;
#[doc = " \\struct _RFC_UNIT_IDENTIFIER\n \\ingroup bgrfc\n\n For convenience combines a unit's ID and its type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_UNIT_IDENTIFIER {
    #[doc = "< 'T' for \"transactional\" behavior (unit is executed synchronously), 'Q' for \"queued\" behavior (unit is written into a queue and executed asynchronously)"]
    pub unitType: SAP_UC,
    #[doc = "< The 32 digit unit ID of the background unit."]
    pub unitID: RFC_UNITID,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_UNIT_IDENTIFIER"][::std::mem::size_of::<_RFC_UNIT_IDENTIFIER>() - 68usize];
    ["Alignment of _RFC_UNIT_IDENTIFIER"][::std::mem::align_of::<_RFC_UNIT_IDENTIFIER>() - 2usize];
    ["Offset of field: _RFC_UNIT_IDENTIFIER::unitType"]
        [::std::mem::offset_of!(_RFC_UNIT_IDENTIFIER, unitType) - 0usize];
    ["Offset of field: _RFC_UNIT_IDENTIFIER::unitID"]
        [::std::mem::offset_of!(_RFC_UNIT_IDENTIFIER, unitID) - 2usize];
};
#[doc = " \\struct _RFC_UNIT_IDENTIFIER\n \\ingroup bgrfc\n\n For convenience combines a unit's ID and its type."]
pub type RFC_UNIT_IDENTIFIER = _RFC_UNIT_IDENTIFIER;
#[doc = "< No information for this unit ID and unit type can be found in the target system. If you are sure, that target system, unit ID and unit type are correct, it means that your previous attempt did not even reach the target system. Send the unit again. However, if you get this status after the Confirm step has already been executed, it means that everything is ok. Don't re-execute in this case!"]
pub const _RFC_UNIT_STATE_RFC_UNIT_NOT_FOUND: _RFC_UNIT_STATE = 0;
#[doc = "< Backend system is still in the process of persisting (or executing if type 'T') the payload data. Give it some more time and check the state again later. If this takes \"too long\", an admin should probably have a look at why there is no progress here."]
pub const _RFC_UNIT_STATE_RFC_UNIT_IN_PROCESS: _RFC_UNIT_STATE = 1;
#[doc = "< Data has been persisted (or executed if type 'T') ok on receiver side. Confirm event may now be triggered."]
pub const _RFC_UNIT_STATE_RFC_UNIT_COMMITTED: _RFC_UNIT_STATE = 2;
#[doc = "< An error of any type has occurred. Unit needs to be resent."]
pub const _RFC_UNIT_STATE_RFC_UNIT_ROLLED_BACK: _RFC_UNIT_STATE = 3;
#[doc = "< Temporary state between the Confirm event and the time, when the status data will be erased for good. Nothing to be done. Just delete the payload and status information on your side."]
pub const _RFC_UNIT_STATE_RFC_UNIT_CONFIRMED: _RFC_UNIT_STATE = 4;
#[doc = " \\enum _RFC_UNIT_STATE\n \\ingroup bgrfc\n\n Used in RfcGetUnitState() for inquiring the processing status of a background Unit that\n we (or someone else) sent into this backend."]
pub type _RFC_UNIT_STATE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_UNIT_STATE\n \\ingroup bgrfc\n\n Used in RfcGetUnitState() for inquiring the processing status of a background Unit that\n we (or someone else) sent into this backend."]
pub use self::_RFC_UNIT_STATE as RFC_UNIT_STATE;
pub type RFC_ABAP_NAME = [RFC_CHAR; 31usize];
pub type RFC_PARAMETER_DEFVALUE = [RFC_CHAR; 31usize];
pub type RFC_PARAMETER_TEXT = [RFC_CHAR; 80usize];
#[doc = "< It's a standard synchronous RFC call."]
pub const _RFC_CALL_TYPE_RFC_SYNCHRONOUS: _RFC_CALL_TYPE = 0;
#[doc = "< This function call is part of a transactional LUW (tRFC)."]
pub const _RFC_CALL_TYPE_RFC_TRANSACTIONAL: _RFC_CALL_TYPE = 1;
#[doc = "< This function call is part of a queued LUW (qRFC)."]
pub const _RFC_CALL_TYPE_RFC_QUEUED: _RFC_CALL_TYPE = 2;
#[doc = "< This function call is part of a background LUW (bgRFC)."]
pub const _RFC_CALL_TYPE_RFC_BACKGROUND_UNIT: _RFC_CALL_TYPE = 3;
#[doc = " \\enum _RFC_CALL_TYPE\n \\ingroup connection\n\n Used in RfcGetServerContext() for inquiring the type of\n an incoming function call from the backend."]
pub type _RFC_CALL_TYPE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_CALL_TYPE\n \\ingroup connection\n\n Used in RfcGetServerContext() for inquiring the type of\n an incoming function call from the backend."]
pub use self::_RFC_CALL_TYPE as RFC_CALL_TYPE;
#[doc = " \\struct _RFC_SERVER_CONTEXT\n \\ingroup connection\n\n Used in RfcGetServerContext() for obtaining more information about the\n current incoming function call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_SERVER_CONTEXT {
    #[doc = "< Specifies the type of function call. Depending on the value of this field, some of the other fields of this struct may be filled."]
    pub type_: RFC_CALL_TYPE,
    #[doc = "< If type is RFC_TRANSACTIONAL or RFC_QUEUED, this field is filled with the 24 digit TID of the tRFC/qRFC unit."]
    pub tid: RFC_TID,
    #[doc = "< If type is RFC_BACKGROUND_UNIT, this pointer is set to the unit identifier of the LUW. Note: the pointer is valid only during the execution context of your server function."]
    pub unitIdentifier: *mut RFC_UNIT_IDENTIFIER,
    #[doc = "< If type is RFC_BACKGROUND_UNIT, this pointer is set to the unit attributes of the LUW. Note: the pointer is valid only during the execution context of your server function."]
    pub unitAttributes: *mut RFC_UNIT_ATTRIBUTES,
    #[doc = "< Specifies whether the current server connection is processing stateful RFC requests (assigned permanently to one fixed ABAP user session)."]
    pub isStateful: ::std::os::raw::c_uint,
    #[doc = "< Contains a unique zero-terminated session ID, identifying the ABAP or external user session. Can be used in stateful servers to store session context in a hashmap."]
    pub sessionID: [SAP_UC; 33usize],
    #[doc = "< Number of entries in the queue name list (see below)"]
    pub queueNamesCount: ::std::os::raw::c_uint,
    #[doc = "< If the current call is a bgRFC or qRFC with inbound queue(s) (receiver side queuing), this field contains the list of queue names. Important: this pointer is valid only within the current call context (server function invocation). After the current call is finished, the memory will be freed again! If you need the data at a later time, you need to copy it into your own memory"]
    pub queueNames: *mut *mut SAP_UC,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_SERVER_CONTEXT"][::std::mem::size_of::<_RFC_SERVER_CONTEXT>() - 160usize];
    ["Alignment of _RFC_SERVER_CONTEXT"][::std::mem::align_of::<_RFC_SERVER_CONTEXT>() - 8usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::type_"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, type_) - 0usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::tid"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, tid) - 4usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::unitIdentifier"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, unitIdentifier) - 56usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::unitAttributes"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, unitAttributes) - 64usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::isStateful"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, isStateful) - 72usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::sessionID"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, sessionID) - 76usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::queueNamesCount"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, queueNamesCount) - 144usize];
    ["Offset of field: _RFC_SERVER_CONTEXT::queueNames"]
        [::std::mem::offset_of!(_RFC_SERVER_CONTEXT, queueNames) - 152usize];
};
#[doc = " \\struct _RFC_SERVER_CONTEXT\n \\ingroup connection\n\n Used in RfcGetServerContext() for obtaining more information about the\n current incoming function call."]
pub type RFC_SERVER_CONTEXT = _RFC_SERVER_CONTEXT;
#[doc = "< No authentication data was provided"]
pub const _RFC_AUTHENTICATION_TYPE_RFC_AUTH_NONE: _RFC_AUTHENTICATION_TYPE = 0;
#[doc = "< Authentication with user and password"]
pub const _RFC_AUTHENTICATION_TYPE_RFC_AUTH_BASIC: _RFC_AUTHENTICATION_TYPE = 1;
#[doc = "< Authentication with x509 certificate"]
pub const _RFC_AUTHENTICATION_TYPE_RFC_AUTH_X509: _RFC_AUTHENTICATION_TYPE = 2;
#[doc = "< Authentication with assertion ticket"]
pub const _RFC_AUTHENTICATION_TYPE_RFC_AUTH_SSO: _RFC_AUTHENTICATION_TYPE = 3;
#[doc = " \\enum _RFC_AUTHENTICATION_TYPE\n \\ingroup autoserver\n\n Type of authentication method used by the backend authentication handler (RFC_ON_AUTHENTICATION_CHECK)."]
pub type _RFC_AUTHENTICATION_TYPE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_AUTHENTICATION_TYPE\n \\ingroup autoserver\n\n Type of authentication method used by the backend authentication handler (RFC_ON_AUTHENTICATION_CHECK)."]
pub use self::_RFC_AUTHENTICATION_TYPE as RFC_AUTHENTICATION_TYPE;
#[doc = " \\struct _RFC_CERTIFICATE_DATA\n \\ingroup autoserver\n\n Compact structure containing relevant information about the x509 certificate provided by the RFC client. Can be accessed by the\n authentication handler (RFC_ON_AUTHENTICATION_CHECK) and used for validating the user trying to log on."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_CERTIFICATE_DATA {
    #[doc = "< Distinguished name of the user of the certificate"]
    pub subject: *const SAP_UC,
    #[doc = "< Distinguished name of the certificate authority (CA) that issued the certificate"]
    pub issuer: *const SAP_UC,
    #[doc = "< UTC Expiration date on which the certificate is no longer considered valid"]
    pub validTo: SAP_ULLONG,
    #[doc = "< UTC Starting date since the certificate is valid"]
    pub validFrom: SAP_ULLONG,
    #[doc = "< Fingerprint of the public key"]
    pub signature: *const SAP_UC,
    #[doc = "< Pointer to the next certificate in the chain if any"]
    pub next: *mut _RFC_CERTIFICATE_DATA,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_CERTIFICATE_DATA"][::std::mem::size_of::<_RFC_CERTIFICATE_DATA>() - 48usize];
    ["Alignment of _RFC_CERTIFICATE_DATA"]
        [::std::mem::align_of::<_RFC_CERTIFICATE_DATA>() - 8usize];
    ["Offset of field: _RFC_CERTIFICATE_DATA::subject"]
        [::std::mem::offset_of!(_RFC_CERTIFICATE_DATA, subject) - 0usize];
    ["Offset of field: _RFC_CERTIFICATE_DATA::issuer"]
        [::std::mem::offset_of!(_RFC_CERTIFICATE_DATA, issuer) - 8usize];
    ["Offset of field: _RFC_CERTIFICATE_DATA::validTo"]
        [::std::mem::offset_of!(_RFC_CERTIFICATE_DATA, validTo) - 16usize];
    ["Offset of field: _RFC_CERTIFICATE_DATA::validFrom"]
        [::std::mem::offset_of!(_RFC_CERTIFICATE_DATA, validFrom) - 24usize];
    ["Offset of field: _RFC_CERTIFICATE_DATA::signature"]
        [::std::mem::offset_of!(_RFC_CERTIFICATE_DATA, signature) - 32usize];
    ["Offset of field: _RFC_CERTIFICATE_DATA::next"]
        [::std::mem::offset_of!(_RFC_CERTIFICATE_DATA, next) - 40usize];
};
#[doc = " \\struct _RFC_CERTIFICATE_DATA\n \\ingroup autoserver\n\n Compact structure containing relevant information about the x509 certificate provided by the RFC client. Can be accessed by the\n authentication handler (RFC_ON_AUTHENTICATION_CHECK) and used for validating the user trying to log on."]
pub type RFC_CERTIFICATE_DATA = _RFC_CERTIFICATE_DATA;
#[doc = " \\struct _RFC_TYPE_DESC_HANDLE\n \\ingroup repository\n\n Handle to a cached metadata description of a structure or table type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_TYPE_DESC_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_TYPE_DESC_HANDLE"][::std::mem::size_of::<_RFC_TYPE_DESC_HANDLE>() - 8usize];
    ["Alignment of _RFC_TYPE_DESC_HANDLE"]
        [::std::mem::align_of::<_RFC_TYPE_DESC_HANDLE>() - 8usize];
    ["Offset of field: _RFC_TYPE_DESC_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_TYPE_DESC_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_TYPE_DESC_HANDLE\n \\ingroup repository\n\n Handle to a cached metadata description of a structure or table type."]
pub type RFC_TYPE_DESC_HANDLE = *mut _RFC_TYPE_DESC_HANDLE;
#[doc = " \\struct _RFC_FUNCTION_DESC_HANDLE\n \\ingroup repository\n\n Handle to a cached metadata description of a function module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_FUNCTION_DESC_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_FUNCTION_DESC_HANDLE"]
        [::std::mem::size_of::<_RFC_FUNCTION_DESC_HANDLE>() - 8usize];
    ["Alignment of _RFC_FUNCTION_DESC_HANDLE"]
        [::std::mem::align_of::<_RFC_FUNCTION_DESC_HANDLE>() - 8usize];
    ["Offset of field: _RFC_FUNCTION_DESC_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_FUNCTION_DESC_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_FUNCTION_DESC_HANDLE\n \\ingroup repository\n\n Handle to a cached metadata description of a function module."]
pub type RFC_FUNCTION_DESC_HANDLE = *mut _RFC_FUNCTION_DESC_HANDLE;
#[doc = " \\struct _RFC_CLASS_DESC_HANDLE\n \\ingroup repository\n\n Handle to a cached metadata description of a class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_CLASS_DESC_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_CLASS_DESC_HANDLE"][::std::mem::size_of::<_RFC_CLASS_DESC_HANDLE>() - 8usize];
    ["Alignment of _RFC_CLASS_DESC_HANDLE"]
        [::std::mem::align_of::<_RFC_CLASS_DESC_HANDLE>() - 8usize];
    ["Offset of field: _RFC_CLASS_DESC_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_CLASS_DESC_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_CLASS_DESC_HANDLE\n \\ingroup repository\n\n Handle to a cached metadata description of a class."]
pub type RFC_CLASS_DESC_HANDLE = *mut _RFC_CLASS_DESC_HANDLE;
#[doc = " \\struct RFC_DATA_CONTAINER\n \\ingroup container\n\n Handle to a general data container (structure, table or function module)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFC_DATA_CONTAINER {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RFC_DATA_CONTAINER"][::std::mem::size_of::<RFC_DATA_CONTAINER>() - 8usize];
    ["Alignment of RFC_DATA_CONTAINER"][::std::mem::align_of::<RFC_DATA_CONTAINER>() - 8usize];
    ["Offset of field: RFC_DATA_CONTAINER::handle"]
        [::std::mem::offset_of!(RFC_DATA_CONTAINER, handle) - 0usize];
};
#[doc = " \\struct RFC_DATA_CONTAINER\n \\ingroup container\n\n Handle to a general data container (structure, table or function module)."]
pub type DATA_CONTAINER_HANDLE = *mut RFC_DATA_CONTAINER;
#[doc = " \\struct RFC_STRUCTURE_HANDLE\n \\ingroup container\n\n Handle to a data container for a structure."]
pub type RFC_STRUCTURE_HANDLE = DATA_CONTAINER_HANDLE;
#[doc = " \\struct RFC_FUNCTION_HANDLE\n \\ingroup container\n\n Handle to a data container for a function module."]
pub type RFC_FUNCTION_HANDLE = DATA_CONTAINER_HANDLE;
#[doc = " \\struct RFC_TABLE_HANDLE\n \\ingroup container\n\n Handle to a data container for a table."]
pub type RFC_TABLE_HANDLE = DATA_CONTAINER_HANDLE;
#[doc = " \\struct RFC_ABAP_OBJECT_HANDLE\n \\ingroup container\n\n Handle to a data container for an ABAP object instance."]
pub type RFC_ABAP_OBJECT_HANDLE = DATA_CONTAINER_HANDLE;
#[doc = " \\struct _RFC_THROUGHPUT_HANDLE\n \\ingroup throughput\n\n Handle to a throughput object which can monitor performance relevant data of connections and servers.\n Returned by RfcCreateThroughput() or RfcGetThroughput()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_THROUGHPUT_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_THROUGHPUT_HANDLE"][::std::mem::size_of::<_RFC_THROUGHPUT_HANDLE>() - 8usize];
    ["Alignment of _RFC_THROUGHPUT_HANDLE"]
        [::std::mem::align_of::<_RFC_THROUGHPUT_HANDLE>() - 8usize];
    ["Offset of field: _RFC_THROUGHPUT_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_THROUGHPUT_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_THROUGHPUT_HANDLE\n \\ingroup throughput\n\n Handle to a throughput object which can monitor performance relevant data of connections and servers.\n Returned by RfcCreateThroughput() or RfcGetThroughput()."]
pub type RFC_THROUGHPUT_HANDLE = *mut _RFC_THROUGHPUT_HANDLE;
#[doc = " \\struct _RFC_AUTHENTICATION_HANDLE\n \\ingroup autoserver\n\n Handle to an authentication object which gives access to relevant authentication data received from the client.\n This data can be used to authenticate users in the authentication handler (RFC_ON_AUTHENTICATION_CHECK).\n Passed into the authentication handler (RFC_ON_AUTHENTICATION_CHECK) by the NW RFC library"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_AUTHENTICATION_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_AUTHENTICATION_HANDLE"]
        [::std::mem::size_of::<_RFC_AUTHENTICATION_HANDLE>() - 8usize];
    ["Alignment of _RFC_AUTHENTICATION_HANDLE"]
        [::std::mem::align_of::<_RFC_AUTHENTICATION_HANDLE>() - 8usize];
    ["Offset of field: _RFC_AUTHENTICATION_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_AUTHENTICATION_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_AUTHENTICATION_HANDLE\n \\ingroup autoserver\n\n Handle to an authentication object which gives access to relevant authentication data received from the client.\n This data can be used to authenticate users in the authentication handler (RFC_ON_AUTHENTICATION_CHECK).\n Passed into the authentication handler (RFC_ON_AUTHENTICATION_CHECK) by the NW RFC library"]
pub type RFC_AUTHENTICATION_HANDLE = *mut _RFC_AUTHENTICATION_HANDLE;
#[doc = " \\struct _RFC_CONNECTION_HANDLE\n \\ingroup connection\n\n Handle to an RFC connection (client connection or server connection).\n Returned by RfcOpenConnection() or RfcRegisterServer()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_CONNECTION_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_CONNECTION_HANDLE"][::std::mem::size_of::<_RFC_CONNECTION_HANDLE>() - 8usize];
    ["Alignment of _RFC_CONNECTION_HANDLE"]
        [::std::mem::align_of::<_RFC_CONNECTION_HANDLE>() - 8usize];
    ["Offset of field: _RFC_CONNECTION_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_CONNECTION_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_CONNECTION_HANDLE\n \\ingroup connection\n\n Handle to an RFC connection (client connection or server connection).\n Returned by RfcOpenConnection() or RfcRegisterServer()."]
pub type RFC_CONNECTION_HANDLE = *mut _RFC_CONNECTION_HANDLE;
#[doc = " \\struct _RFC_SERVER_HANDLE\n \\ingroup autoserver\n\n Handle to an automated (\"multi-count\") RFC Server, which can manage multiple parallel listening server sessions.\n Returned by RfcCreateServer()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_SERVER_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_SERVER_HANDLE"][::std::mem::size_of::<_RFC_SERVER_HANDLE>() - 8usize];
    ["Alignment of _RFC_SERVER_HANDLE"][::std::mem::align_of::<_RFC_SERVER_HANDLE>() - 8usize];
    ["Offset of field: _RFC_SERVER_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_SERVER_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_SERVER_HANDLE\n \\ingroup autoserver\n\n Handle to an automated (\"multi-count\") RFC Server, which can manage multiple parallel listening server sessions.\n Returned by RfcCreateServer()."]
pub type RFC_SERVER_HANDLE = *mut _RFC_SERVER_HANDLE;
#[doc = "< Unspecified"]
pub const _RFC_PROTOCOL_TYPE_RFC_UNKOWN: _RFC_PROTOCOL_TYPE = 0;
#[doc = "< RFC Client"]
pub const _RFC_PROTOCOL_TYPE_RFC_CLIENT: _RFC_PROTOCOL_TYPE = 1;
#[doc = "< Started RFC Server"]
pub const _RFC_PROTOCOL_TYPE_RFC_STARTED_SERVER: _RFC_PROTOCOL_TYPE = 2;
#[doc = "< Registered RFC Server"]
pub const _RFC_PROTOCOL_TYPE_RFC_REGISTERED_SERVER: _RFC_PROTOCOL_TYPE = 3;
#[doc = "< Multi-count registered RFC Server"]
pub const _RFC_PROTOCOL_TYPE_RFC_MULTI_COUNT_REGISTERED_SERVER: _RFC_PROTOCOL_TYPE = 4;
#[doc = "< TCP Client"]
pub const _RFC_PROTOCOL_TYPE_RFC_TCP_SOCKET_CLIENT: _RFC_PROTOCOL_TYPE = 5;
#[doc = "< TCP Server"]
pub const _RFC_PROTOCOL_TYPE_RFC_TCP_SOCKET_SERVER: _RFC_PROTOCOL_TYPE = 6;
#[doc = "< Websocket RFC Client"]
pub const _RFC_PROTOCOL_TYPE_RFC_WEBSOCKET_CLIENT: _RFC_PROTOCOL_TYPE = 7;
#[doc = "< Websocket RFC Server"]
pub const _RFC_PROTOCOL_TYPE_RFC_WEBSOCKET_SERVER: _RFC_PROTOCOL_TYPE = 8;
#[doc = "< Websocket RFC Client"]
pub const _RFC_PROTOCOL_TYPE_RFC_PROXY_WEBSOCKET_CLIENT: _RFC_PROTOCOL_TYPE = 9;
#[doc = " \\enum _RFC_PROTOCOL_TYPE\n \\ingroup connection\n\n Used in state information in order to indicate the different types of RFC programs, RFC Server types, etc."]
pub type _RFC_PROTOCOL_TYPE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_PROTOCOL_TYPE\n \\ingroup connection\n\n Used in state information in order to indicate the different types of RFC programs, RFC Server types, etc."]
pub use self::_RFC_PROTOCOL_TYPE as RFC_PROTOCOL_TYPE;
#[doc = "< The server object has been created, but nothing has been done with it yet."]
pub const _RFC_SERVER_STATE_RFC_SERVER_INITIAL: _RFC_SERVER_STATE = 0;
#[doc = "< The server has been started, but startup is not yet complete and the server is not yet able to receive/serve requests. Should quickly switch to RUNNING or BROKEN."]
pub const _RFC_SERVER_STATE_RFC_SERVER_STARTING: _RFC_SERVER_STATE = 1;
#[doc = "< Means at least one registration is still able to accept request from the gateway (in case of Registered Server), or that the server port is open and listening (in case of TCP Socket Server)."]
pub const _RFC_SERVER_STATE_RFC_SERVER_RUNNING: _RFC_SERVER_STATE = 2;
#[doc = "< Means that all registrations are dead, e.g. because of gateway being down (in case of Registered Server), or that for some reason server port could not be opened (in case of TCP Socket Server)."]
pub const _RFC_SERVER_STATE_RFC_SERVER_BROKEN: _RFC_SERVER_STATE = 3;
#[doc = "< The server has been stopped via RfcShutdownServer() (with a timeout > 0) and is still busy processing ongoing requests. It is however no longer accepting new requests. Should switch to STOPPED, once the ongoing requests are finished."]
pub const _RFC_SERVER_STATE_RFC_SERVER_STOPPING: _RFC_SERVER_STATE = 4;
#[doc = "< The server has been stopped via RfcShutdownServer() and is currently not processing nor accepting any requests. The object, however, is still valid and can be started again anytime with RfcLaunchServer()."]
pub const _RFC_SERVER_STATE_RFC_SERVER_STOPPED: _RFC_SERVER_STATE = 5;
#[doc = " \\enum _RFC_SERVER_STATE\n \\ingroup autoserver\n\n Used in state information in order to indicate the current state of an RFC Server."]
pub type _RFC_SERVER_STATE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_SERVER_STATE\n \\ingroup autoserver\n\n Used in state information in order to indicate the current state of an RFC Server."]
pub use self::_RFC_SERVER_STATE as RFC_SERVER_STATE;
#[doc = " \\struct _RFC_SERVER_ATTRIBUTES\n \\ingroup autoserver\n\n Information about an RFC Server returned by RfcGetServerAttributes()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_SERVER_ATTRIBUTES {
    #[doc = "< This server's name as given when creating the server."]
    pub serverName: *mut SAP_UC,
    #[doc = "< This RFC server's type. Will be one of RFC_MULTI_COUNT_REGISTERED_SERVER or RFC_TCP_SOCKET_SERVER."]
    pub type_: RFC_PROTOCOL_TYPE,
    #[doc = "< The current number of active registrations (in case of a Registered Server) or the maximum number of parallel connections the server will accept (in case of a TCP Socket Server)."]
    pub registrationCount: ::std::os::raw::c_uint,
    #[doc = "< This server's state."]
    pub state: RFC_SERVER_STATE,
    #[doc = "< The number of requests currently being processed."]
    pub currentBusyCount: ::std::os::raw::c_uint,
    #[doc = "< The maximum number of requests the server has been processing in parallel since it has been created."]
    pub peakBusyCount: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_SERVER_ATTRIBUTES"][::std::mem::size_of::<_RFC_SERVER_ATTRIBUTES>() - 32usize];
    ["Alignment of _RFC_SERVER_ATTRIBUTES"]
        [::std::mem::align_of::<_RFC_SERVER_ATTRIBUTES>() - 8usize];
    ["Offset of field: _RFC_SERVER_ATTRIBUTES::serverName"]
        [::std::mem::offset_of!(_RFC_SERVER_ATTRIBUTES, serverName) - 0usize];
    ["Offset of field: _RFC_SERVER_ATTRIBUTES::type_"]
        [::std::mem::offset_of!(_RFC_SERVER_ATTRIBUTES, type_) - 8usize];
    ["Offset of field: _RFC_SERVER_ATTRIBUTES::registrationCount"]
        [::std::mem::offset_of!(_RFC_SERVER_ATTRIBUTES, registrationCount) - 12usize];
    ["Offset of field: _RFC_SERVER_ATTRIBUTES::state"]
        [::std::mem::offset_of!(_RFC_SERVER_ATTRIBUTES, state) - 16usize];
    ["Offset of field: _RFC_SERVER_ATTRIBUTES::currentBusyCount"]
        [::std::mem::offset_of!(_RFC_SERVER_ATTRIBUTES, currentBusyCount) - 20usize];
    ["Offset of field: _RFC_SERVER_ATTRIBUTES::peakBusyCount"]
        [::std::mem::offset_of!(_RFC_SERVER_ATTRIBUTES, peakBusyCount) - 24usize];
};
#[doc = " \\struct _RFC_SERVER_ATTRIBUTES\n \\ingroup autoserver\n\n Information about an RFC Server returned by RfcGetServerAttributes()."]
pub type RFC_SERVER_ATTRIBUTES = _RFC_SERVER_ATTRIBUTES;
#[doc = "< A new stateful user session has been created on the server. This can be done either by the server itself via RfcSetServerStateful(), or by the backend via function module RFC_SET_REG_SERVER_PROPERTY"]
pub const _RFC_SESSION_EVENT_RFC_SESSION_CREATED: _RFC_SESSION_EVENT = 0;
#[doc = "< A function call came in from the backend and started processing. This event can probably be ignored by 99% of the applications."]
pub const _RFC_SESSION_EVENT_RFC_SESSION_ACTIVATED: _RFC_SESSION_EVENT = 1;
#[doc = "< A function call completed processing. This event can probably be ignored by 99% of the applications."]
pub const _RFC_SESSION_EVENT_RFC_SESSION_PASSIVATED: _RFC_SESSION_EVENT = 2;
#[doc = "< A stateful user session has been destroyed, either by the server itself via RfcSetServerStateful(), or by the backend via function module RFC_SET_REG_SERVER_PROPERTY, or because the connection was closed (e.g. the corresponding ABAP user session ended or explicitly closed the connection), or because the connection was broken by network error/system failure etc. The application should now clean up all memory/resources allocated for the given session ID."]
pub const _RFC_SESSION_EVENT_RFC_SESSION_DESTROYED: _RFC_SESSION_EVENT = 3;
#[doc = " \\enum _RFC_SESSION_EVENT\n \\ingroup autoserver\n\n Used in a server session change listener to notify the application whenever a new user session on the server gets started or ends."]
pub type _RFC_SESSION_EVENT = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_SESSION_EVENT\n \\ingroup autoserver\n\n Used in a server session change listener to notify the application whenever a new user session on the server gets started or ends."]
pub use self::_RFC_SESSION_EVENT as RFC_SESSION_EVENT;
#[doc = " \\struct _RFC_SESSION_CHANGE\n \\ingroup autoserver\n\n Notifies an RFC Server that a stateful user session has just been created or destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_SESSION_CHANGE {
    #[doc = "< Session ID of the user session in question"]
    pub sessionID: [SAP_UC; 31usize],
    #[doc = "< What has been done with that session"]
    pub event: RFC_SESSION_EVENT,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_SESSION_CHANGE"][::std::mem::size_of::<_RFC_SESSION_CHANGE>() - 68usize];
    ["Alignment of _RFC_SESSION_CHANGE"][::std::mem::align_of::<_RFC_SESSION_CHANGE>() - 4usize];
    ["Offset of field: _RFC_SESSION_CHANGE::sessionID"]
        [::std::mem::offset_of!(_RFC_SESSION_CHANGE, sessionID) - 0usize];
    ["Offset of field: _RFC_SESSION_CHANGE::event"]
        [::std::mem::offset_of!(_RFC_SESSION_CHANGE, event) - 64usize];
};
#[doc = " \\struct _RFC_SESSION_CHANGE\n \\ingroup autoserver\n\n Notifies an RFC Server that a stateful user session has just been created or destroyed."]
pub type RFC_SESSION_CHANGE = _RFC_SESSION_CHANGE;
pub type RFC_SERVER_SESSION_CHANGE_LISTENER = ::std::option::Option<
    unsafe extern "C" fn(
        serverHandle: RFC_SERVER_HANDLE,
        sessionChange: *mut RFC_SESSION_CHANGE,
    ) -> RFC_RC,
>;
pub type RFC_SERVER_ERROR_LISTENER = ::std::option::Option<
    unsafe extern "C" fn(
        serverHandle: RFC_SERVER_HANDLE,
        clientInfo: *mut RFC_ATTRIBUTES,
        errorInfo: *mut RFC_ERROR_INFO,
    ),
>;
#[doc = " \\struct _RFC_STATE_CHANGE\n \\ingroup autoserver\n\n Notifies the application that an RFC Server changed its state (e.g. got started, got shutdown, lost its connection to the backend etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_STATE_CHANGE {
    #[doc = "< Previous state of the given server"]
    pub oldState: RFC_SERVER_STATE,
    #[doc = "< New state of the given server"]
    pub newState: RFC_SERVER_STATE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_STATE_CHANGE"][::std::mem::size_of::<_RFC_STATE_CHANGE>() - 8usize];
    ["Alignment of _RFC_STATE_CHANGE"][::std::mem::align_of::<_RFC_STATE_CHANGE>() - 4usize];
    ["Offset of field: _RFC_STATE_CHANGE::oldState"]
        [::std::mem::offset_of!(_RFC_STATE_CHANGE, oldState) - 0usize];
    ["Offset of field: _RFC_STATE_CHANGE::newState"]
        [::std::mem::offset_of!(_RFC_STATE_CHANGE, newState) - 4usize];
};
#[doc = " \\struct _RFC_STATE_CHANGE\n \\ingroup autoserver\n\n Notifies the application that an RFC Server changed its state (e.g. got started, got shutdown, lost its connection to the backend etc.)."]
pub type RFC_STATE_CHANGE = _RFC_STATE_CHANGE;
pub type RFC_SERVER_STATE_CHANGE_LISTENER = ::std::option::Option<
    unsafe extern "C" fn(serverHandle: RFC_SERVER_HANDLE, stateChange: *mut RFC_STATE_CHANGE),
>;
#[doc = " \\struct _RFC_SERVER_MONITOR_DATA\n \\ingroup autoserver\n\n Allows to retrieve monitoring information about all busy or idle connections of an automated RFC Server via RfcGetServerConnectionMonitorData()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_SERVER_MONITOR_DATA {
    #[doc = "< Pointer to an RFC_ATTRIBUTES structure containing information about this particular client connection."]
    pub clientInfo: *mut RFC_ATTRIBUTES,
    #[doc = "< 1, if this connection is currently processing a call, 0, if it is idle."]
    pub isActive: ::std::os::raw::c_int,
    #[doc = "< If this connection is currently processing a call, this flag indicates, whether it is a stateful or stateless call: 0 = stateless, 1 = stateful."]
    pub isStateful: ::std::os::raw::c_int,
    #[doc = "< Name of the ABAP function module currently being processed over this connection (if the connection is currently active), or empty (if the connection is idle)."]
    pub functionModuleName: [SAP_UC; 128usize],
    #[doc = "< Point of time of the last activity on this connection (if the connection is currently idle), or not used (if the connection is busy)."]
    pub lastActivity: time_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_SERVER_MONITOR_DATA"]
        [::std::mem::size_of::<_RFC_SERVER_MONITOR_DATA>() - 280usize];
    ["Alignment of _RFC_SERVER_MONITOR_DATA"]
        [::std::mem::align_of::<_RFC_SERVER_MONITOR_DATA>() - 8usize];
    ["Offset of field: _RFC_SERVER_MONITOR_DATA::clientInfo"]
        [::std::mem::offset_of!(_RFC_SERVER_MONITOR_DATA, clientInfo) - 0usize];
    ["Offset of field: _RFC_SERVER_MONITOR_DATA::isActive"]
        [::std::mem::offset_of!(_RFC_SERVER_MONITOR_DATA, isActive) - 8usize];
    ["Offset of field: _RFC_SERVER_MONITOR_DATA::isStateful"]
        [::std::mem::offset_of!(_RFC_SERVER_MONITOR_DATA, isStateful) - 12usize];
    ["Offset of field: _RFC_SERVER_MONITOR_DATA::functionModuleName"]
        [::std::mem::offset_of!(_RFC_SERVER_MONITOR_DATA, functionModuleName) - 16usize];
    ["Offset of field: _RFC_SERVER_MONITOR_DATA::lastActivity"]
        [::std::mem::offset_of!(_RFC_SERVER_MONITOR_DATA, lastActivity) - 272usize];
};
#[doc = " \\struct _RFC_SERVER_MONITOR_DATA\n \\ingroup autoserver\n\n Allows to retrieve monitoring information about all busy or idle connections of an automated RFC Server via RfcGetServerConnectionMonitorData()."]
pub type RFC_SERVER_MONITOR_DATA = _RFC_SERVER_MONITOR_DATA;
#[doc = " \\struct _RFC_TRANSACTION_HANDLE\n \\ingroup transaction\n\n Handle to a data container for a tRFC/qRFC LUW.\n Can be filled with several RFC_FUNCTION_HANDLEs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_TRANSACTION_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_TRANSACTION_HANDLE"][::std::mem::size_of::<_RFC_TRANSACTION_HANDLE>() - 8usize];
    ["Alignment of _RFC_TRANSACTION_HANDLE"]
        [::std::mem::align_of::<_RFC_TRANSACTION_HANDLE>() - 8usize];
    ["Offset of field: _RFC_TRANSACTION_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_TRANSACTION_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_TRANSACTION_HANDLE\n \\ingroup transaction\n\n Handle to a data container for a tRFC/qRFC LUW.\n Can be filled with several RFC_FUNCTION_HANDLEs."]
pub type RFC_TRANSACTION_HANDLE = *mut _RFC_TRANSACTION_HANDLE;
#[doc = " \\struct _RFC_UNIT_HANDLE\n \\ingroup bgrfc\n\n Handle to a data container for a bgRFC LUW.\n Can be filled with several RFC_FUNCTION_HANDLEs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_UNIT_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_UNIT_HANDLE"][::std::mem::size_of::<_RFC_UNIT_HANDLE>() - 8usize];
    ["Alignment of _RFC_UNIT_HANDLE"][::std::mem::align_of::<_RFC_UNIT_HANDLE>() - 8usize];
    ["Offset of field: _RFC_UNIT_HANDLE::handle"]
        [::std::mem::offset_of!(_RFC_UNIT_HANDLE, handle) - 0usize];
};
#[doc = " \\struct _RFC_UNIT_HANDLE\n \\ingroup bgrfc\n\n Handle to a data container for a bgRFC LUW.\n Can be filled with several RFC_FUNCTION_HANDLEs."]
pub type RFC_UNIT_HANDLE = *mut _RFC_UNIT_HANDLE;
#[doc = " \\struct _RFC_CONNECTION_PARAMETER\n \\ingroup connection\n\n Structure used for connecting to a backend system via RfcOpenConnection() or\n RfcRegisterServer(). For a list of supported parameters see these two functions or the file sapnwrfc.ini, which gives a complete list of all possible connection parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_CONNECTION_PARAMETER {
    #[doc = "< The name of the connection parameter, like ashost, user, client."]
    pub name: *const SAP_UC,
    #[doc = "< The value of the given parameter."]
    pub value: *const SAP_UC,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_CONNECTION_PARAMETER"]
        [::std::mem::size_of::<_RFC_CONNECTION_PARAMETER>() - 16usize];
    ["Alignment of _RFC_CONNECTION_PARAMETER"]
        [::std::mem::align_of::<_RFC_CONNECTION_PARAMETER>() - 8usize];
    ["Offset of field: _RFC_CONNECTION_PARAMETER::name"]
        [::std::mem::offset_of!(_RFC_CONNECTION_PARAMETER, name) - 0usize];
    ["Offset of field: _RFC_CONNECTION_PARAMETER::value"]
        [::std::mem::offset_of!(_RFC_CONNECTION_PARAMETER, value) - 8usize];
};
#[doc = " \\struct _RFC_CONNECTION_PARAMETER\n \\ingroup connection\n\n Structure used for connecting to a backend system via RfcOpenConnection() or\n RfcRegisterServer(). For a list of supported parameters see these two functions or the file sapnwrfc.ini, which gives a complete list of all possible connection parameters."]
pub type RFC_CONNECTION_PARAMETER = _RFC_CONNECTION_PARAMETER;
#[doc = " \\struct _RFC_CONNECTION_PARAMETER\n \\ingroup connection\n\n Structure used for connecting to a backend system via RfcOpenConnection() or\n RfcRegisterServer(). For a list of supported parameters see these two functions or the file sapnwrfc.ini, which gives a complete list of all possible connection parameters."]
pub type P_RFC_CONNECTION_PARAMETER = *mut _RFC_CONNECTION_PARAMETER;
#[doc = " \\struct _RFC_FIELD_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetFieldDescByIndex() or RfcGetFieldDescByName())\n or defining (RfcAddTypeField()) the properties of a field in a structure/table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_FIELD_DESC {
    #[doc = "< Field name, null-terminated string"]
    pub name: RFC_ABAP_NAME,
    #[doc = "< Field data type"]
    pub type_: RFCTYPE,
    #[doc = "< Field length in bytes in a 1-byte-per-SAP_CHAR system"]
    pub nucLength: ::std::os::raw::c_uint,
    #[doc = "< Field offset in bytes in a 1-byte-per-SAP_CHAR system"]
    pub nucOffset: ::std::os::raw::c_uint,
    #[doc = "< Field length in bytes in a 2-byte-per-SAP_CHAR system"]
    pub ucLength: ::std::os::raw::c_uint,
    #[doc = "< Field offset in bytes in a 2-byte-per-SAP_CHAR system"]
    pub ucOffset: ::std::os::raw::c_uint,
    #[doc = "< If the field is of type \"packed number\" (BCD), this member gives the number of decimals."]
    pub decimals: ::std::os::raw::c_uint,
    #[doc = "< Pointer to an RFC_STRUCTURE_DESC structure for the nested sub-type if the type field is RFCTYPE_STRUCTURE or RFCTYPE_TABLE */"]
    pub typeDescHandle: RFC_TYPE_DESC_HANDLE,
    #[doc = "< Not used by the NW RFC library. This parameter can be used by applications that want to store additional information in the repository (like F4 help values, e.g.)."]
    pub extendedDescription: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_FIELD_DESC"][::std::mem::size_of::<_RFC_FIELD_DESC>() - 104usize];
    ["Alignment of _RFC_FIELD_DESC"][::std::mem::align_of::<_RFC_FIELD_DESC>() - 8usize];
    ["Offset of field: _RFC_FIELD_DESC::name"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, name) - 0usize];
    ["Offset of field: _RFC_FIELD_DESC::type_"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, type_) - 64usize];
    ["Offset of field: _RFC_FIELD_DESC::nucLength"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, nucLength) - 68usize];
    ["Offset of field: _RFC_FIELD_DESC::nucOffset"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, nucOffset) - 72usize];
    ["Offset of field: _RFC_FIELD_DESC::ucLength"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, ucLength) - 76usize];
    ["Offset of field: _RFC_FIELD_DESC::ucOffset"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, ucOffset) - 80usize];
    ["Offset of field: _RFC_FIELD_DESC::decimals"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, decimals) - 84usize];
    ["Offset of field: _RFC_FIELD_DESC::typeDescHandle"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, typeDescHandle) - 88usize];
    ["Offset of field: _RFC_FIELD_DESC::extendedDescription"]
        [::std::mem::offset_of!(_RFC_FIELD_DESC, extendedDescription) - 96usize];
};
#[doc = " \\struct _RFC_FIELD_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetFieldDescByIndex() or RfcGetFieldDescByName())\n or defining (RfcAddTypeField()) the properties of a field in a structure/table."]
pub type RFC_FIELD_DESC = _RFC_FIELD_DESC;
#[doc = " \\struct _RFC_FIELD_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetFieldDescByIndex() or RfcGetFieldDescByName())\n or defining (RfcAddTypeField()) the properties of a field in a structure/table."]
pub type P_RFC_FIELD_DESC = *mut _RFC_FIELD_DESC;
#[doc = "< Import parameter. This corresponds to ABAP IMPORTING parameter."]
pub const _RFC_DIRECTION_RFC_IMPORT: _RFC_DIRECTION = 1;
#[doc = "< Export parameter. This corresponds to ABAP EXPORTING parameter."]
pub const _RFC_DIRECTION_RFC_EXPORT: _RFC_DIRECTION = 2;
#[doc = "< Import and export parameter. This corresponds to ABAP CHANGING parameter."]
pub const _RFC_DIRECTION_RFC_CHANGING: _RFC_DIRECTION = 3;
#[doc = "< Table parameter. This corresponds to ABAP TABLES parameter."]
pub const _RFC_DIRECTION_RFC_TABLES: _RFC_DIRECTION = 7;
#[doc = " \\enum _RFC_DIRECTION\n \\ingroup repository\n\n Used in #RFC_PARAMETER_DESC::direction for specifying the direction of a function module parameter."]
pub type _RFC_DIRECTION = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_DIRECTION\n \\ingroup repository\n\n Used in #RFC_PARAMETER_DESC::direction for specifying the direction of a function module parameter."]
pub use self::_RFC_DIRECTION as RFC_DIRECTION;
#[doc = " \\struct _RFC_PARAMETER_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())\n or defining (RfcAddParameter()) the properties of a parameter in a function module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_PARAMETER_DESC {
    #[doc = "< Parameter name, null-terminated string"]
    pub name: RFC_ABAP_NAME,
    #[doc = "< Parameter data type"]
    pub type_: RFCTYPE,
    #[doc = "< Specifies whether the parameter is an input, output or bi-directional parameter"]
    pub direction: RFC_DIRECTION,
    #[doc = "< Parameter length in bytes in a 1-byte-per-SAP_CHAR system"]
    pub nucLength: ::std::os::raw::c_uint,
    #[doc = "< Parameter length in bytes in a 2-byte-per-SAP_CHAR system"]
    pub ucLength: ::std::os::raw::c_uint,
    #[doc = "< Gives the number of decimals in case of a packed number (BCD)"]
    pub decimals: ::std::os::raw::c_uint,
    #[doc = "< Handle to the structure definition in case this parameter is a structure or table"]
    pub typeDescHandle: RFC_TYPE_DESC_HANDLE,
    #[doc = "< Default value as defined in SE37"]
    pub defaultValue: RFC_PARAMETER_DEFVALUE,
    #[doc = "< Description text of the parameter as defined in SE37. Null-terminated string."]
    pub parameterText: RFC_PARAMETER_TEXT,
    #[doc = "< Specifies whether this parameter is defined as optional in SE37. 1 is optional, 0 non-optional"]
    pub optional: RFC_BYTE,
    #[doc = "< This field can be used by the application programmer (i.e. you) to store arbitrary extra information."]
    pub extendedDescription: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_PARAMETER_DESC"][::std::mem::size_of::<_RFC_PARAMETER_DESC>() - 328usize];
    ["Alignment of _RFC_PARAMETER_DESC"][::std::mem::align_of::<_RFC_PARAMETER_DESC>() - 8usize];
    ["Offset of field: _RFC_PARAMETER_DESC::name"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, name) - 0usize];
    ["Offset of field: _RFC_PARAMETER_DESC::type_"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, type_) - 64usize];
    ["Offset of field: _RFC_PARAMETER_DESC::direction"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, direction) - 68usize];
    ["Offset of field: _RFC_PARAMETER_DESC::nucLength"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, nucLength) - 72usize];
    ["Offset of field: _RFC_PARAMETER_DESC::ucLength"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, ucLength) - 76usize];
    ["Offset of field: _RFC_PARAMETER_DESC::decimals"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, decimals) - 80usize];
    ["Offset of field: _RFC_PARAMETER_DESC::typeDescHandle"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, typeDescHandle) - 88usize];
    ["Offset of field: _RFC_PARAMETER_DESC::defaultValue"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, defaultValue) - 96usize];
    ["Offset of field: _RFC_PARAMETER_DESC::parameterText"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, parameterText) - 158usize];
    ["Offset of field: _RFC_PARAMETER_DESC::optional"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, optional) - 318usize];
    ["Offset of field: _RFC_PARAMETER_DESC::extendedDescription"]
        [::std::mem::offset_of!(_RFC_PARAMETER_DESC, extendedDescription) - 320usize];
};
#[doc = " \\struct _RFC_PARAMETER_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())\n or defining (RfcAddParameter()) the properties of a parameter in a function module."]
pub type RFC_PARAMETER_DESC = _RFC_PARAMETER_DESC;
#[doc = " \\struct _RFC_PARAMETER_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())\n or defining (RfcAddParameter()) the properties of a parameter in a function module."]
pub type P_RFC_PARAMETER_DESC = *mut _RFC_PARAMETER_DESC;
#[doc = " \\struct _RFC_EXCEPTION_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetExceptionDescByIndex() or RfcGetExceptionDescByName())\n or defining (RfcAddException()) the properties of an exception key in a function module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_EXCEPTION_DESC {
    #[doc = "< Exception key"]
    pub key: [SAP_UC; 128usize],
    #[doc = "< Error message (exception text as defined in SE37)"]
    pub message: [SAP_UC; 512usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_EXCEPTION_DESC"][::std::mem::size_of::<_RFC_EXCEPTION_DESC>() - 1280usize];
    ["Alignment of _RFC_EXCEPTION_DESC"][::std::mem::align_of::<_RFC_EXCEPTION_DESC>() - 2usize];
    ["Offset of field: _RFC_EXCEPTION_DESC::key"]
        [::std::mem::offset_of!(_RFC_EXCEPTION_DESC, key) - 0usize];
    ["Offset of field: _RFC_EXCEPTION_DESC::message"]
        [::std::mem::offset_of!(_RFC_EXCEPTION_DESC, message) - 256usize];
};
#[doc = " \\struct _RFC_EXCEPTION_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetExceptionDescByIndex() or RfcGetExceptionDescByName())\n or defining (RfcAddException()) the properties of an exception key in a function module."]
pub type RFC_EXCEPTION_DESC = _RFC_EXCEPTION_DESC;
#[doc = " \\struct _RFC_EXCEPTION_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetExceptionDescByIndex() or RfcGetExceptionDescByName())\n or defining (RfcAddException()) the properties of an exception key in a function module."]
pub type P__RFC_EXCEPTION_DESC = *mut _RFC_EXCEPTION_DESC;
#[doc = "< Instance attribute (object member)"]
pub const _RFC_CLASS_ATTRIBUTE_TYPE_RFC_CLASS_ATTRIBUTE_INSTANCE: _RFC_CLASS_ATTRIBUTE_TYPE = 0;
#[doc = "< Class attribute (global)"]
pub const _RFC_CLASS_ATTRIBUTE_TYPE_RFC_CLASS_ATTRIBUTE_CLASS: _RFC_CLASS_ATTRIBUTE_TYPE = 1;
#[doc = "< A constant"]
pub const _RFC_CLASS_ATTRIBUTE_TYPE_RFC_CLASS_ATTRIBUTE_CONSTANT: _RFC_CLASS_ATTRIBUTE_TYPE = 2;
#[doc = " \\enum _RFC_CLASS_ATTRIBUTE_TYPE\n \\ingroup repository\n\n Determines the type of an ABAP Object attribute."]
pub type _RFC_CLASS_ATTRIBUTE_TYPE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_CLASS_ATTRIBUTE_TYPE\n \\ingroup repository\n\n Determines the type of an ABAP Object attribute."]
pub use self::_RFC_CLASS_ATTRIBUTE_TYPE as RFC_CLASS_ATTRIBUTE_TYPE;
pub type RFC_CLASS_ATTRIBUTE_DEFVALUE = [RFC_CHAR; 31usize];
pub type RFC_CLASS_NAME = [RFC_CHAR; 31usize];
pub type RFC_CLASS_ATTRIBUTE_DESCRIPTION = [RFC_CHAR; 512usize];
#[doc = " \\struct _RFC_CLASS_ATTRIBUTE_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())\n or defining (RfcAddParameter()) the properties of a parameter in a function module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_CLASS_ATTRIBUTE_DESC {
    #[doc = "< Attribute name, null-terminated string"]
    pub name: RFC_ABAP_NAME,
    #[doc = "< Attribute data type"]
    pub type_: RFCTYPE,
    #[doc = "< Attribute length in bytes in a 1-byte-per-SAP_CHAR system"]
    pub nucLength: ::std::os::raw::c_uint,
    #[doc = "< Attribute length in bytes in a 2-byte-per-SAP_CHAR system"]
    pub ucLength: ::std::os::raw::c_uint,
    #[doc = "< Gives the number of decimals in case this attribute is a packed number (BCD)"]
    pub decimals: ::std::os::raw::c_uint,
    #[doc = "< Handle to the structure definition in case this attribute is a structure or table"]
    pub typeDescHandle: RFC_TYPE_DESC_HANDLE,
    #[doc = "< Default value as defined in SE37"]
    pub defaultValue: RFC_CLASS_ATTRIBUTE_DEFVALUE,
    #[doc = "< Declaring class"]
    pub declaringClass: RFC_CLASS_NAME,
    #[doc = "< Attribute description, null terminated, may be null"]
    pub description: RFC_CLASS_ATTRIBUTE_DESCRIPTION,
    #[doc = "< This attribute is read only if isReadOnly != 0"]
    pub isReadOnly: ::std::os::raw::c_uint,
    #[doc = "< The attribute type tells you, whether this attribute is an instance attribute, a class attribute or a constant."]
    pub attributeType: RFC_CLASS_ATTRIBUTE_TYPE,
    #[doc = "< This field can be used by the application programmer (i.e. you) to store arbitrary extra information."]
    pub extendedDescription: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_CLASS_ATTRIBUTE_DESC"]
        [::std::mem::size_of::<_RFC_CLASS_ATTRIBUTE_DESC>() - 1256usize];
    ["Alignment of _RFC_CLASS_ATTRIBUTE_DESC"]
        [::std::mem::align_of::<_RFC_CLASS_ATTRIBUTE_DESC>() - 8usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::name"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, name) - 0usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::type_"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, type_) - 64usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::nucLength"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, nucLength) - 68usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::ucLength"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, ucLength) - 72usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::decimals"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, decimals) - 76usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::typeDescHandle"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, typeDescHandle) - 80usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::defaultValue"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, defaultValue) - 88usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::declaringClass"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, declaringClass) - 150usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::description"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, description) - 212usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::isReadOnly"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, isReadOnly) - 1236usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::attributeType"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, attributeType) - 1240usize];
    ["Offset of field: _RFC_CLASS_ATTRIBUTE_DESC::extendedDescription"]
        [::std::mem::offset_of!(_RFC_CLASS_ATTRIBUTE_DESC, extendedDescription) - 1248usize];
};
#[doc = " \\struct _RFC_CLASS_ATTRIBUTE_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())\n or defining (RfcAddParameter()) the properties of a parameter in a function module."]
pub type RFC_CLASS_ATTRIBUTE_DESC = _RFC_CLASS_ATTRIBUTE_DESC;
#[doc = " \\struct _RFC_CLASS_ATTRIBUTE_DESC\n \\ingroup repository\n\n Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())\n or defining (RfcAddParameter()) the properties of a parameter in a function module."]
pub type P_RFC_CLASS_ATTRIBUTE_DESC = *mut _RFC_CLASS_ATTRIBUTE_DESC;
pub type RFC_SERVER_FUNCTION = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC,
>;
pub type RFC_ON_CHECK_TRANSACTION = ::std::option::Option<
    unsafe extern "C" fn(rfcHandle: RFC_CONNECTION_HANDLE, tid: *const SAP_UC) -> RFC_RC,
>;
pub type RFC_ON_COMMIT_TRANSACTION = ::std::option::Option<
    unsafe extern "C" fn(rfcHandle: RFC_CONNECTION_HANDLE, tid: *const SAP_UC) -> RFC_RC,
>;
pub type RFC_ON_ROLLBACK_TRANSACTION = ::std::option::Option<
    unsafe extern "C" fn(rfcHandle: RFC_CONNECTION_HANDLE, tid: *const SAP_UC) -> RFC_RC,
>;
pub type RFC_ON_CONFIRM_TRANSACTION = ::std::option::Option<
    unsafe extern "C" fn(rfcHandle: RFC_CONNECTION_HANDLE, tid: *const SAP_UC) -> RFC_RC,
>;
pub type RFC_FUNC_DESC_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        functionName: *const SAP_UC,
        rfcAttributes: RFC_ATTRIBUTES,
        funcDescHandle: *mut RFC_FUNCTION_DESC_HANDLE,
    ) -> RFC_RC,
>;
pub type RFC_PM_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        functionName: *const SAP_UC,
        eppBuffer: *mut SAP_RAW,
        eppBufferSize: usize,
        eppLength: *mut usize,
    ) -> RFC_RC,
>;
pub type RFC_ON_CHECK_UNIT = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *const RFC_UNIT_IDENTIFIER,
    ) -> RFC_RC,
>;
pub type RFC_ON_COMMIT_UNIT = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *const RFC_UNIT_IDENTIFIER,
    ) -> RFC_RC,
>;
pub type RFC_ON_ROLLBACK_UNIT = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *const RFC_UNIT_IDENTIFIER,
    ) -> RFC_RC,
>;
pub type RFC_ON_CONFIRM_UNIT = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *const RFC_UNIT_IDENTIFIER,
    ) -> RFC_RC,
>;
pub type RFC_ON_GET_UNIT_STATE = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *const RFC_UNIT_IDENTIFIER,
        unitState: *mut RFC_UNIT_STATE,
    ) -> RFC_RC,
>;
pub type RFC_ON_PASSWORD_CHANGE = ::std::option::Option<
    unsafe extern "C" fn(
        sysId: *const SAP_UC,
        user: *const SAP_UC,
        client: *const SAP_UC,
        password: *mut SAP_UC,
        passwordLength: ::std::os::raw::c_uint,
        newPassword: *mut SAP_UC,
        newPasswordLength: ::std::os::raw::c_uint,
        cause: *mut RFC_ERROR_INFO,
    ) -> RFC_RC,
>;
pub type RFC_ON_AUTHORIZATION_CHECK = ::std::option::Option<
    unsafe extern "C" fn(
        rfcHandle: RFC_CONNECTION_HANDLE,
        secAttributes: *mut RFC_SECURITY_ATTRIBUTES,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC,
>;
pub type RFC_ON_AUTHENTICATION_CHECK = ::std::option::Option<
    unsafe extern "C" fn(
        rfcAttributes: RFC_ATTRIBUTES,
        authenticationHandle: RFC_AUTHENTICATION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC,
>;
unsafe extern "C" {
    #[doc = " \\brief  Initialization of internal variables\n \\ingroup general\n\n Obsolete.\n %RfcInit() no longer needs to be called explicitly. The RFC library does\n this automatically on DLL load.\n \\return RFC_RC"]
    pub fn RfcInit() -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Freeing of internal variables\n \\ingroup general\n\n Obsolete.\n The RFC library does this automatically on DLL unload.\n \\return RFC_RC"]
    pub fn RfcCleanup() -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Get information about currently loaded sapnwrfc library.\n \\ingroup general\n\n Fills the provided unsigneds with the SAP release values, e.g. *majorVersion = 7500,\n *minorVersion = 0, *patchLevel = 44.\n \\out *majorVersion\n \\out *minorVersion\n \\out *patchLevel\n \\return Version information in string format.\n \\warning Don't free the returned SAP_UC pointer, it's static memory..."]
    pub fn RfcGetVersion(
        majorVersion: *mut ::std::os::raw::c_uint,
        minorVersion: *mut ::std::os::raw::c_uint,
        patchLevel: *mut ::std::os::raw::c_uint,
    ) -> *const SAP_UC;
}
unsafe extern "C" {
    #[doc = " \\brief This function is intended to be used by SAP Make-factory only. Please DO NOT use it!\n \\ingroup general"]
    pub fn RfcGetVersionInternal() -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the directory in which to search for the sapnwrfc.ini file.\n \\ingroup general\n\n By default the sapnwrfc library searches for the sapnwrfc.ini in the current\n working directory of the process. If you want to keep it in a different directory,\n use this function to tell the sapnwrfc library about the new path.\n \\note After you have changed the directory, the NW RFC lib automatically loads\n the contents of the new sapnwrfc.ini file from that directory.\n\n \\in *pathName The full (absolute) path of the directory, in which the sapnwrfc\n library should look for the sapnwrfc.ini file. A path relative to the current\n working directory of the process also works.\n \\out *errorInfo Detail information in case anything goes wrong.\n \\return RFC_RC"]
    pub fn RfcSetIniPath(pathName: *const SAP_UC, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reloads the contents of the sapnwrfc.ini file into memory.\n \\ingroup general\n\n Searches the directory given by RfcSetIniPath() (or the current working directory)\n for the file sapnwrfc.ini and loads its contents into memory. Reloading the sapnwrfc.ini\n file is only necessary after the file has been manually edited\n If you want to use a sapnwrfc.ini file in a different location, consider using %RfcSetIniPath().\n\n Note: If a file with the name sapnwrfc.ini does not exist in the given directory, this is not\n considered an error! Default settings are used in this case.\n\n \\out *errorInfo Detail information in case anything goes wrong.\n \\return RFC_RC"]
    pub fn RfcReloadIniFile(errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the current trace level of the specified RFC connection or destination to the new value.\n \\ingroup general\n\n \\note If both of connection and destination are NULL, this function sets the \"global\"\n trace level. See below.\n \\in connection A handle to a currently open RFC connection (client or server connection).\n The new trace level will be effective immediately.\n \\in *destination Null-terminated string specifying a client or server destination as defined\n via a DEST=... entry in sapnwrfc.ini. The new trace level will be used for new connections\n to that destination opened after the %RfcSetTraceLevel() call. Already existing connections to\n that destination will not be effected.\n \\in traceLevel The new trace level. Must be between 0 and 4. The meaning of those four values\n is as follows:\n - 0: Off. Only severe errors are logged to the dev_rfc.trc file.\n - 1: Brief. All API calls (except for the setter and getter functions) and important attributes\n      like codepages, RFC headers, logon parameters are traced. Trace is written to a file named\n      rfc&lt;pid&gt;.trc or rfc&lt;pid&gt;_&lt;tid&gt;.trc, depending on whether tracing is done\n      on a \"per-process\" basis or a \"per-thread\" basis. &lt;pid&gt; is the current process ID,\n      &lt;tid&gt; the current thread ID.\n - 2: Verbose. In addition to 1, the values of the \"scalar\" RFC parameters as well as the contents\n      of the network containers are traced. Scalar parameters are primitive types (CHAR, INT, FLOAT, etc)\n      and flat structures.\n - 3: Detailed. In addition to 2 the contents of nested structures and tables and hexdumps\n - 4: Full. In addition to 3 all API calls of setter and getter functions and table operations\n      are traced.\n \\out *errorInfo Detail information in case the specified connection or destination does not exist.\n \\return RFC_OK, RFC_INVALID_HANDLE or RFC_INVALID_PARAMETER\n\n \\note In general RFC trace can be activated/deactivated in 6 different ways:\n - By setting the parameter RFC_TRACE=[0|1|2|3|4] in the DEFAULT section of the sapnwrfc.ini file.\n   This value applies to all destinations, for which no explicit trace level has been set.\n   (\"Global\" trace level.)\n - By setting the parameter TRACE=[0|1|2|3|4] in a specific destination section of sapnwrfc.ini.\n   it applies to that destination only and overrules the \"global\" trace level from the DEFAULT section.\n - By setting the environment variable RFC_TRACE=[0|1|2|3|4]. This overrules the setting from the\n   DEFAULT section of sapnwrfc.ini.\n - Via %RfcSetTraceLevel(). If connection and destination are NULL, this function sets the global\n   trace level and overrules the value from the DEFAULT section of sapnwrfc.ini as well as the environment\n   variable RFC_TRACE. If connection is non-NULL, it sets the trace level for the current connection only,\n   and if destination is non-NULL, it sets the trace level for that destination, overruling the value from\n   this destination's section in the sapnwrfc.ini file.\n - By passing a {name=TRACE, value=[0|1|2|3|4]} pair in the RFC_CONNECTION_PARAMETER array used in\n   RfcOpenConnection(), RfcRegisterServer() or RfcStartServer(). If that RFC_CONNECTION_PARAMETER array\n   also contains a {name=DEST, value=...} pair, the trace parameter from the array overrules the value\n   from this destination's sapnwrfc.ini section.\n - In case the program is a server program: by activating the trace flag for the corresponding destination\n   in SM59. The trace setting on backend side is then \"inherited\" by the external side.\n\n \\note For more information on trace settings see the sample sapnwrfc.ini file contained in the demo folder."]
    pub fn RfcSetTraceLevel(
        connection: RFC_CONNECTION_HANDLE,
        destination: *mut SAP_UC,
        traceLevel: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Changes the character encoding to be used in trace files.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_ENCODING.\n See the documentation of that parameter in the sample ini file contained in the\n /demo directory of the NW RFC SDK.\n\n \\note This API call affects only new trace files that will be opened after the call.\n The character encoding of already existing trace files is not changed in order to\n prevent confusion and garbage data...\n\n\n \\in *traceEncoding The new encoding. Possible values are \"UTF-16\", \"UTF-8\" and\n \"DEFAULT\". On Windows UTF-16 is recommended for faster performance. \"DEFAULT\" corresponds\n to the operating system's default character encoding, which is CP1252 or ISO-8859-1 on\n most Windows systems and UTF-8 on most Linux systems.\n \\out *errorInfo Detail information in case of an invalid traceEncoding input.\n \\return RFC_RC"]
    pub fn RfcSetTraceEncoding(
        traceEncoding: *mut SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Changes the directory where the NW RFC lib should write trace files.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_DIR.\n See the documentation of that parameter in the sample ini file contained in the\n /demo directory of the NW RFC SDK.\n\n \\note This API call affects only new trace files that will be opened after the call.\n The directory of already existing trace files is not changed in order to\n prevent confusion and garbage data...\n\n\n \\in *traceDir The new directory. Can be an absolute or relative path name.\n The directory needs to exist prior to calling this API. The NW RFC lib will not\n attempt to create non-existing directories.\n \\out *errorInfo Detail information in case of an invalid traceEncoding input.\n \\return RFC_RC"]
    pub fn RfcSetTraceDir(traceDir: *mut SAP_UC, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Changes the way the NW RFC lib writes trace files.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_TYPE.\n See the documentation of that parameter in the sample ini file contained in the\n /demo directory of the NW RFC SDK.\n\n \\note This API call closes currently open trace files and then changes to\n \"one file per process\" or one \"file per thread\".\n If the NW RFC lib is already using the given trace type, it does nothing.\n\n\n \\in *traceType Must be either \"PROCESS\" or \"THREAD\".\n \\out *errorInfo Detail information in case of an invalid traceEncoding input.\n \\return RFC_RC"]
    pub fn RfcSetTraceType(traceType: *mut SAP_UC, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the global CPIC trace level used by the underlying CPIC libabry to write CPIC tracing information\n to the CPIC trace file cpic_<pid>.trc, where pid is the process ID of the current process. The CPIC trace file\n is located in the same directory where the RFC trace files are located.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter CPIC_TRACE_LEVEL.\n See the documentation of that parameter in the sample ini file contained in the\n /demo directory of the NW RFC SDK.\n\n \\in traceLevel Must be a value between 0 to 3, where 0 turns tracing off.\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetCpicTraceLevel(
        traceLevel: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief Activates the CPIC keepalive\n\n \\in timeout Must be a value between 10 and 3600, where 0 turns the cpic keepalive off.\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetCpicKeepalive(
        timeout: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the global Websocket trace level used by the underlying NI libabry to write tracing information\n to the trace file ws_rfc_<pid>.trc, where pid is the process ID of the current process. The NI trace file\n is located in the same directory where the RFC trace files are located.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_SOCKET_TRACE.\n See the documentation of that parameter in the sample ini file contained in the\n /demo directory of the NW RFC SDK.\n Nevertheless this API cannot set a trace level below the global socket trace level set by environment variable\n or the ini file.\n\n \\in traceLevel Must be a value between 0 to 3, where 0 turns tracing off.\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetSocketTraceLevel(
        traceLevel: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the absolute path to the sapcrypto library to enable TLS encryption via Websocket Rfc.\n \\ingroup general\n\n The parameter pathToLibrary needs also to contain the name of the library.\n This function has the same effect as the sapnwrfc.ini parameter TLS_SAPCRYPTOLIB.\n This API cannot reset a new path to the library during runtime. Once set, the path is definitive.\n\n \\in *pathToLibrary Absolute path to library (.so or .dll).\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcLoadCryptoLibrary(
        pathToLibrary: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the global idle time interval of a Websocket connection in seconds after which\n a keep alive Websocket ping packet is sent.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_WEBSOCKET_PING_INTERVAL.\n The default value is 300; valid values are 0 [off] and a range from 10 [ten seconds] to 86400 [one day].\n\n \\in pingInterval Interval in seconds.\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetWebsocketPingInterval(
        pingInterval: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the global timeout for a WebSocket keep alive ping reply packet in seconds.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_WEBSOCKET_PONG_TIMEOUT.\n If no such so-called pong packet is received from the communication partner as a reply to a previously sent\n WebSocket keep alive ping packet within this timeout period, the connection is considered as broken and will be closed.\n The default value is 60; valid values are 0 [off] and a range from 10 [ten seconds] to 3600 [one hour].\n The timeout value should be set lower than the ping interval, so only one ping is active at a time.\n\n \\in pongTimeout Timeout in seconds.\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetWebsocketPongTimeout(
        pongTimeout: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the maximum size of the trace file, after which the current file is closed and \"rolled over\" to a new file.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_MAX_FILE_SIZE. By default\n two files of a maximum of 512 MB are stored.\n However this function cannot set the size below a minimum value of 20 MB or the value set by RFC_TRACE_MAX_FILE_SIZE\n from the sapnwrfc.ini.\n As unit of measure you can use \"M\" for Megabytes or \"G\" for Gigabytes, for example 1024 and M.\n\n \\in size Size in specified unit\n \\in unit Unit of measurement\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetMaximumTraceFileSize(
        size: ::std::os::raw::c_uint,
        unit: SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the maximum size of stored old trace files, after which the current file is closed and \"rolled over\" to a new file.\n \\ingroup general\n\n This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_MAX_STORED_FILES.\n An additional \"roll\" to a new file after the maximum is reached, triggers a deletion of the oldest file.\n The old stored files are marked with the opening timestamp in the file name, when a \"roll over\" is done.\n By default two files are stored. The current trace file is not yet marked with the time stamp.\n However this function cannot set the size to zero, (it will result in an error,) or to a value lower than the one set\n by RFC_TRACE_MAX_STORED_FILES from the sapnwrfc.ini.\n By setting this value to -1, the limit is disabled and and an infinite amount of concurrent files can\n be kept, i.e. no files will be deleted by the NW RFC library.\n \\warning Attention: Lowering the value might delete some old files, if there are currently more stored\n files than permitted by the new (lower) value.\n\n \\in numberOfFiles Maximum size of stored old trace\n \\out *errorInfo Detail information in case of an error.\n \\return RFC_RC"]
    pub fn RfcSetMaximumStoredTraceFiles(
        numberOfFiles: ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts data in UTF-8 format to SAP_UC strings.\n \\ingroup general\n\n Special case of %RfcUTF8ToSAPUC() with onCCE = 0.\n\n \\in *utf8 Pointer to UTF-8 data to be converted\n \\in utf8Length Number of bytes to convert\n \\out *sapuc Pre-allocated output buffer, which will receive the result. Output will be null-terminated.\n \\inout *sapucSize Needs to be filled with the size of the given output buffer in SAP_UC characters.\n If the given buffer turns out to be too small (return code RFC_BUFFER_TOO_SMALL), it will be filled\n with the required buffer size that would be necessary to convert the given input data.\n \\out *resultLength If the output buffer was large enough, resultLength will be filled with the\n length of the output string in SAP_UC characters.\n \\out *errorInfo Will be filled with additional error information in case of an error.\n \\return RFC_RC"]
    pub fn RfcUTF8ToSAPUC(
        utf8: *const RFC_BYTE,
        utf8Length: ::std::os::raw::c_uint,
        sapuc: *mut SAP_UC,
        sapucSize: *mut ::std::os::raw::c_uint,
        resultLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts data in UTF-8 format to SAP_UC strings.\n \\ingroup general\n\n The function can deal with values that cannot be converted, i.e. invalid UTF8 codepoints. By setting onCCE to 0, the function\n will stop the conversion and return an error. By setting onCCE to 2, the function will replace the invalid codepoint with\n the given substitue.\n This is similiar to the connection parameters ON_CCE and CFIT in the sapnwrfc.ini.\n\n \\in *utf8 Pointer to UTF-8 data to be converted\n \\in utf8Length Number of bytes to convert\n \\out *sapuc Pre-allocated output buffer, which will receive the result. Output will be null-terminated.\n \\inout *sapucSize Needs to be filled with the size of the given output buffer in SAP_UC characters.\n If the given buffer turns out to be too small (return code RFC_BUFFER_TOO_SMALL), it will be filled\n with the required buffer size that would be necessary to convert the given input data.\n \\out *resultLength If the output buffer was large enough, resultLength will be filled with the\n length of the output string in SAP_UC characters.\n \\in onCCE Flag for dealing with failed conversion\n \\in substitute Copdepoint of substitue character, if onCCE = 2\n \\out *errorInfo Will be filled with additional error information in case of an error.\n \\return RFC_RC"]
    pub fn RfcUTF8ToSAPUC_CCE(
        utf8: *const RFC_BYTE,
        utf8Length: ::std::os::raw::c_uint,
        sapuc: *mut SAP_UC,
        sapucSize: *mut ::std::os::raw::c_uint,
        resultLength: *mut ::std::os::raw::c_uint,
        onCCE: ::std::os::raw::c_ushort,
        substitute: SAP_UINT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts data in SAP_UC format to UTF-8 format\n \\ingroup general\n\n Special case of %RfcSAPUCToUTF8_CCE() with onCCE = 0.\n\n \\in *sapuc Pointer to SAP_UC data to be converted\n \\in sapucLength Number of characters to convert\n \\out *utf8 Pre-allocated output buffer, which will receive the result. Output will be null-terminated.\n \\inout *utf8Size Needs to be filled with the size of the given output buffer in bytes.\n If the given buffer turns out to be too small (return code RFC_BUFFER_TOO_SMALL), it will be filled\n with the required buffer size that would be necessary to convert the given input data.\n \\out *resultLength If the output buffer was large enough, resultLength will be filled with the\n length of the output string in bytes.\n \\out *errorInfo Will be filled with additional error information in case of an error.\n \\return RFC_OK or RFC_BUFFER_TOO_SMALL"]
    pub fn RfcSAPUCToUTF8(
        sapuc: *const SAP_UC,
        sapucLength: ::std::os::raw::c_uint,
        utf8: *mut RFC_BYTE,
        utf8Size: *mut ::std::os::raw::c_uint,
        resultLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts data in SAP_UC format to UTF-8 format\n \\ingroup general\n\n The function can deal with values that cannot be converted, i.e. invalid UTF16 codepoints. By setting onCCE to 0, the function\n will stop the conversion and return an error. By setting onCCE to 2, the function will replace the invalid codepoint with\n the given substitue.\n This is similiar to the connection parameters ON_CCE and CFIT in the sapnwrfc.ini.\n\n \\in *sapuc Pointer to SAP_UC data to be converted\n \\in sapucLength Number of characters to convert\n \\out *utf8 Pre-allocated output buffer, which will receive the result. Output will be null-terminated.\n \\inout *utf8Size Needs to be filled with the size of the given output buffer in bytes.\n If the given buffer turns out to be too small (return code RFC_BUFFER_TOO_SMALL), it will be filled\n with the required buffer size that would be necessary to convert the given input data.\n \\out *resultLength If the output buffer was large enough, resultLength will be filled with the\n length of the output string in bytes.\n \\in onCCE Flag for dealing with failed conversion\n \\in substitute Copdepoint of substitue character, if onCCE = 2\n \\out *errorInfo Will be filled with additional error information in case of an error.\n \\return RFC_OK or RFC_BUFFER_TOO_SMALL"]
    pub fn RfcSAPUCToUTF8_CCE(
        sapuc: *const SAP_UC,
        sapucLength: ::std::os::raw::c_uint,
        utf8: *mut RFC_BYTE,
        utf8Size: *mut ::std::os::raw::c_uint,
        resultLength: *mut ::std::os::raw::c_uint,
        onCCE: ::std::os::raw::c_ushort,
        substitute: SAP_UINT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts an RFC_RC return code to a human readable string for logging purposes.\n \\ingroup general\n\n \\in rc Return code to covert to string\n \\return String representation of the return code\n \\warning Don't free the returned SAP_UC pointer -- its's static memory..."]
    pub fn RfcGetRcAsString(rc: RFC_RC) -> *const SAP_UC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts an RFCTYPE data type indicator to a human readable string for logging purposes.\n \\ingroup general\n\n \\in type Data type indicator to convert\n \\return String representation of the type\n \\warning Don't free the returned SAP_UC pointer -- its's static memory..."]
    pub fn RfcGetTypeAsString(type_: RFCTYPE) -> *const SAP_UC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts an RFC_DIRECTION direction indicator to a human readable string for logging purposes.\n \\ingroup general\n\n \\in direction Direction indicator to convert\n \\return String representation of the direction\n \\warning Don't free the returned SAP_UC pointer -- its's static memory..."]
    pub fn RfcGetDirectionAsString(direction: RFC_DIRECTION) -> *const SAP_UC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts an RFC_SERVER_STATE state indicator to a human readable string for logging purposes.\n \\ingroup general\n\n \\in serverState State indicator to convert\n \\return String representation of the state\n \\warning Don't free the returned SAP_UC pointer -- its's static memory..."]
    pub fn RfcGetServerStateAsString(serverState: RFC_SERVER_STATE) -> *const SAP_UC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts an RFC_SESSION_EVENT to a human readable string for logging purposes.\n \\ingroup general\n\n \\in sessionEvent Session event to convert\n \\return String representation of the event\n \\warning Don't free the returned SAP_UC pointer -- its's static memory..."]
    pub fn RfcGetSessionEventAsString(sessionEvent: RFC_SESSION_EVENT) -> *const SAP_UC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts a 2-char SAP language code to the 1-char SAP language code.\n \\ingroup general\n\n \\in *laiso Pointer to the 2-char array with SAP LAISO code to convert\n \\out *lang Pointer to the 1 char for SAP SPRAS key\n \\out *errorInfo Will be filled with additional error information in case of an error.\n \\return RFC_RC RFC_OK or RFC_INVALID_PARAMETER in case of an error\n \\warning The SAP LAISO code is not 100% ISO639_1 compliant - see also ABAP table T002X columns SPRAS/LAISO for details"]
    pub fn RfcLanguageIsoToSap(
        laiso: *const SAP_UC,
        lang: *mut SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts a 1-char SAP language key to the 2-char SAP language code.\n \\ingroup general\n\n \\in *lang Pointer to the 1 char with SAP SPRAS key to convert\n \\out *laiso Pointer to the 2-char array for SAP LAISO code\n \\out *errorInfo Will be filled with additional error information in case of an error.\n \\return RFC_RC RFC_OK or RFC_INVALID_PARAMETER in case of an error\n \\warning The SAP LAISO code is not 100% ISO639_1 compliant - see also ABAP table T002X columns SPRAS/LAISO for details"]
    pub fn RfcLanguageSapToIso(
        lang: *const SAP_UC,
        laiso: *mut SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a list of names of all SAP Systems maintained in SAPLogon (saplogon.ini or SAPUILandscape.xml).\n \\ingroup connection\n\n On Windows systems, where SAPLogon is installed, the logon parameters defined in saplogon.ini can be used for opening connections\n to those backend systems. This routine retrieves a list of all available SAP systems. Each key in the list can be used as a value\n for RFC_CONNECTION_PARAMETER.value, where RFC_CONNECTION_PARAMETER.name = \"SAPLOGON_ID\".\n For more information see the documentation of the SAPLOGON_ID parameter in the sample sapnwrfc.ini file.\n\n If the API returns successfully, you should call RfcFreeSaplogonEntries() with the same inputs, once you no longer need the\n SAPLogon IDs, so that the memory occupied by them can be cleaned up.\n\n Sample code illustrating how to use the SAPLogon IDs: \\code\n SAP_UC** logonIDList;\n unsigned numEntries;\n RfcGetSaplogonEntries(&logonIDList, &numEntries, &errorInfo);\n\n if (errorInfo.code == RFC_OK){\n \t   for (unsigned i=0; i<numEntries; ++i) printfU(cU(\"%s\\n\"), logonIDList[i]);\n }\n RfcFreeSaplogonEntries(&logonIDList, &numEntries, &errorInfo);\n \\endcode\n\n \\out ***saplogonIDList Receives a pointer to a SAP_UC* array containing the SAPLogon IDs.\n \\out *numSaplogonIDs Will be filled with the number of SAPLogon IDs in the list.\n \\out *errorInfo Returns more error details, if the list of saplogon.ini keys could not be retrieved.\n \\return RFC_MEMORY_INSUFFICIENT, if unable to malloc memory for the ID list; RFC_NOT_FOUND, if saplogon.ini could not be found on that system or is empty."]
    pub fn RfcGetSaplogonEntries(
        saplogonIDList: *mut *mut *mut SAP_UC,
        numSaplogonIDs: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Frees a list of SAPLogon IDs obtained from RfcGetSaplogonEntries().\n \\ingroup connection\n\n When you no longer need the SAPLogon IDs obtained from RfcGetSaplogonEntries(), you should call this function with the same\n arguments that got filled by RfcGetSaplogonEntries(). This will free any internal memory occupied by the list of SAPLogon IDs.\n\n \\inout ***saplogonIDList Points to an SAP_UC* array that was previously filled by RfcGetSaplogonEntries(). Will be set to NULL.\n \\inout *numSaplogonIDs Points to the length of the SAPLogon ID list. Will be set to 0.\n \\out *errorInfo Returns more error details, if something goes wrong.\n \\return Nothing that can go wrong here really."]
    pub fn RfcFreeSaplogonEntries(
        saplogonIDList: *mut *mut *mut SAP_UC,
        numSaplogonIDs: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Retrieves all connection parameters corresponding to the given ID from the saplogon.ini or SAPUILandscape.xml file.\n \\ingroup connection\n\n The ID needs to be one of those returned by RfcGetSaplogonEntries(). It is the same as can also be used as connection\n parameter SAPLOGON_ID.\n\n \\in *saplogonID A SAPLogon ID uniquely identifying a certain saplogon.ini or SAPUILandscape.xml entry.\n \\out **entryParameters Receives a pointer to a RFC_CONNECTION_PARAMETER array containing the parameters of the given SAPLogon ID.\n \\out *numParameters Will be filled with the number of connection parameters in the array.\n \\out *errorInfo Returns more error details, if something goes wrong, e.g. out of memory or SAPLogon ID cannot be found.\n \\return Nothing that can go wrong here really."]
    pub fn RfcGetSaplogonEntry(
        saplogonID: *mut SAP_UC,
        entryParameters: *mut *mut RFC_CONNECTION_PARAMETER,
        numParameters: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Frees an array of connection parameters obtained from RfcGetSaplogonEntry().\n \\ingroup connection\n\n When you no longer need the connection parameters obtained from RfcGetSaplogonEntries(), you should call this function with the same\n arguments that got filled by RfcGetSaplogonEntry(). This will free any internal memory occupied by the array of parameters.\n\n \\inout **entryParameters Points to an RFC_CONNECTION_PARAMETER array that was previously filled by RfcGetSaplogonEntry(). Will be set to NULL.\n \\inout *numParameters Points to the length of the connection parameter array. Will be set to 0.\n \\out *errorInfo Returns more error details, if something goes wrong.\n \\return Nothing that can go wrong here really."]
    pub fn RfcFreeSaplogonEntry(
        entryParameters: *mut *mut RFC_CONNECTION_PARAMETER,
        numParameters: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Opens an RFC client connection for invoking ABAP function modules in an R/3 backend.\n \\ingroup connection\n\n Opens a client connection to an SAP System. The connectionParams may contain the following name-value pairs:\n - client, user, passwd, lang, trace\n\n and additionally one of\n -# Direct application server logon: ashost, sysnr.\n -# Logon with load balancing: mshost, msserv, sysid, group.\\n\n    msserv is needed only, if the service of the message server is\n    not defined as sapms<SYSID> in /etc/services.\n\n When logging on with SNC, user&passwd are to be replaced by\n - snc_qop, snc_myname, snc_partnername and optionally snc_lib.\n\n (If snc_lib is not specified, the underlying SNC layer uses the \"global\" GSS library\n defined via environment variable SNC_LIB or SNC_LIB_64.)\n\n When logging on with SSO Ticket, you can use mysapsso2 instead of user&passwd.\n The old SSO format (mysapsso) is no longer supported.\n\n\n Alternatively the connection parameters can be defined in the config file\n sapnwrfc.ini. In this case you just pass the parameter dest=... and all\n parameters that are missing in the sapnwrfc.ini entry into %RfcOpenConnection().\n\n For a complete list of logon parameters to be used in connectionParams as well as in the\n sapnwrfc.ini file, see the sample sapnwrfc.ini file in the SDK's demo folder.\n\n If the logon was ok, %RfcOpenConnection() returns a client connection handle, which can be used in RfcInvoke().\n Otherwise the return value is NULL and errorInfo contains a detailed error description.\n errorInfo->code will be one of:\n - RFC_INVALID_PARAMETER\t\t\tOne of the connectionParams was invalid\n - RFC_COMMUNICATION_FAILURE\t\tSomething is wrong with the network or network settings\n - RFC_LOGON_FAILURE\t\t\t\tInvalid user/password/ticket/certificate\n - RFC_ABAP_RUNTIME_FAILURE\t\tSomething is wrong with the R/3 backend\n - RFC_MEMORY_INSUFFICIENT\t\tA malloc failed when trying to allocate a temporary buffer\n\n\n \\in *connectionParams An array of RFC_CONNECTION_PARAMETERs with the names as described above\n and the values as necessary in your landscape.\n \\in paramCount Number of parameters in the above array.\n \\out *errorInfo Returns more error details, if the connect attempt fails.\n \\return A handle to an RFC client connection that can be used for invoking ABAP function modules in the backend."]
    pub fn RfcOpenConnection(
        connectionParams: *const RFC_CONNECTION_PARAMETER,
        paramCount: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CONNECTION_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Registers a server connection at an SAP gateway.\n \\ingroup connection\n\n The connectionParams may contain the following name-value pairs:\n - gwhost, gwserv, program_id, trace, and the parameters for SNC communication as in RfcOpenConnection().\n\n Program_id corresponds to an RFC destination in SM59 of type \"T\" in registration mode.\n\n For a complete list of logon parameters to be used in connectionParams as well as in the\n sapnwrfc.ini file, see the sample sapnwrfc.ini file in the SDK's demo folder.\n\n If the connection registration was ok, %RfcRegisterServer() returns a server connection handle, which can\n be used in RfcListenAndDispatch().\n Otherwise the return value is NULL and errorInfo contains information similar to the RfcOpenConnection() case.\n\n\n \\in *connectionParams An array of RFC_CONNECTION_PARAMETERs with the names as described above\n and the values as necessary in your landscape.\n \\in paramCount Number of parameters in the above array.\n \\out *errorInfo Returns more error details, if the connect attempt fails.\n \\return A handle to an RFC server connection that can be used for listening for function module requests from the backend."]
    pub fn RfcRegisterServer(
        connectionParams: *const RFC_CONNECTION_PARAMETER,
        paramCount: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CONNECTION_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Allows a program to be used as an RFC server which is started by the backend on demand.\n \\ingroup connection\n\n This API needs to be called, if the server program is to be started by the R/3 application server.\n (RFC destination in SM59 of type \"T\" in startup mode.)\n argc and argv are the inputs of the mainU function. The R/3 application server passes the correct command line to\n the program, when starting it up, so you only need to forward these two parameters to %RfcStartServer().\n connectionParams is optional and is only needed, if you want to add additional logon parameters to the\n ones coming from the command line, e.g for activating trace.\n\n Like RfcRegisterServer(), the function returns a server connection handle that can be used in RfcListenAndDispatch().\n The mechanism of this kind of RFC destination thus works as follows:\n -# The R/3 application server opens a telnet connection to the host, where your server program is located, and\n    starts the program with the necessary logon parameters. (Or creates a child process, if the startup\n    method is \"Start on application server\".)\n -# Your server program calls RfcStartServer, which opens an RFC connection back to the R/3 system.\n -# The R/3 system then makes the function call over that RFC connection.\n\n The main differences of \"startup mode\" compared to the \"registration mode\" are:\n - Advantage: no logon parameters need to be maintained in the server program. (Unless you want to open\n   an additional client connection for looking up function module metadata (RFC_FUNCTION_DESC_HANDLEs) in the\n   R/3 DDIC.)\n - Disadvantage: every single function call creates a new process and possibly a remote shell connection in addition to\n   the actual RFC connection.\n\n\n \\in argc From mainU() (command line supplied by backend)\n \\in **argv From mainU() (command line supplied by backend)\n \\in *connectionParams May optionally contain additional logon parameters\n \\in paramCount Length of the connection parameter array above\n \\out *errorInfo Returns more error details, if the connect attempt fails.\n \\return A handle to an RFC server connection that can be used for listening for function module requests from the backend."]
    pub fn RfcStartServer(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut SAP_UC,
        connectionParams: *const RFC_CONNECTION_PARAMETER,
        paramCount: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CONNECTION_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Closes an RFC connection\n \\ingroup connection\n\n Can be used to close client connections as well as server connections, when they are no longer needed.\n\n\n \\in rfcHandle Connection to be closed\n \\out *errorInfo Error details in case closing the connection fails. (Can usually be ignored...)\n \\return RFC_RC"]
    pub fn RfcCloseConnection(
        rfcHandle: RFC_CONNECTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Checks an RFC connection\n \\ingroup connection\n\n Can be used to check whether a client/server connection has already been closed,\n or whether the NW RFC library still \"considers\" the connection to be open.\n Note that this does not guarantee that the connection is indeed still alive:\n A firewall may silently have closed the connection without notifying the endpoints.\n If you want to find out, whether the connection is still alive, you'll have to\n use the more expensive RfcPing().\n\n\n \\in rfcHandle Connection to be checked\n \\out *isValid 1, if the connection is still found in the internal connection management, 0 otherwise.\n \\out *errorInfo Error details in case the connection is invalid.\n \\return RFC_RC"]
    pub fn RfcIsConnectionHandleValid(
        rfcHandle: RFC_CONNECTION_HANDLE,
        isValid: *mut ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Cancels the RFC call which is currently being called over the given RFC connection and closes the connection\n \\ingroup connection\n\n Can be used only on an RFC client connection and needs to be called from a different thread than the one currently executing the RFC call.\n\n\n \\in rfcHandle RFC client connection which is currently blocked in RfcInvoke().\n \\out *errorInfo Error details in case canceling fails. (Can usually be ignored...)\n \\return RFC_OK, if cancel was requested; RFC_ILLEGAL_STATE, if the connection is currently not in a call; or RFC_NOT_SUPPORTED, if the handle is a server handle."]
    pub fn RfcCancel(rfcHandle: RFC_CONNECTION_HANDLE, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  RFC_RC SAP_API RfcResetServerContext\n \\ingroup connection\n\n Resets the SAP server context (\"user context / ABAP session context\") associated with the given client\n connection, but does not close the connection.\n\n\n \\in rfcHandle The client connection, whose server context is to be reset.\n \\out *errorInfo Error details in case resetting the server context fails. (Better close the connection in that case.)\n \\return RFC_RC"]
    pub fn RfcResetServerContext(
        rfcHandle: RFC_CONNECTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Ping the remote communication partner through the passed connection handle.\n \\ingroup connection\n\n Sends a ping to the backend in order to check, whether the connection is still alive.\n Can be used on both, client connections as well as server connections.\n \\warning Do not use inside a server function implementation.\n\n\n \\in rfcHandle The connection to check\n \\out *errorInfo More error details in case the connection is broken.\n \\return RFC_RC"]
    pub fn RfcPing(rfcHandle: RFC_CONNECTION_HANDLE, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns details about the current client or server connection.\n \\ingroup connection\n\n Consider that in case you are a server and call RfcListenAndDispatch(), the partner fields\n of the attributes will be cleared. The reason is, although we might be only connected to a\n gateway of one application server, the function module can be also called from the other\n application servers of the system if configured accordingly in the SM59 destination.\n\n I.e. expect only valid partner information from within a function module. Outside of the\n function module, e.g. in the loop where RfcListenAndDispatch is called, you will get\n cleared partner information in most of the cases except case RFC_OK, which means that you\n were just called by an application server.\n\n See documentation of RFC_ATTRIBUTES.\n\n\n \\in rfcHandle RFC connection\n \\out *attr Information about the current connection and the communication partner on the other side.\n \\out *errorInfo Additional error information (e.g. connection already closed).\n \\return RFC_RC"]
    pub fn RfcGetConnectionAttributes(
        rfcHandle: RFC_CONNECTION_HANDLE,
        attr: *mut RFC_ATTRIBUTES,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Inside a server function, returns details about the current execution context.\n \\ingroup connection\n\n See documentation of RFC_SERVER_CONTEXT.\n\n\n \\in rfcHandle RFC server connection\n \\out *context Information about the current server execution context.\n \\out *errorInfo Additional error information (e.g. connection is not a server connection).\n \\return RFC_RC"]
    pub fn RfcGetServerContext(
        rfcHandle: RFC_CONNECTION_HANDLE,
        context: *mut RFC_SERVER_CONTEXT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the SAPRouter, if any.\n \\ingroup connection\n\n\n \\in rfcHandle RFC connection\n \\out *sapRouter Pre-allocated buffer\n \\inout *length Needs to be filled with the buffer length of sapRouter. The return value will be the string\n length of the returned sapRouter (if buffer was large enough) or the required buffer size (if RFC_BUFFER_TOO_SMALL).\n In the first case, the length value will be the string length without the terminating zero, in the second case it will be the\n required buffer size including the terminating zero.\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_BUFFER_TOO_SMALL, if the provided sapRouter buffer was too small. RFC_OK otherwise."]
    pub fn RfcGetSapRouter(
        rfcHandle: RFC_CONNECTION_HANDLE,
        sapRouter: *mut SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the external IP address of the communication partner.\n \\ingroup connection\n\n In scenarios where NAT (Network Address Translation) is performed between the LAN segment, where the external RFC program is\n running, and the LAN segment, where the backend system is running, the RFC_ATTRIBUTES (members \"partnerHost\", \"partnerIP\" or \"partnerIPv6\")\n will always contain the hostname/address returned by the backend system, which is the address as it is known inside the internal LAN segment.\n However, this address is usually unusable/invalid inside the external LAN segment. External programs that need a valid \"external\" IP address\n of the current communication partner, can use this API to obtain it.\n If no NAT is used in the current scenario, the value returned by this API will be equal to partnerIP/partnerIPv6 from the RFC_ATTRIBUTES.\n\n\n \\in rfcHandle RFC connection\n \\out *partnerExternalIP Pre-allocated buffer\n \\inout *length Needs to be filled with the buffer length of partnerExternalIP. The return value will be the string\n length of the returned external IP (if buffer was large enough) or the required buffer size (if RFC_BUFFER_TOO_SMALL).\n In the first case, the length value will be the string length without the terminating zero, in the second case it will be the\n required buffer size including the terminating zero.\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_BUFFER_TOO_SMALL, if the provided partnerExternalIP buffer was too small.\n         RFC_INVALID_HANDLE, if the given rfcHandle is not connected.\n         RFC_INVALID_PARAMETER, if one of the input values is invalid.\n         RFC_OK otherwise."]
    pub fn RfcGetPartnerExternalIP(
        rfcHandle: RFC_CONNECTION_HANDLE,
        partnerExternalIP: *mut SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the IP address of the local network interface used by this connection.\n \\ingroup connection\n\n On servers with multiple network interfaces, it may be useful to know, via which interface the current connection has been established.\n\n\n \\in rfcHandle RFC connection\n \\out *localAddress Pre-allocated buffer. If you use a buffer of length at least 46, it will always be sufficient,\n even in case of IPv6 addresses.\n \\inout *length Needs to be filled with the buffer length of partnerExternalIP. The return value will be the string\n length of the returned external IP (if buffer was large enough) or the required buffer size (if RFC_BUFFER_TOO_SMALL).\n In the first case, the length value will be the string length without the terminating zero, in the second case it will be the\n required buffer size including the terminating zero.\n \\out *localPort The local port used for the network connection.\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_BUFFER_TOO_SMALL, if the provided partnerExternalIP buffer was too small.\n         RFC_INVALID_HANDLE, if the given rfcHandle is not connected.\n         RFC_INVALID_PARAMETER, if one of the input values is invalid.\n         RFC_EXTERNAL_FAILURE, if a network level error occurs.\n         RFC_OK otherwise."]
    pub fn RfcGetLocalAddress(
        rfcHandle: RFC_CONNECTION_HANDLE,
        localAddress: *mut SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        localPort: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the partner's SSO2 ticket, if any.\n \\ingroup connection\n\n Can be used in two cases: call it inside the implementation of a server function and pass the server connection as rfcHandle,\n if you want to obtain the ticket sent from the ABAP side. For this to work, one of the flags \"Send Logon Ticket\" or \"Send\n Assertion Ticket\" (or similar) needs to be activated in the definition of the corresponding RFC destination in SM59.\n Or call it after RfcOpenConnection() and pass the client connection as rfcHandle, to obtain the ticket issued for the currrently\n logged in user. For this to work, the connection must be opened with parameter GETSSO2=1 and the profile parameter\n login/create_sso2_ticket must be set to a value different from \"0\" in the backend.\n\n\n \\in rfcHandle RFC server connection\n \\out *ssoTicket Pre-allocated buffer, which will receive the backend user's SSO2 ticket (signed user information in base64 format)\n \\inout *length Needs to be filled with the buffer length of ssoTicket. The return value will be the string\n length of the returned ticket (if buffer was large enough) or the required buffer size (if RFC_BUFFER_TOO_SMALL).\n In the first case, the length value will be the string length without the terminating zero, in the second case it will be the\n required buffer size including the terminating zero.\n \\out *errorInfo More error details in case there is no ticket.\n \\return RFC_RC\n \\warning"]
    pub fn RfcGetPartnerSSOTicket(
        rfcHandle: RFC_CONNECTION_HANDLE,
        ssoTicket: *mut SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the partner's SNC name, if any.\n \\ingroup connection\n\n\n \\in rfcHandle RFC server connection. If this function is executed on a client connection, RFC_ILLEGAL_STATE will be returned.\n \\out *sncName Pre-allocated buffer, which will receive the backend user's SNC name (null-terminated string).\n \\in length Size of the pre-allocated buffer. This information is coming from the GSS library, therefore\n unfortunately the feature of assigning the used/required length to an output parameter is not possible in this case.\n The maximum length of an SNC name is 256.\n \\out *errorInfo More error details in case SNC is not active.\n \\return RFC_RC"]
    pub fn RfcGetPartnerSNCName(
        rfcHandle: RFC_CONNECTION_HANDLE,
        sncName: *mut SAP_UC,
        length: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets partner's SNC key, if any.\n \\ingroup connection\n\n\n \\in rfcHandle RFC server connection. If this function is executed on a client connection, RFC_ILLEGAL_STATE will be returned.\n \\out *sncKey Pre-allocated buffer, which will receive the backend user's SNC key.\n \\inout *length Needs to be filled with the buffer length of ssoTicket. The return value will be the byte\n length of the returned key (if buffer was large enough). Unfortunately in case of RFC_BUFFER_TOO_SMALL\n the required size is not returned by the GSS library.\n The maximum length of an SNC key is 1024.\n \\out *errorInfo More error details in case SNC is not active.\n \\return RFC_RC"]
    pub fn RfcGetPartnerSNCKey(
        rfcHandle: RFC_CONNECTION_HANDLE,
        sncKey: *mut SAP_RAW,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts SNC name to SNC key.\n \\ingroup connection\n\n\n \\in *sncLib Optional: file name of the GSS library to be used for the conversion. If not specified, the\n \"global\" GSS library (environment variable SNC_LIB or SNC_LIB_64) will be used.\n \\in *sncName Null-terminated SNC name to be converted.\n \\out *sncKey Pre-allocated buffer, which will receive the corresponding SNC key.\n \\inout *keyLength Needs to be filled with the buffer length of sncKey. The return value will be byte length\n of the SNC key (if buffer was large enough). Unfortunately in case of RFC_BUFFER_TOO_SMALL\n the required size is not returned by the GSS library.\n The maximum length of an SNC key is 1024.\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcSNCNameToKey(
        sncLib: *const SAP_UC,
        sncName: *const SAP_UC,
        sncKey: *mut SAP_RAW,
        keyLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Converts SNC key to SNC name.\n \\ingroup connection\n\n\n \\in *sncLib Optional: file name of the GSS library to be used for the conversion. If not specified, the\n \"global\" GSS library (environment variable SNC_LIB or SNC_LIB_64) will be used.\n \\in *sncKey SNC key to be converted.\n \\in keyLength Byte length of the given SNC key\n \\out *sncName Pre-allocated buffer, which will receive the corresponding (null-terminated) SNC name.\n \\in nameLength Size of the given sncName buffer. (The maximum length of an SNC name is 256.)\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcSNCKeyToName(
        sncLib: *const SAP_UC,
        sncKey: *const SAP_RAW,
        keyLength: ::std::os::raw::c_uint,
        sncName: *mut SAP_UC,
        nameLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Listens on a server connection handle and waits for incoming RFC calls from the R/3 system.\n \\ingroup connection\n\n The mechanism for dispatching incoming function calls works as follows:\n First %RfcListenAndDispatch() checks, whether for the current combination of R/3 SystemID and function\n module name a callback function has been installed via RfcInstallServerFunction(). If not, it checks,\n whether a callback function for SystemID=NULL has been installed via RfcInstallServerFunction().If not,\n it checks, whether a global callback function has been installed via RfcInstallGenericServerFunction().\n\n If a callback function has been found, the RFC call will be dispatched to that function for processing,\n and %RfcListenAndDispatch() returns the return code of the callback function.\n Otherwise %RfcListenAndDispatch() returns a SYSTEM_FAILURE to the R/3 backend and the return code\n RFC_NOT_FOUND to the caller.\n\n In general the return codes of %RfcListenAndDispatch() have the following meaning:\n - RFC_OK\\n\t\tA function call was processed successfully.\n - RFC_RETRY\\n\tNo function call came in within the specified timeout period. (\"timeout\" is given in seconds.)\n - RFC_ABAP_EXCEPTION\\n\tA function call was processed and ended with a defined ABAP Exception, which has\n\t\t\t\t\tbeen returned to the backend.\n\n In the above three cases \"rfcHandle\" is still open and can be used to listen for the next request.\n\n - RFC_ABAP_MESSAGE\\n\tA function call was started to be processed, but was aborted with an ABAP A-, E- or X-Message.\n\t\t\t\tThe message parameters have been returned to the backend (and can be evaluated there via\n\t\t\t\tthe sy-msgid, sy-msgtype, sy-msgno, sy-msgv1, ..., sy-msgv4 parameters).\n - RFC_EXTERNAL_FAILURE\\n\tA function call was started to be processed, but was aborted with a \"SYSTEM_FAILURE\",\n\t\t\t\twhich has been returned to the backend.\n - RFC_COMMUNICATION_FAILURE\\n\tThe connection broke down while processing the function call. No response\n\t\t\t\thas been sent to the backend.\n - RFC_CLOSED\\n\tThe connection has been closed by the backend side (SMGW, SM04). No response\n\t\t\t\thas been sent to the backend.\n - RFC_NOT_FOUND\\n\tNo handler has been found for the current function module name. A SYSTEM_FAILURE has\n\t\t\t\tbeen returned to the R/3 backend.\n\n In these five cases the connection has been closed, so the \"rfcHandle\" needs to be refreshed via RfcRegisterServer.\n\n - RFC_INVALID_HANDLE\\n\t\"rfcHandle\" is invalid or points to a connection that has already been closed.\n\n\n \\in rfcHandle Server connection on which to listen for incoming requests.\n \\in timeout Number of seconds to wait for an incoming request.\n \\out *errorInfo Additional error information.\n \\return RFC_RC"]
    pub fn RfcListenAndDispatch(
        rfcHandle: RFC_CONNECTION_HANDLE,
        timeout: ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Executes a function module in the backend system.\n \\ingroup connection\n\n The return codes have the following meaning:\n - RFC_OK\\n\t\tThe function call was executed successfully.\n - RFC_ABAP_EXCEPTION\\n\tThe function call was executed and ended with a defined ABAP Exception. The key of the\n\t\t\t\t\texception can be obtained from errorInfo->key.\n\n In the above two cases \"rfcHandle\" is still open and can be used to execute further function call.\n\n - RFC_ABAP_MESSAGE\\n\tThe function call was started to be processed, but was aborted with an ABAP Message.\n\t\t\t\tThe message parameters can be obtained from errorInfo->abapMsgClass, errorInfo->abapMsgType,\n\t\t\t\terrorInfo->abapMsgNumber, errorInfo->abapMsgV1, ..., errorInfo->abapMsgV4.\n - RFC_ABAP_RUNTIME_FAILURE\\n\tThe function call was started to be processed, but was aborted with a SYSTEM_FAILURE\n\t\t\t\t(e.g division by zero, unhandled exception, etc in the backend system).\n\t\t\t\tDetails can be obtained from errorInfo->message.\n - RFC_COMMUNICATION_FAILURE\\n\tThe connection broke down while processing the function call.\n\t\t\t\tDetails can be obtained from errorInfo->message.\n\n In these three cases the connection has been closed, so the \"rfcHandle\" needs to be refreshed via RfcOpenConnection.\n\n - RFC_INVALID_HANDLE\\n\t\"rfcHandle\" is invalid or points to a connection that has already been closed.\n\n\n \\in rfcHandle Client connection over which to execute the function module.\n \\inout funcHandle Data container containing the input data for the function module.\n %RfcInvoke() will write the FM's output data into this container.\n \\out *errorInfo Additional error information.\n \\return RFC_RC"]
    pub fn RfcInvoke(
        rfcHandle: RFC_CONNECTION_HANDLE,
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  This function can be used to start \"automatic\" servers.\n \\ingroup autoserver\n\n In contrast to RfcRegisterServer(), which registers one single server connection at a SAP gateway, %RfcCreateServer() can be used\n to create a server object that manages multiple server connections in parallel, that takes care of automatically\n re-registering a connection in case it gets broken by network problems, etc. and that takes care of the dispatch-loop\n internally, so that application programmers no longer need to implement that error-prone task themselves. This means,\n you no longer need to use RfcListenAndDispatch() and no longer need to worry about creating multiple threads with such a\n listen- and dispatch-loop, if you want to process multiple parallel requests. All you need to do is starting an RFC_SERVER_HANDLE\n with RfcLaunchServer(), and it will listen for incoming requests on n parallel threads (as given by the parameter REG_COUNT).\n\n In addition, you can start not only a usual registered Server that registers at an RFC gateway, but also a standalone Server\n that listens for requests on a network port and can be accessed by both, SAP systems and other external C-, Java- or .NET-based\n RFC client programs. Which kind of server is started, depends on the connection parameters:\n\n Registered Server:\n Here you need to supply the standard parameters you would also use with RfcRegisterServer(). E.g. GWHOST, GWSERV and PROGRAM_ID,\n followed potentially by parameters for SNC, Trace, SAPRouter, etc. In addition you can supply the parameters REG_COUNT and MAX_REG_COUNT,\n if you want to process multiple requests in parallel (multiple gateway registrations). MAX_REG_COUNT is needed only for \"stateful\"\n RFC servers (see the sample sapnwrfc.ini for details).\n Alternatively to registering at only one fixed gateway, you can also provide parameters for \"group registration\". Then the server will\n register REG_COUNT connections at every gateway of the given logon group. Again see chapter 3 in the sapnwrfc.ini file.\n\n\n For all types of servers you need to specify the parameter SERVER_NAME. This is a freely choosable name used for monitoring purposes.\n\n After a server object has been created, it can be started and stopped any number of times via RfcLaunchServer() and RfcShutdownServer().\n When the server is no longer needed, it must be cleaned up with RfcDestroyServer().\n\n \\in *connectionParams Array of network parameters needed for starting the server.\n \\out paramCount Number of elements contained in the RFC_CONNECTION_PARAMETER array.\n \\out *errorInfo Additional error information in case the server object could not be created (e.g. invalid parameters or insufficient memory).\n \\return A handle to the created server object."]
    pub fn RfcCreateServer(
        connectionParams: *const RFC_CONNECTION_PARAMETER,
        paramCount: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_SERVER_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Cleans up and destroys an automatic server object, once you are done with it.\n \\ingroup autoserver\n\n Any internal resources of this server object are released. Therefore make sure not to use the RFC_SERVER_HANDLE in any further API calls\n(RfcLaunchServer(), RfcShutdownServer(), etc), after you have destroyed it.\n\n\n \\in serverHandle A handle to the server object.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_OK"]
    pub fn RfcDestroyServer(
        serverHandle: RFC_SERVER_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Starts up an automatic server, so that it starts waiting for incoming requests and processes them.\n \\ingroup autoserver\n\n\n \\in serverHandle A handle to the server object.\n \\out *errorInfo Additional error information in case starting the server fails.\n \\return RFC_RC"]
    pub fn RfcLaunchServer(
        serverHandle: RFC_SERVER_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Stops an automatic server, so that it no longer accepts incoming requests.\n \\ingroup autoserver\n\n If timeout is set to 0, the server stops immediately, aborting any currently ongoing RFC requests. If you want to give any possibly ongoing requests a\n chance to complete, before stopping the server, provide a timeout > 0. %RfcShutdownServer() will then block until all current requests are completed\n or the timeout period is over, whichever occurs first. In any case, the server will immediately stop accepting new requests as soon as you call this function.\n\n If at a later point you want this server to resume listening for requests, you can start it again by calling RfcLaunchServer(). However, once you have\n cleaned up the server with RfcDestroyServer(), you must no longer attempt to use it in further RfcLaunchServer() (or other) calls.\n\n \\in serverHandle A handle to the server object.\n \\in timeout Number of seconds to wait in order to give currently ongoing RFC requests time to complete.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_OK"]
    pub fn RfcShutdownServer(
        serverHandle: RFC_SERVER_HANDLE,
        timeout: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Retrieves detailed information about a multi-count Registered Server or a TCP Socket Server.\n \\ingroup autoserver\n\n See RFC_SERVER_ATTRIBUTES for more details.\n\n \\in serverHandle A handle to the server object.\n \\out *serverAttributes Is filled with state information, number of busy connections, etc.\n \\out *errorInfo Not much can go wrong here, except an invalid handle.\n \\return RFC_RC"]
    pub fn RfcGetServerAttributes(
        serverHandle: RFC_SERVER_HANDLE,
        serverAttributes: *mut RFC_SERVER_ATTRIBUTES,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Retrieves detailed information about all clients currently connected to a multi-count Registered Server or a TCP Socket Server.\n \\ingroup autoserver\n\n For every connected client you get its connection attributes (hostname, SID, user, client) as well as the current function module name,\n if the connection is busy, or the last activity time, if it is idle.\n Make sure to release the memory again with RfcDestroyServerConnectionMonitorData(), after you are done with it.\n\n \\in serverHandle A handle to the server object.\n \\out *numberOfConnections Number of client connections currently connected to this server.\n \\out **connectionData An array of monitor data structs, one for each client connection.\n \\out *errorInfo Not much can go wrong here, except an invalid handle or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetServerConnectionMonitorData(
        serverHandle: RFC_SERVER_HANDLE,
        numberOfConnections: *mut ::std::os::raw::c_uint,
        connectionData: *mut *mut RFC_SERVER_MONITOR_DATA,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases all internal memory hold by monitor data object.\n \\ingroup autoserver\n\n Use this to free the data obtained from RfcGetServerConnectionMonitorData() once you no longer need it.\n\n \\in numberOfConnections Number of elements in the connectionData array.\n \\in connectionData Array of connection data objects to be cleaned up.\n \\out *errorInfo Can't go wrong...\n \\return RFC_OK"]
    pub fn RfcDestroyServerConnectionMonitorData(
        numberOfConnections: ::std::os::raw::c_uint,
        connectionData: *mut RFC_SERVER_MONITOR_DATA,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds an error listener to this server.\n \\ingroup autoserver\n\n An error listener is a callback function of type RFC_SERVER_ERROR_LISTENER. The server will execute this function, whenever a\n severe technical error happens outside the processing of function modules, e.g. network problems with the gateway or with the\n connected clients.\n\n \\in serverHandle A handle to the server object.\n \\in errorListener Function pointer to a callback function receiving error notifications.\n \\out *errorInfo Additional error information in case adding the error listener fails, e.g. invalid handle.\n \\return RFC_RC"]
    pub fn RfcAddServerErrorListener(
        serverHandle: RFC_SERVER_HANDLE,
        errorListener: RFC_SERVER_ERROR_LISTENER,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a state change listener to this server.\n \\ingroup autoserver\n\n A state change listener is a callback function of type RFC_SERVER_STATE_CHANGE_LISTENER. The server will execute this function,\n whenever the server's state changes, e.g. from STARTED to ALIVE, or from ALIVE to STOPPING.\n\n \\in serverHandle A handle to the server object.\n \\in stateChangeListener Function pointer to a callback function receiving state change notifications.\n \\out *errorInfo Additional error information in case adding the state change listener fails, e.g. invalid handle.\n \\return RFC_RC"]
    pub fn RfcAddServerStateChangedListener(
        serverHandle: RFC_SERVER_HANDLE,
        stateChangeListener: RFC_SERVER_STATE_CHANGE_LISTENER,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a session change listener to this server.\n \\ingroup autoserver\n\n A session change listener is a callback function of type RFC_SESSION_STATE_CHANGE_LISTENER. The server will execute this function,\n whenever a stateful user session starts or ends. A \"stateful user session\" is basically a one-to-one binding between a SAP user session\n on ABAP side and some kind of \"user session\" in your C program. State information can be kept on C side inbetween separate function\n calls from ABAP.\n\n The server will also execute this function, whenever an ABAP function call begins or ends inside an existing stateful user session.\n For most applications, this probably does not matter, so this event can be ignored. There may however be cases, where some cleanup\n or reduction of consumed resources can be done, while a stateful user session is idle.\n\n There are two ways to start a stateful user session:\n - The ABAP side requests to start a stateful sequence by calling RFM RFC_SET_REG_SERVER_PROPERTY with parameter EXCLUSIV = 'Y'\n - The C program, while currently processing a request from ABAP, can set the current connection to stateful via RfcSetServerStateful()\n\n There are four ways a stateful user session can end:\n - The ABAP side ends the stateful sequence by calling RFM RFC_SET_REG_SERVER_PROPERTY with parameter EXCLUSIV = 'N'\n - The C program, while currently processing a request from ABAP, can end the current stateful session via RfcSetServerStateful()\n - The SAP user session on ABAP side ends.\\n\n   This can be, because the SAP user logs out, or ends the current internal mode by pressing the \"yellow arrow\" or \"red cross\" button\n   or by switching to a new transaction via \\\\n in the OK-code field.\n - Either the ABAP session or the C session runs into a severe problem (SYSTEM_FAILURE), upon which both sides get reset and the\n   connection between the two sides gets closed.\n - The network connection gets destroyed by network problems, system crash etc.\n\n An application that wants to work with stateful sessions, needs to react as follows to the various events:\n - RFC_SESSION_CREATED\\n\n   Do the necessary initialization of data or resources (like a database connection, etc.).\n - RFC_SESSION_PASSIVATED\\n\n   Most applications won't need this and can therefore ignore this event. One example, where this may be useful, is:\n   if the function calls going on in this session are few and far between, but they occupy a lot of memory, it might be a good idea\n   to flush the session state out to disc here, and load it back into memory, when the session gets activated again.\n - RFC_SESSION_ACTIVATED\\n\n   This is the counterpart to RFC_SESSION_PASSIVATED. In most cases it can safely be ignored. For an example where it might be\n   useful to use it, see above.\n - RFC_SESSION_DESTROYED\\n\n   Do the necessary cleanup of data and other resources that have been used while processing the function calls of this session.\n\n \\in serverHandle A handle to the server object.\n \\in sessionChangeListener Function pointer to a callback function receiving state change notifications.\n \\out *errorInfo Additional error information in case adding the state change listener fails, e.g. invalid handle.\n \\return RFC_RC"]
    pub fn RfcAddServerSessionChangedListener(
        serverHandle: RFC_SERVER_HANDLE,
        sessionChangeListener: RFC_SERVER_SESSION_CHANGE_LISTENER,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets this client's operation mode to statefull or stateless.\n \\ingroup autoserver\n\n When a client session operates in stateless mode, which is the default, it does not keep state information inbetween several\n RFC requests over the same connection. By setting it to stateful, you can change that so that all requests over one connection\n run inside one single \"user session\".\n\n \\note This can be used only for connection handles being managed by an automated (multi-count) server. If you try to use it\n on an ordinary connection created with RfcRegisterServer() or RfcStartServer(), you will get an RFC_ILLEGAL_STATE error.\n\n \\in connectionHandle A handle to the current client connection. Use the one that gets passed to you in your RFC_SERVER_FUNCTION implementation.\n \\in isStateful Specifies whether the server should operate in stateful mode (\"1\") or in stateless mode (\"0\").\n \\out *errorInfo Additional error information in case changing the state fails, e.g. invalid handle, server is not a multi-count server, etc.\n \\return RFC_RC"]
    pub fn RfcSetServerStateful(
        connectionHandle: RFC_CONNECTION_HANDLE,
        isStateful: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs an optional function for performing authentication checks on incoming login attempts.\n \\ingroup installer\n\n After an RFC connection is opened to the RFC library, and before the first RFC call is executed over\n this connection, the RFC library calls this callback function, if installed.\n Here you can implement a central authentication check, defining exactly which entity\n is allowed to execute the function in your RFC server program.\n The actual function module implementations can then concentrate on their business logic and don't\n need to pay attention to access and authentication checks.\n\n \\in onAuthenticationCheck Pointer to a function of type RFC_ON_AUTHENTICATION_CHECK. The RFC lib calls this function, whenever a new RFC connection to this server is first opened by the client.\n \\out *errorInfo Additional information, in case the handler could not be installed.\n \\return RFC_RC"]
    pub fn RfcInstallAuthenticationCheckHandler(
        onAuthenticationCheck: RFC_ON_AUTHENTICATION_CHECK,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the type of authentication data received from the backend in RFC_ON_AUTHENTICATION_CHECK.\n \\ingroup autoserver\n\n If a handler of type RFC_ON_AUTHENTICATION_CHECK is installed, this getter returns the type of authentication data that was received from\n the backend. The authentication method can be customized in the SM59 destination in the backend. The received authentication data is stored\n in the authentication handle, which can then by queried by the authentication handler RFC_ON_AUTHENTICATION_CHECK.\n\n \\in authenticationHandle A handle representing the authentication data passed into RFC_ON_AUTHENTICATION_CHECK.\n \\out *type The type of authentication method used by the backend.\n \\out *errorInfo Additional error information in case changing the state fails, e.g. invalid handle, null pointer, etc.\n \\return RFC_RC"]
    pub fn RfcGetAuthenticationType(
        authenticationHandle: RFC_AUTHENTICATION_HANDLE,
        type_: *mut RFC_AUTHENTICATION_TYPE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the user to authenticate in RFC_ON_AUTHENTICATION_CHECK if any is received.\n \\ingroup autoserver\n\n If a handler of type RFC_ON_AUTHENTICATION_CHECK is installed, this getter returns the user to authenticate set in the destination in the backend.\n This could also be the alias user.\n The received authentication data is stored in the authentication handle, which can then by queried by\n the authentication handler RFC_ON_AUTHENTICATION_CHECK.\n\n \\in authenticationHandle A handle representing the authentication data passed into RFC_ON_AUTHENTICATION_CHECK.\n \\out **user User to authenticate.\n \\out *length String length of user.\n \\out *errorInfo Additional error information in case changing the state fails, e.g. invalid handle, null pointer, etc.\n \\return RFC_RC"]
    pub fn RfcGetAuthenticationUser(
        authenticationHandle: RFC_AUTHENTICATION_HANDLE,
        user: *mut *const SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the password for authentication in RFC_ON_AUTHENTICATION_CHECK if basic authentication method was setup in the backend.\n \\ingroup autoserver\n\n If a handler of type RFC_ON_AUTHENTICATION_CHECK is installed, this getter returns the password for authentication set in the destination in the backend, i.e.\n basic authentication was setup.\n The received authentication data is stored in the authentication handle, which can then by queried by\n the authentication handler RFC_ON_AUTHENTICATION_CHECK.\n\n \\in authenticationHandle A handle representing the authentication data passed into RFC_ON_AUTHENTICATION_CHECK.\n \\out **password The user's password for basic authentication. NULL if otherwise.\n \\out *length String length of password.\n \\out *errorInfo Additional error information in case changing the state fails, e.g. invalid handle, null pointer, etc.\n \\return RFC_RC"]
    pub fn RfcGetAuthenticationPassword(
        authenticationHandle: RFC_AUTHENTICATION_HANDLE,
        password: *mut *const SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the assertionTicket for authentication in RFC_ON_AUTHENTICATION_CHECK if SSO based authentication method was setup in the backend.\n \\ingroup autoserver\n\n If a handler of type RFC_ON_AUTHENTICATION_CHECK is installed, this getter returns the assertionTicket for authentication set in the destination in the backend, i.e.\n SSO authentication was setup.\n The received authentication data is stored in the authentication handle, which can then by queried by\n the authentication handler RFC_ON_AUTHENTICATION_CHECK.\n\n \\in authenticationHandle A handle representing the authentication data passed into RFC_ON_AUTHENTICATION_CHECK.\n \\out **assertionTicket Assertion ticket for SSO authentication. NULL if otherwise.\n \\out *length String length of assertionTicket.\n \\out *errorInfo Additional error information in case changing the state fails, e.g. invalid handle, null pointer, etc.\n \\return RFC_RC"]
    pub fn RfcGetAuthenticationAssertionTicket(
        authenticationHandle: RFC_AUTHENTICATION_HANDLE,
        assertionTicket: *mut *const SAP_UC,
        length: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the certificate chain for authentication in RFC_ON_AUTHENTICATION_CHECK if x509 authentication method was setup in the backend.\n \\ingroup autoserver\n\n If a handler of type RFC_ON_AUTHENTICATION_CHECK is installed, this getter returns the certificate chain for authentication set in the destination in the backend, i.e.\n x509 authentication was setup. The certificate chain is stored as a singly linked list.\n The received authentication data is stored in the authentication handle, which can then by queried by\n the authentication handler RFC_ON_AUTHENTICATION_CHECK.\n\n \\in authenticationHandle A handle representing the authentication data passed into RFC_ON_AUTHENTICATION_CHECK.\n \\out **certificateData Singly linked list of certificate attributes for x509 authentication. NULL if otherwise.\n \\out *errorInfo Additional error information in case changing the state fails, e.g. invalid handle, null pointer, etc.\n \\return RFC_RC"]
    pub fn RfcGetAuthenticationCertificateData(
        authenticationHandle: RFC_AUTHENTICATION_HANDLE,
        certificateData: *mut *const RFC_CERTIFICATE_DATA,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Retrieves a unique 24-digit transaction ID from the backend.\n \\ingroup transaction\n If you specify NULL as connection handle, the API will attempt to generate a TID locally using the\n operating system's UUID algorithms. (Currently not possible on AIX systems.)\n\n \\in rfcHandle Client connection to a backend or NULL, if you want to create a TID locally.\n \\out tid Will be filled with the transaction ID.\n \\out *errorInfo Error information in case there is a problem with the connection.\n \\return RFC_RC"]
    pub fn RfcGetTransactionID(
        rfcHandle: RFC_CONNECTION_HANDLE,
        tid: *mut SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates a container for executing a (multi-step) transactional call.\n \\ingroup transaction\n\n If queueName is NULL, tRFC will be used, otherwise qRFC. Use RfcInvokeInTransaction() to\n add one (or more) function modules to the transactional call. When sending this transactional\n call to the backend via RfcSubmitTransaction(), the backend will then treat\n all function modules in the RFC_TRANSACTION_HANDLE as one LUW.\n\n \\in rfcHandle Client connection to the backend, into which you want to send this tRFC/qRFC LUW.\n \\in tid A unique 24 character ID.\n \\in *queueName For tRFC set this to NULL, for qRFC specify the name of a qRFC inbound queue in the backend.\n \\out *errorInfo Error information in case there is a problem with the connection.\n \\return A data container that can be filled with several function modules."]
    pub fn RfcCreateTransaction(
        rfcHandle: RFC_CONNECTION_HANDLE,
        tid: *mut SAP_UC,
        queueName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TRANSACTION_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a function module call to a transaction. Can be used multiple times on one tHandle.\n \\ingroup transaction\n\n \\in tHandle A transaction handle created via RfcCreateTransaction().\n \\in funcHandle An RFC_FUNCTION_HANDLE, whose IMPORTING, CHANGING and TABLES parameters have been filled.\n \\note that tRFC/qRFC calls have no return values, so the EXPORTING parameters of this function handle will\n not be filled, nor will the changes to the CHANGING/TABLES parameters be returned.\n \\out *errorInfo Actually there is nothing that can go wrong here except for invalid handles and out of memory.\n \\return RFC_RC"]
    pub fn RfcInvokeInTransaction(
        tHandle: RFC_TRANSACTION_HANDLE,
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Executes the entire LUW in the backend system as an \"atomic unit\".\n \\ingroup transaction\n\n This step can be repeated until it finally succeeds (RFC_OK). The transaction handling in the backend\n system protects against duplicates (until you remove the TID from the backend's status tables using\n RfcConfirmTransaction()).\n\n\n \\in tHandle A transaction handle filled with one or several function modules.\n \\out *errorInfo Additional error information in case anything goes wrong.\n \\return RFC_RC"]
    pub fn RfcSubmitTransaction(
        tHandle: RFC_TRANSACTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes the TID contained in the RFC_TRANSACTION_HANDLE from the backend's ARFCRSTATE table.\n \\ingroup transaction\n\n After RfcSubmitTransaction() has finally succeeded, call %RfcConfirmTransaction() to clean up the\n transaction handling table in the backend.\n \\warning Attention: after this call, the backend is no longer protected against this TID. So another\n RfcSubmitTransaction() with the same transaction handle would result in a duplicate.\n\n\n \\in tHandle A transaction handle that has successfully been submitted.\n \\out *errorInfo Additional error information in case of a network problem.\n \\warning You may retry the Confirm step, if you get an error here, but do not retry the Submit step!\n \\return RFC_RC"]
    pub fn RfcConfirmTransaction(
        tHandle: RFC_TRANSACTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Convenience function to remove the TID contained in a previous RFC_TRANSACTION_HANDLE from the backend's ARFCRSTATE table,\n without the need of still having the RFC_TRANSACTION_HANDLE at hand.\n \\ingroup transaction\n\n After RfcSubmitTransaction() has finally succeeded, call %RfcConfirmTransactionID() to clean up the\n transaction handling table in the backend. This function can be called after the RFC_TRANSACTION_HANDLE has\n already been deleted.\n \\warning Attention: after this call, the backend is no longer protected against this TID. So another\n RfcSubmitTransaction() with the same transaction handle would result in a duplicate.\n\n\n \\in rfcHandle A connection into the same system, into which the corresponding transaction has been sent via RfcSubmitTransaction().\n \\in tid A unique 24 character ID.\n \\out *errorInfo Additional error information in case of a network problem.\n \\warning You may retry the Confirm step, if you get an error here, but do not retry the Submit step!\n \\return RFC_RC"]
    pub fn RfcConfirmTransactionID(
        rfcHandle: RFC_CONNECTION_HANDLE,
        tid: *mut SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases the memory of the transaction container.\n \\ingroup transaction\n\n\n \\in tHandle A transaction handle that is no longer needed.\n \\out *errorInfo Not much that can go wrong here...\n \\return RFC_RC"]
    pub fn RfcDestroyTransaction(
        tHandle: RFC_TRANSACTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Create a 32 digit bgRFC unit ID.\n \\ingroup bgrfc\n\n This function fills the given RFC_UNITID with a 32 digit hexadecimal GUID and zero-terminates it.\n If you want the GUID to be generated by the backend, pass a valid rfcHandle, if you want the\n NW RFC library to generate one locally (using the appropriate OS functions), pass NULL as\n connection handle. In both cases the GUID is suitable for sending bgRFC units into an SAP system.\n\n\n \\in rfcHandle An open RFC connection into the system that is to create the unit ID, or NULL.\n \\out uid Preallocated buffer that will receive the 32 digits of the unit ID and a terminating zero.\n \\out *errorInfo Not much that can go wrong here...\n \\return RFC_RC"]
    pub fn RfcGetUnitID(
        rfcHandle: RFC_CONNECTION_HANDLE,
        uid: *mut SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Create a bgRFC unit.\n \\ingroup bgrfc\n\n Creates a data container that can later be filled with one or more function modules comprising the\n bgRFC unit. The backend will execute these function modules as an atomic unit.\n The connection handle specifies the target system, to which the unit will later be sent. The unit ID\n has been created in the previous step (or is an old one in case of retrying a failed unit).\n Via queueNames and queueNameCount you can specify the list of bgRFC queues, into which this unit\n shall later be inserted. If no queues are given (queueNameCount == 0), a synchronous unit is created\n (type 'T') that will later be executed immediately. Otherwise an asynchronous unit (type 'Q') is created,\n which will be inserted into the named queues and executed asynchronously by the bgRFC scheduler.\n\n\n \\in rfcHandle An open RFC connection into the system that will later receive the unit.\n \\in uid A 32 digit unique identifier of the unit.\n \\in *queueNames[] A list of bgRFC queues in the backend or NULL.\n \\in queueNameCount The length of the queueNames list.\n \\in *unitAttr A set of attributes that specify the behaviour of the unit in the backend.\n See RFC_UNIT_ATTRIBUTES for more information.\n \\out *identifier This identifier can be used in later calls to RfcConfirmUnit() and RfcGetUnitState().\n It is important that these functions are called with the correct unit type ('T' or 'Q'), otherwise\n the backend system won't find the status information corresponding to the uid... Therefore the\n NW RFC lib bundles the uid and the correct unit type here for your convenience.\n \\out *errorInfo More details in case something goes wrong.\n \\return RFC_OK or RFC_MEMORY_INSUFFICIENT"]
    pub fn RfcCreateUnit(
        rfcHandle: RFC_CONNECTION_HANDLE,
        uid: *mut SAP_UC,
        queueNames: *mut *const SAP_UC,
        queueNameCount: ::std::os::raw::c_uint,
        unitAttr: *const RFC_UNIT_ATTRIBUTES,
        identifier: *mut RFC_UNIT_IDENTIFIER,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_UNIT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a function module to a bgRFC unit.\n \\ingroup bgrfc\n\n Serializes the payload of the function module data container into bgRFC format and inserts\n it into the data container for the bgRFC unit. The funcHandle can afterwards be freed\n using RfcDestroyFunction(), because the data is copied, not referenced.\n\n \\note Despite the name \"invoke\", nothing is executed in the backend system, yet!\n\n\n \\in unitHandle A valid (unsubmitted) bgRFC unit, to which the given function module shall be added.\n \\in funcHandle A function module, whose payload (IMPORTING/CHANGING/TABLES) shall be added to the unit.\n \\out *errorInfo More details in case something goes wrong.\n \\return RFC_OK, RFC_INVALID_HANDLE or RFC_MEMORY_INSUFFICIENT"]
    pub fn RfcInvokeInUnit(
        unitHandle: RFC_UNIT_HANDLE,
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Executes a bgRFC unit in the backend.\n \\ingroup bgrfc\n\n Sends the bgRFC unit into the backend, where it will be executed synchronously or persisted\n in the given inbound queues and executed asynchronously by the bgRFC scheduler, depending on\n whether the unit type is 'T' or 'Q'.\n If the type is 'T', this function will wait until the unit is completely executed and then\n return the success or error information. If the type is 'Q', this function only inserts the\n unit into the specified queues and then returns. Processing of the unit in the backend system\n happens asynchronously. The return code of this function indicates, whether the unit could\n be persisted in the given queues successfully. In order to get information about the processing\n status of the unit, use RfcGetUnitState() at a later point.\n\n \\note Despite the name \"invoke\", nothing is executed in the backend system, yet!\n\n\n \\in unitHandle A valid (unsubmitted) bgRFC unit, which shall be sent into the backend system.\n \\out *errorInfo More details in case something goes wrong.\n \\return RFC_OK, RFC_INVALID_HANDLE, RFC_MEMORY_INSUFFICIENT, RFC_COMMUNICATION_FAILURE"]
    pub fn RfcSubmitUnit(unitHandle: RFC_UNIT_HANDLE, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes the UID from the backend's status management.\n \\ingroup bgrfc\n\n After RfcSubmitUnit() returned successfully, you should use this function to cleanup\n the status information for this unit on backend side. However, be careful: if you have\n a three-tier architecture, don't bundle Submit and Confirm into one single logical step.\n Otherwise you run the risk, that the middle tier (the NW RFC lib) successfully executes\n both, the Submit and the Confirm, but on the way back to the first tier an error occurs\n and the first tier can not be sure that the unit was really executed in the backend and\n therefore decides to re-execute it. This will now result in a duplicate execution in the\n backend, because the Confirm step in the first try has already deleted the UID in the\n backend, and consequently the backend is no longer protected against re-execution of this\n UID. In a three-tier architecture, the first tier should trigger both steps separately:\n first the Submit, and after it knows that the Submit was successful, the Confirm.\n Also in case the Confirm runs into an error, do NOT execute the Submit again, never!\n You may try the Confirm again at a later point, but otherwise just ignore the error.\n Better a left-over entry in the status information table than a duplicate unit...\n\n \\in rfcHandle A connection into the same system, into which the corresponding bgRFC unit\n has been sent via RfcSubmitUnit().\n \\in *identifier The correct combination of UID and type of the unit. Best use the output\n you get from RfcCreateUnit().\n \\out *errorInfo More details in case something goes wrong.\n \\return RFC_OK, RFC_INVALID_HANDLE, RFC_COMMUNICATION_FAILURE"]
    pub fn RfcConfirmUnit(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *mut RFC_UNIT_IDENTIFIER,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases the memory of the bgRFC unit container.\n \\ingroup bgrfc\n\n\n \\in unitHandle A unit handle that is no longer needed.\n \\out *errorInfo Not much that can go wrong here...\n \\return RFC_RC"]
    pub fn RfcDestroyUnit(unitHandle: RFC_UNIT_HANDLE, errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Retrieves the processing status of the given background unit from the backend system's status management.\n \\ingroup bgrfc\n\n\n \\in rfcHandle A connection into the same system, into which the corresponding bgRFC unit\n has been sent via RfcSubmitUnit().\n \\in *identifier The correct combination of UID and type of the unit. Best use the output\n you get from RfcCreateUnit().\n \\out *state The state of the unit. See RFC_UNIT_STATE for more details.\n \\out *errorInfo Not much that can go wrong here...\n \\return RFC_RC"]
    pub fn RfcGetUnitState(
        rfcHandle: RFC_CONNECTION_HANDLE,
        identifier: *mut RFC_UNIT_IDENTIFIER,
        state: *mut RFC_UNIT_STATE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs a callback function of type RFC_SERVER_FUNCTION, which will be triggered when a request for\n the function module corresponding to funcDescHandle comes in from the R/3 system corresponding to sysId.\n \\ingroup installer\n\n If you pass NULL as \"sysId\", the serverFunction will be used for calls from any backend system.\n\n The main inputs of RFC_SERVER_FUNCTION are as follows:\n - RFC_CONNECTION_HANDLE\\n\t\tA connection handle, which can be used to query logon information about\n\t\t\t\t\t\tthe current (backend) user or to make callbacks into the backend.\n - RFC_FUNCTION_HANDLE\\n\t\t\tA data container that represents the current function call. Read the importing\n\t\t\t\t\t\tparameters, which came from the backend, from this container via the RfcGetX functions and\n\t\t\t\t\t\twrite the exporting parameters, which are to be returned to the backend, into this container\n\t\t\t\t\t\tusing the RfcSetX functions.\\n\n\t\t\t\t\t\tThe memory of that container is automatically released by the RFC Runtime after the\n\t\t\t\t\t\tRFC_SERVER_FUNCTION returns.\n - RFC_ERROR_INFO*\\n\t\t\tIf you want to return an ABAP Exception or ABAP Message to the backend, fill the\n\t\t\t\t\t\tparameters of that container and return RFC_ABAP_EXCEPTION or RFC_ABAP_MESSAGE from\n\t\t\t\t\t\tyour RFC_SERVER_FUNCTION implementation.\\n\n\t\t\t\t\t\tIf you want to return a SYSTEM_FAILURE to the backend, fill the message parameter of\n\t\t\t\t\t\tthis container and return RFC_EXTERNAL_FAILURE from your RFC_SERVER_FUNCTION implementation.\n If your RFC_SERVER_FUNCTION implementation processed the function call successfully, you should return RFC_OK.\n\n\n \\in *sysId System ID of the R/3 system, for which this function module implementation shall be used.\n If you set this to NULL, this server function will be used for calls from all backends, for whose SysID no\n explicit server function has been installed.\n \\in funcDescHandle A function description giving the name of the function module and its parameters.\\n\n Note that the NW RFC library does not create a copy of this function description. So if you are using\n self-defined (hard-coded) function descriptions (see RfcCreateFunctionDesc()), then you need to make\n sure, that these function descriptions are not destroyed as long as they are still used in a server\n function installation!\n \\in serverFunction Pointer to a C function of type RFC_SERVER_FUNCTION. If you pass a null-pointer here,\n any previously installed server function for the given function module will be uninstalled.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcInstallServerFunction(
        sysId: *const SAP_UC,
        funcDescHandle: RFC_FUNCTION_DESC_HANDLE,
        serverFunction: RFC_SERVER_FUNCTION,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs a generic callback function of type RFC_SERVER_FUNCTION together with a callback\n function of type RFC_FUNC_DESC_CALLBACK for obtaining the metadata description of unknown function modules.\n \\ingroup installer\n\n The RFC Runtime calls the callback function RFC_SERVER_FUNCTION, if it receives a function call, for whose\n function module name no matching callback function has been installed via RfcInstallServerFunction()\n (neither for the current system ID nor for SysID=NULL).\n\n In addition to the handler function you need to provide a second callback function: RFC_FUNC_DESC_CALLBACK.\n The RFC runtime calls it to obtain an RFC_FUNCTION_DESC_HANDLE for the current function module from you.\n So this function either needs to return hardcoded meta data or needs to be able to perform a DDIC lookup\n using a valid client connection and RfcGetFunctionDesc(). If your implementation of RFC_FUNC_DESC_CALLBACK\n is not able to provide a function description for the current function module name, it should return RFC_NOT_FOUND.\n The RFC runtime will then notify the backend, that this function module cannot be processed by your\n RFC server.\n\n\n \\in serverFunction A pointer to a function that can handle \"all\" function modules.\n \\in funcDescProvider A pointer to a function that can provide metadata descriptions of \"all\" function modules.\n \\out *errorInfo Again not much that can go wrong at this point.\n \\return"]
    pub fn RfcInstallGenericServerFunction(
        serverFunction: RFC_SERVER_FUNCTION,
        funcDescProvider: RFC_FUNC_DESC_CALLBACK,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs the necessary callback functions for processing incoming tRFC/qRFC calls.\n \\ingroup installer\n\n These functions need to be implemented by you and will be used by the RFC runtime in the following way:\n -# The RFC_ON_CHECK_TRANSACTION function is called when a local transaction is starting. Since a transactional\n    RFC call can be issued many times by the client system, the function is responsible for storing the transaction ID\n    in permanent storage. The return value should be one of the following:\n    - RFC_OK\\n\t\tTransaction ID stored, transaction can be started.\n    - RFC_EXECUTED\\n\tThis transaction has already been processed successfully in an earlier attempt. Skip the execution now.\n    - RFC_EXTERNAL_FAILURE\\n Currently unable to access my permanent storage. Raise an exception in the sending system, so\n\t\t\t\t\t\tthat the sending system will try to resend the transaction at a later time.\n -# The next step will be the execution of the RFC_SERVER_FUNCTIONs for all function modules contained in the LUW.\n -# If one of the RFC_SERVER_FUNCTION implementations returns an error code, RFC_ON_ROLLBACK_TRANSACTION is called.\n    Here you should roll back all the work of all the previous RFC_SERVER_FUNCTIONs. (The easiest way is to do\n    a database ROLLBACK WORK here.)\\n\n    If all RFC_SERVER_FUNCTIONs complete successfully, RFC_ON_COMMIT_TRANSACTION is called at the end.\n    Persist all the changes here (e.g. do a COMMIT WORK).\\n\n    Note: Normally you'll only have \"one-function-module LUWs\", e.g. IDocs. In this case the RFC_SERVER_FUNCTION\n    can already commit/rollback its own work, before returning RFC_OK or an error code. So the two functions\n    RFC_ON_ROLLBACK_TRANSACTION and RFC_ON_COMMIT_TRANSACTION can be empty in this case.\n -# In the end RFC_ON_CONFIRM_TRANSACTION will be called. All information stored about that transaction can now be\n    discarded by the server, as it no longer needs to protect itself against duplicates.\n    In general this function can be used to delete the transaction ID from permanent storage.\n\n If you pass NULL as \"sysId\", the transaction handlers will be used for tRFC calls from any backend system,\n for which no explicit handlers have been installed.\n\n\n \\in *sysId System ID of the SAP system for which to use this set of transaction handlers, or NULL.\n \\in onCheckFunction Pointer to a function of type RFC_ON_CHECK_TRANSACTION.\n \\in onCommitFunction Pointer to a function of type RFC_ON_COMMIT_TRANSACTION.\n \\in onRollbackFunction Pointer to a function of type RFC_ON_ROLLBACK_TRANSACTION.\n \\in onConfirmFunction Pointer to a function of type RFC_ON_CONFIRM_TRANSACTION.\n \\out *errorInfo Additional information, in case the handlers could not be installed.\n \\return RFC_RC"]
    pub fn RfcInstallTransactionHandlers(
        sysId: *const SAP_UC,
        onCheckFunction: RFC_ON_CHECK_TRANSACTION,
        onCommitFunction: RFC_ON_COMMIT_TRANSACTION,
        onRollbackFunction: RFC_ON_ROLLBACK_TRANSACTION,
        onConfirmFunction: RFC_ON_CONFIRM_TRANSACTION,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs the necessary callback functions for processing incoming bgRFC calls.\n \\ingroup installer\n\n These functions need to be implemented by you and will be used by the RFC runtime in the following way:\n -# The RFC_ON_CHECK_UNIT function is called when a local background unit is starting. Since a background\n    RFC call can be issued many times by the client system, the function is responsible for storing the unit ID\n    and type in permanent storage. The return value should be one of the following:\n    - RFC_OK\\n\t\tUnit ID stored, LUW can be started.\n    - RFC_EXECUTED\\n\tThis LUW has already been processed successfully in an earlier attempt. Skip the execution now.\n    - RFC_EXTERNAL_FAILURE\\n Currently unable to access my permanent storage. Raise an exception in the sending system, so\n\t\t\t\t\t\tthat the sending system will try to resend the unit at a later time.\n -# The next step will be the execution of the RFC_SERVER_FUNCTIONs for all function modules contained in the LUW.\n -# If one of the RFC_SERVER_FUNCTION implementations returns an error code, RFC_ON_ROLLBACK_UNIT is called.\n    Here you should roll back all the work of all the previous RFC_SERVER_FUNCTIONs. (The easiest way is to do\n    a database ROLLBACK WORK here.)\\n\n    If all RFC_SERVER_FUNCTIONs complete successfully, RFC_ON_COMMIT_UNIT is called at the end.\n    Persist all the changes here (e.g. do a COMMIT WORK).\\n\n    Note: Normally you'll only have \"one-function-module LUWs\", e.g. IDocs. In this case the RFC_SERVER_FUNCTION\n    can already commit/rollback its own work, before returning RFC_OK or an error code. So the two functions\n    RFC_ON_ROLLBACK_UNIT and RFC_ON_COMMIT_UNIT can be empty in this case.\n -# In the end RFC_ON_CONFIRM_UNIT will be called. All information stored about that LUW can now be\n    discarded by the server, as it no longer needs to protect itself against duplicates.\n    In general this function can be used to delete the unit ID from permanent storage.\n -# At various points in the processing of a background unit, the backend system may or may not inquire\n    the status of the currently (or previously) processed unit by calling RFC_ON_GET_UNIT_STATE. Your implementation\n    of this function should check your permanent storage for status information about the given unit ID and\n    fill the RFC_UNIT_STATE* accordingly.\n\n If you pass NULL as \"sysId\", the transaction handlers will be used for bgRFC calls from any backend system,\n for which no explicit handlers have been installed.\n\n\n \\in *sysId System ID of the SAP system for which to use this set of transaction handlers, or NULL.\n \\in onCheckFunction Pointer to a function of type RFC_ON_CHECK_UNIT.\n \\in onCommitFunction Pointer to a function of type RFC_ON_COMMIT_UNIT.\n \\in onRollbackFunction Pointer to a function of type RFC_ON_ROLLBACK_UNIT.\n \\in onConfirmFunction Pointer to a function of type RFC_ON_CONFIRM_UNIT.\n \\in onGetStateFunction Pointer to a function of type RFC_ON_GET_UNIT_STATE.\n \\out *errorInfo Additional information, in case the handlers could not be installed.\n \\return RFC_RC"]
    pub fn RfcInstallBgRfcHandlers(
        sysId: *const SAP_UC,
        onCheckFunction: RFC_ON_CHECK_UNIT,
        onCommitFunction: RFC_ON_COMMIT_UNIT,
        onRollbackFunction: RFC_ON_ROLLBACK_UNIT,
        onConfirmFunction: RFC_ON_CONFIRM_UNIT,
        onGetStateFunction: RFC_ON_GET_UNIT_STATE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs the necessary callback functions for processing Extended Passport (EPP) events.\n \\ingroup installer\n\n Extended Passports is a feature that supersedes Distributed Statistical Records (DSRs).\n It allows to track certain performance attributes across system boundaries. These callback functions\n allow the application to exchange passports with the backend system. The actual data contained in the\n passports, can be processed with the eppslib library.\n \\note Normal RFC applications should never need to deal with this topic at all...\n\n\n \\in onClientCallStart Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, before it sends a client request into the backend. Here you can provide the passport that is to be sent along with the RFC request.\n \\in onClientCallEnd Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, after the RFC response was received from the backend. You can read the updated passport information.\n \\in onServerCallStart Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, when it received an RFC request from the backend. Here you can read the passport that accompanied the request.\n \\in onServerCallEnd Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, before it will send the response to the above request back to the backend. You can update the passport data with information about processing performance of the current call.\n \\out *errorInfo Additional information, in case the handlers could not be installed.\n \\return RFC_RC"]
    pub fn RfcInstallPassportManager(
        onClientCallStart: RFC_PM_CALLBACK,
        onClientCallEnd: RFC_PM_CALLBACK,
        onServerCallStart: RFC_PM_CALLBACK,
        onServerCallEnd: RFC_PM_CALLBACK,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs an optional callback function for processing password change events.\n \\ingroup installer\n\n Whenever a logon attempt is made with a user, whose password is still initial, the backend system\n challenges this user to change his/her password. If this happens during a call to RfcOpenConnection(),\n the RFC library calls this callback function (if installed), and allows you to change the user's password.\n In your implementation, you can either return RFC_EXTERNAL_FAILURE, if you can't/don't want to change\n the password. In that case RfcOpenConnection() will end with RFC_LOGON_FAILURE and any additional text from\n errorInfo->message will be returned to the application. Or you can fill the old and new password with correct\n values and return RFC_OK, upon which the RFC library will attempt to change the password accordingly.\n \\note See also the documentation of the logon parameter PASSWORD_CHANGE_ENFORCED in the sample sapnwrfc.ini file,\n which specifies, whether the application is allowed to get by without a PasswordChangeHandler and keep using\n the initial/expired password for login.\n\n\n \\in onPasswordChange Pointer to a function of type RFC_ON_PASSWORD_CHANGE. The RFC lib calls this function, whenever an initial password is detected during a call to RfcOpenConnection().\n \\out *errorInfo Additional information, in case the handler could not be installed.\n \\return RFC_RC"]
    pub fn RfcInstallPasswordChangeHandler(
        onPasswordChange: RFC_ON_PASSWORD_CHANGE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Installs an optional callback function for performing authorization checks on incoming function calls.\n \\ingroup installer\n\n After an RFC call arrives at the RFC library, and before the library executes the corresponding\n server implementation for that function module, it calls this callback function, if installed.\n Here you can implement a central authorization check, defining exactly which user from which backend\n system is allowed to execute what functions in your RFC server program.\n The actual function module implementations can then concentrate on their business logic and don't\n need to pay attention to access and authorization checks.\n\n\n \\in onAuthorizationCheck Pointer to a function of type RFC_ON_AUTHORIZATION_CHECK. The RFC lib calls this function, whenever an RFC request arrives from the backend.\n \\out *errorInfo Additional information, in case the handler could not be installed.\n \\return RFC_RC"]
    pub fn RfcInstallAuthorizationCheckHandler(
        onAuthorizationCheck: RFC_ON_AUTHORIZATION_CHECK,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates a data container that can be used to execute function calls in the backend via RfcInvoke().\n \\ingroup container\n\n The importing parameters can be set using the RfcSetX functions. After the RfcInvoke() call returned\n successfully, the exporting parameters can be read from this data container via the RfcGetX functions.\n\n\n \\in funcDescHandle Metadata description (\"blueprint\") for the data container to be created.\n \\out *errorInfo Error information in case the parameters are incorrect or there's not enough memory.\n \\return A handle to the function module container."]
    pub fn RfcCreateFunction(
        funcDescHandle: RFC_FUNCTION_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_FUNCTION_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases all memory used by the data container.\n \\ingroup container\n\n \\warning Be careful: if you have obtained a handle to a structure (RFC_STRUCTURE_HANDLE) or\n table parameter (RFC_TABLE_HANDLE) from that function module, that handle will be invalid afterwards,\n as that memory will be released as well!\n\n\n \\in funcHandle Data container to release.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcDestroyFunction(
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Allows to deactivate certain parameters in the function module interface.\n \\ingroup container\n\n This is particularly useful for BAPIs which have many large tables, in which you are not interested.\n Deactivate those and leave only those tables active, in which you are interested. This reduces\n network traffic and memory consumption in your application considerably.\n\n \\note This functionality can be used for input and output parameters. If the parameter is an input,\n no data for that parameter will be sent to the backend. If it's an output, the backend will be\n informed not to return data for that parameter.\n\n \\in funcHandle A function module data container.\n \\in *paramName The name of a parameter of this function module.\n \\in isActive 1 = activate, 0 = deactivate.\n \\out *errorInfo Error information in case something goes wrong (e.g. a parameter of that name does not exist).\n \\return RFC_RC"]
    pub fn RfcSetParameterActive(
        funcHandle: RFC_FUNCTION_HANDLE,
        paramName: *const SAP_UC,
        isActive: ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Query whether a parameter is active.\n \\ingroup container\n\n Useful for example in a server function implementation: Before creating a large table,\n you may want to check, whether the client (the backend system), has requested that table at all.\n\n \\in funcHandle A function module data container (usually handed to your server function from the RFC library).\n \\in *paramName The name of a parameter of this function module.\n \\out *isActive 1 = is active, 0 = is not active.\n \\out *errorInfo Error information in case something goes wrong (e.g. a parameter of that name does not exist).\n \\return RFC_RC"]
    pub fn RfcIsParameterActive(
        funcHandle: RFC_FUNCTION_HANDLE,
        paramName: *const SAP_UC,
        isActive: *mut ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates a data container for a structure.\n \\ingroup container\n\n\n \\in typeDescHandle The metadata description (blueprint) for the structure to be created.\n \\out *errorInfo Error information in case the parameters are incorrect or there's not enough memory.\n \\return A handle to the structure."]
    pub fn RfcCreateStructure(
        typeDescHandle: RFC_TYPE_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_STRUCTURE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Clones a sructure including the data in it.\n \\ingroup container\n\n\n \\in srcStructureHandle The structure to clone.\n \\out *errorInfo Not enough memory?\n \\return A handle to the newly created copy of the input structure."]
    pub fn RfcCloneStructure(
        srcStructureHandle: RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_STRUCTURE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases all memory for a particular structure\n \\ingroup container\n\n \\warning Do not call this function on structures, which you have obtained from another data container\n (e.g. a function module) via RfcGetStructure(). In that case the memory will be released, when the\n parent container will be destroyed. If you destroy a child structure separately, you will get a\n segmentation fault, when the parent structure is destroyed!\n\n \\in structHandle Structure to release.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcDestroyStructure(
        structHandle: RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates a data container for a table.\n \\ingroup container\n\n\n \\in typeDescHandle The metadata description (blueprint) for the line type of the table to be created.\n \\out *errorInfo More details in case there was an invalid parameter or not enough memory.\n \\return The freshly created table."]
    pub fn RfcCreateTable(
        typeDescHandle: RFC_TYPE_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TABLE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Clones a table including all the data in it. (Use with care...)\n \\ingroup container\n\n\n \\in srcTableHandle The table to duplicate.\n \\out *errorInfo In case there is not enough memory.\n \\return A handle to the cloned table."]
    pub fn RfcCloneTable(
        srcTableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TABLE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases the memory of a table and all its lines.\n \\ingroup container\n\n \\warning Be careful: if you still have a reference to a certain table line (an RFC_STRUCTURE_HANDLE you got\n from RfcGetCurrentRow() / RfcAppendNewRow() / RfcInsertNewRow()), this handle will be invalid after %RfcDestroyTable()!\n Using a handle to a table line after the table has been destroyed, will lead to a segmentation fault.\n\n \\in tableHandle The table to release.\n \\out *errorInfo Nothing can go wrong here...\n \\return RFC_RC"]
    pub fn RfcDestroyTable(tableHandle: RFC_TABLE_HANDLE, errorInfo: *mut RFC_ERROR_INFO)
    -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the table row, on which the \"table cursor\" is currently positioned.\n \\ingroup container\n\n \\note that the rows are numbered from 0 to n-1, not from 1 to n, as it's done in ABAP.\n\n \\in tableHandle The table to read data from.\n \\out *errorInfo If the table cursor is not on a valid position.\n \\return A handle to the current row.\n \\warning Do not destroy the returned RFC_STRUCTURE_HANDLE."]
    pub fn RfcGetCurrentRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_STRUCTURE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Appends a new empty row at the end of the table and moves the table cursor to that row.\n \\ingroup container\n\n\n \\in tableHandle The table to enlarge.\n \\out *errorInfo More information in case of errors (e.g. not enough memory).\n \\return A handle to the newly created row."]
    pub fn RfcAppendNewRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_STRUCTURE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Reserves memory without changing the size of a table so that new rows can be appended without new memory allocation.\n \\ingroup container\n\n\n \\in tableHandle The table to enlarge.\n \\in numRows Number of rows to reserve.\n \\out *errorInfo More information in case of errors (e.g. not enough memory).\n \\return RFC_OK, RFC_INVALID_HANDLE or RFC_MEMORY_INSUFFICIENT."]
    pub fn RfcReserveCapacity(
        tableHandle: RFC_TABLE_HANDLE,
        numRows: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Appends a set of new empty rows at the end of the table and moves the table cursor to the first new row.\n \\ingroup container\n\n\n \\in tableHandle The table to enlarge.\n \\in numRows Number of rows to add.\n \\out *errorInfo More information in case of errors (e.g. not enough memory).\n \\return RFC_OK, RFC_INVALID_HANDLE or RFC_MEMORY_INSUFFICIENT."]
    pub fn RfcAppendNewRows(
        tableHandle: RFC_TABLE_HANDLE,
        numRows: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Inserts a new empty row at the current position of the table cursor.\n \\ingroup container\n\n The row, on which the table cursor is currently positioned, and all following rows are moved\n one index \"down\". E.g. if the table currently has rows nos 0 - n-1 and the cursor points to row i,\n then the rows i - n-1 are moved to positions i+1 - n, and the new row is inserted at position i.\n\n\n \\in tableHandle The table to enlarge.\n \\out *errorInfo More information in case of errors (e.g. not enough memory).\n \\return A handle to the newly created row."]
    pub fn RfcInsertNewRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_STRUCTURE_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Appends an existing row to the end of the table and moves the table cursor to that row.\n \\ingroup container\n\n\n \\in tableHandle The table to enlarge.\n \\in structHandle The row to append to the table.\n \\out *errorInfo More information in case something goes wrong (e.g. the line types of the table and the structure don't match).\n \\return RFC_RC"]
    pub fn RfcAppendRow(
        tableHandle: RFC_TABLE_HANDLE,
        structHandle: RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Inserts an existing row at the current position of the table cursor.\n \\ingroup container\n\n The row, on which the table cursor is currently positioned, and all following rows are moved\n one index \"down\". E.g. if the table currently has rows nos 0 - n-1 and the cursor points to row i,\n then the rows i - n-1 are moved to positions i+1 - n, and the given row is inserted at position i.\n\n\n \\in tableHandle The table to enlarge.\n \\in structHandle The row to insert into the table.\n \\out *errorInfo More information in case something goes wrong (e.g. the line types of the table and the structure don't match).\n \\return RFC_RC"]
    pub fn RfcInsertRow(
        tableHandle: RFC_TABLE_HANDLE,
        structHandle: RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Deletes the row, on which the table cursor is currently positioned.\n \\ingroup container\n\n If the row cursor is currently at an index i between 0 - n-2, then row i will be deleted and the\n rows i+1 - n-1 will be moved on index \"up\", e.g. will now be rows i - n-2. The table cursor will\n remain fixed at index i.\\n\n If the cursor is currently on the last row (n-1), then that row will be deleted, all other position\n will remain unchanged, and the table cursor will move up to n-2 (the new last row of the table).\n\n\n \\in tableHandle The table from which to delete a row.\n \\out *errorInfo Error information in case the table cursor is not on a valid position.\n \\return RFC_RC"]
    pub fn RfcDeleteCurrentRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Deletes all rows from the table.\n \\ingroup container\n\n\n \\in tableHandle The table to clear.\n \\out *errorInfo Not much that can go wrong here (except an invalid table handle).\n \\return RFC_RC"]
    pub fn RfcDeleteAllRows(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Positions the table cursor at the first row (or at index \"-1\", if the table is empty).\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\out *errorInfo Not much that can go wrong here (except an invalid table handle).\n \\return RFC_RC"]
    pub fn RfcMoveToFirstRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Positions the table cursor at the last row (or at index \"-1\", if the table is empty).\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\out *errorInfo Not much that can go wrong here (except an invalid table handle).\n \\return RFC_RC"]
    pub fn RfcMoveToLastRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Increments the table cursor by one.\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\out *errorInfo Not much that can go wrong here (except an invalid table handle).\n \\return RFC_RC"]
    pub fn RfcMoveToNextRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Decrements the table cursor by one.\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\out *errorInfo Not much that can go wrong here (except an invalid table handle).\n \\return RFC_RC"]
    pub fn RfcMoveToPreviousRow(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the table cursor to a specific index.\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\in index The index to which to move the cursor.\n \\out *errorInfo Index out of bounds or invalid table handle.\n \\return RFC_RC"]
    pub fn RfcMoveTo(
        tableHandle: RFC_TABLE_HANDLE,
        index: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of rows in a table.\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\out *rowCount The number of rows in the table.\n \\out *errorInfo Not much that can go wrong.\n \\return RFC_RC"]
    pub fn RfcGetRowCount(
        tableHandle: RFC_TABLE_HANDLE,
        rowCount: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a type description handle describing the line type (metadata) of this table.\n \\ingroup container\n\n\n \\in tableHandle A table.\n \\out *errorInfo Not much that can go wrong.\n \\return A type description handle that provides information about this table's fields (for each field: fieldname, the field's datatype, length, offset, etc.)"]
    pub fn RfcGetRowType(
        tableHandle: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TYPE_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates an ABAP object handle with the given class description handle.\n \\ingroup container\n\n \\in classDescHandle   class description handle.\n \\out *errorInfo  Contains more information, for example if memory runs out (code = RFC_MEMORY_INSUFFICIENT).\n \\return A handle to the created ABAP object."]
    pub fn RfcCreateAbapObject(
        classDescHandle: RFC_CLASS_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_ABAP_OBJECT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Destroys an ABAP object handle.\n \\ingroup container\n\n \\in objHandle    ABAP object handle to be destroyed.\n \\out *errorInfo  Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcDestroyAbapObject(
        objHandle: RFC_ABAP_OBJECT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as char array.\n \\ingroup container\n\n The charBuffer will be filled with a string representation of the given field. The remaining\n places in the buffer will be filled with trailing spaces. In case the buffer is too small,\n the function will return RFC_BUFFER_TOO_SMALL. The result will not be null-terminated.\n\n The field specified by name needs to be of one of the following data types. If the field\n has one of the listed non-char-like data types, the RFC library will convert the field value\n to string format. Example:\\n\n If \"name\" specifies a field of type INT4 with the value 4711 and charBuffer is an SAP_CHAR[10],\n then the buffer will be filled as follows: \"4711      \".\n\n \\note If the target field has type BYTE or XSTRING, the bytes will be\n converted to a hex encoded string representation.\n\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_UTCLONG\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field.\n \\out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in RFC_CHARs.\n \\out *errorInfo Field doesn't exist, cannot be converted to char, etc.\n \\return RFC_RC"]
    pub fn RfcGetChars(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        charBuffer: *mut RFC_CHAR,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as char array.\n \\ingroup container\n\n This function works exactly like RfcGetChars(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field.\n \\out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in RFC_CHARs.\n \\out *errorInfo Field doesn't exist, cannot be converted to char, etc.\n \\return RFC_RC"]
    pub fn RfcGetCharsByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        charBuffer: *mut RFC_CHAR,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as num-char array (digits only).\n \\ingroup container\n\n The charBuffer will be filled with a string representation of the field (from right to left).\n The remaining places in the buffer will be filled with leading zero digits. In case\n the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL. The result is not\n null-terminated.\n\n The field specified by name needs to be of one of the following data types. If the field\n has one of the listed non-char-like data types, the RFC library will convert the field value\n to string format. Example:\\n\n If \"name\" specifies a field of type INT4 with the value 4711 and charBuffer is an SAP_CHAR[10],\n then the buffer will be filled as follows: \"0000004711\".\n\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field.\n \\out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in RFC_CHARs.\n \\out *errorInfo Field doesn't exist, cannot be converted to numc, etc.\n \\return RFC_RC"]
    pub fn RfcGetNum(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        charBuffer: *mut RFC_NUM,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as num-char array (digits only).\n \\ingroup container\n\n This function works exactly like RfcGetNum(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field.\n \\out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in RFC_CHARs.\n \\out *errorInfo Field doesn't exist, cannot be converted to numc, etc.\n \\return RFC_RC"]
    pub fn RfcGetNumByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        charBuffer: *mut RFC_NUM,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads a DATE field.\n \\ingroup container\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read. The field must be of type RFCTYPE_DATE.\n \\out emptyDate An RFC_DATE object, which will receive the field value.\n \\out *errorInfo More information in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcGetDate(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        emptyDate: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads a DATE field.\n \\ingroup container\n\n This function works exactly like RfcGetDate(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read. The field must be of type RFCTYPE_DATE.\n \\out emptyDate An RFC_DATE object, which will receive the field value.\n \\out *errorInfo More information in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcGetDateByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        emptyDate: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads a TIME field.\n \\ingroup container\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read. The field must be of type RFCTYPE_TIME.\n \\out emptyTime An RFC_TIME object, which will receive the field value.\n \\out *errorInfo More information in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcGetTime(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        emptyTime: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads a TIME field.\n \\ingroup container\n\n This function works exactly like RfcGetTime(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read. The field must be of type RFCTYPE_TIME.\n \\out emptyTime An RFC_TIME object, which will receive the field value.\n \\out *errorInfo More information in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcGetTimeByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        emptyTime: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as null-terminated string.\n \\ingroup container\n\n The charBuffer will be filled with a null-terminated string representation of the field value.\n In case the buffer is too small, e.g. no place for string termination, the function will\n return RFC_BUFFER_TOO_SMALL. stringLength contains the number of written characters, or the\n required number of characters in case RFC_BUFFER_TOO_SMALL was thrown.\n The result will be null-terminated.\n\n The field specified by name needs to be of one of the following data types. If the field\n has one of the listed non-char-like data types, the RFC library will convert the field value\n to string format. Example:\\n\n If \"name\" specifies a field of type INT4 with the value 4711 and stringBuffer is an SAP_UC[10],\n then the buffer will be filled as follows: \"4711\\0xxxxx\". (x: left unchanged.)\n\n \\note If the target field has type BYTE or XSTRING, the bytes will be\n converted to a hex encoded string representation.\n\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_UTCLONG\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *stringBuffer Pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in SAP_UC.\n \\out *stringLength Always returns the string's length, no matter whether the stringBuffer had\n been large enough or not. (Note that if you want to try again after an RFC_BUFFER_TOO_SMALL,\n you need to make the stringBuffer at least *stringLength + 1 in order to account for the terminating null.)\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetString(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        stringBuffer: *mut SAP_UC,
        bufferLength: ::std::os::raw::c_uint,
        stringLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as null-terminated string.\n \\ingroup container\n\n This function works exactly like RfcGetString(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *stringBuffer Pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in SAP_UC.\n \\out *stringLength Always returns the string's length, no matter whether the stringBuffer had\n been large enough or not. (Note that if you want to try again after an RFC_BUFFER_TOO_SMALL,\n you need to make the stringBuffer at least *stringLength + 1 in order to account for the termnating null.)\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetStringByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        stringBuffer: *mut SAP_UC,
        bufferLength: ::std::os::raw::c_uint,
        stringLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as byte array.\n \\ingroup container\n\n Should mainly be used with fields of type RAW (RFCTYPE_BYTE), but also works with\n a number of other data types. In case of numerical data types it simply gives the\n binary representation of the value, in case of character data types it gives the\n UTF-16 representation (little endian/big endian, depending on the host platform).\n In case the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL.\n In case the buffer is longer than the field, it will be filled with 0x00 values.\n Example: The field is of type INT4 and contains the value 4711, byteBuffer is an SAP_RAW[10].\n Then the buffer will be filled as follows: 67 12 00 00 00 00 00 00 00 00 (little endian system)\n or 00 00 12 67 00 00 00 00 00 00 (big endian system).\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_CHAR\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in bytes.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetBytes(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        byteBuffer: *mut SAP_RAW,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as byte array.\n \\ingroup container\n\n This function works exactly like RfcGetBytes(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in bytes.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetBytesByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        byteBuffer: *mut SAP_RAW,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as byte array.\n \\ingroup container\n\n In case the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL.\n xstringLength contains the number of written bytes, or the required number of bytes\n in case of RFC_BUFFER_TOO_SMALL.\n The remaining buffer won't be changed.\n\n Example: The field is of type INT4 and contains the value 4711, byteBuffer is an SAP_RAW[10].\n Then the buffer will be filled as follows: 67 12 00 00 x x x x x x (little endian system)\n or 00 00 12 67 x x x x x x (big endian system). (x: unchanged) In both cases *xstringLength\n will be 4.\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_CHAR\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in bytes.\n \\out *xstringLength Byte length of the result (in both cases, no matter whether the byteBuffer had\n been large enough or not).\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetXString(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        byteBuffer: *mut SAP_RAW,
        bufferLength: ::std::os::raw::c_uint,
        xstringLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as byte array.\n \\ingroup container\n\n This function works exactly like RfcGetXString(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.\n \\in bufferLength Size of the buffer in bytes.\n \\out *xstringLength Byte length of the result (in both cases, no matter whether the byteBuffer had\n been large enough or not).\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetXStringByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        byteBuffer: *mut SAP_RAW,
        bufferLength: ::std::os::raw::c_uint,
        xstringLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as RFC_INT (signed).\n \\ingroup container\n\n If the field is a character type, an \"atoi-like\" conversion is performed. If the field is of type\n RFCTYPE_BYTE/RFCTYPE_XSTRING, this function interprets the bytes in big-endian byte order when\n converting them to int. Note that in this case the byte length of the field value must not exceed 4!\n\n The field specified by name needs to be of one of the following data types:\n <ul>\n <li>RFCTYPE_INT8\n <li>RFCTYPE_INT\n <li>RFCTYPE_INT2\n <li>RFCTYPE_INT1\n <li>RFCTYPE_BYTE     is interpreted as big endian sequence of an int\n <li>RFCTYPE_XSTRING  is interpreted as big endian sequence of an int\n <li>RFCTYPE_FLOAT\n <li>RFCTYPE_CHAR\n <li>RFCTYPE_NUM\n <li>RFCTYPE_STRING\n <li>RFCTYPE_BCD\n </ul>\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_INT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the specified field as RFC_INT (signed).\n \\ingroup container\n\n This function works exactly like RfcGetInt(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetIntByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_INT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of a field as an unsigned one byte integer.\n \\ingroup container\n\n The current field value must not be bigger than 255, otherwise you'll get an RFC_CONVERSION_ERROR.\n If the field is of type RFCTYPE_BYTE/RFCTYPE_XSTRING, the field length must be 1 byte.\n\n The field specified by name needs to be of one of the following data types:\n <ul>\n <li>RFCTYPE_INT8\n <li>RFCTYPE_INT\n <li>RFCTYPE_INT2\n <li>RFCTYPE_INT1\n <li>RFCTYPE_BYTE\n <li>RFCTYPE_XSTRING\n <li>RFCTYPE_FLOAT\n <li>RFCTYPE_BCD\n </ul>\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt1(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_INT1,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of a field as an unsigned one byte integer.\n \\ingroup container\n\n This function works exactly like RfcGetInt1(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt1ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_INT1,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field value as a signed two byte integer.\n \\ingroup container\n\n The current field value must be between -32768 and 32767, otherwise you'll get an RFC_CONVERSION_ERROR.\n If the field is of type RFCTYPE_BYTE/RFCTYPE_XSTRING, the field length must be 1 or 2 bytes.\n\n The field specified by name needs to be of one of the following data types:\n <ul>\n <li>RFCTYPE_INT8\n <li>RFCTYPE_INT\n <li>RFCTYPE_INT2\n <li>RFCTYPE_INT1\n <li>RFCTYPE_BYTE     is interpreted as big endian sequence of a short\n <li>RFCTYPE_XSTRING  is interpreted as big endian sequence of a short\n <li>RFCTYPE_FLOAT\n <li>RFCTYPE_BCD\n </ul>\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt2(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_INT2,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field value as a signed two byte integer.\n \\ingroup container\n\n This function works exactly like RfcGetInt2(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt2ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_INT2,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field value as a signed eight byte integer.\n \\ingroup container\n\n If the field is of type RFCTYPE_BYTE/RFCTYPE_XSTRING, the field length must be 1, 2, 4 or 8 bytes.\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_INT8\n - RFCTYPE_INT\n - RFCTYPE_INT2\n - RFCTYPE_INT1\n - RFCTYPE_BYTE     is interpreted as big endian sequence of a long long\n - RFCTYPE_XSTRING  is interpreted as big endian sequence of a long long\n - RFCTYPE_UTCLONG\n - RFCTYPE_FLOAT\n - RFCTYPE_CHAR\n - FCTYPE_NUM\n - RFCTYPE_STRING\n - RFCTYPE_BCD\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt8(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_INT8,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field value as a signed eight byte integer.\n \\ingroup container\n\n This function works exactly like RfcGetInt8(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The (converted) integer value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetInt8ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_INT8,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the given field as an RFC_FLOAT.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECF16\n - RFCTYPE_DECF34\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The floating point value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetFloat(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_FLOAT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the value of the given field as an RFC_FLOAT.\n \\ingroup container\n\n This function works exactly like RfcGetFloat(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The floating point value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetFloatByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_FLOAT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field as an 8 byte IEEE 754r decimal floating point.\n \\ingroup container\n\n See the header sapdecf.h for how to work with RFC_DECF16 objects. If the field has a binary\n data type, its field length needs to be 8 bytes.\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_DECF16\n - RFCTYPE_DECF34\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_INT8\n - RFCTYPE_INT\n - RFCTYPE_INT2\n - RFCTYPE_INT1\n - RFCTYPE_CHAR\n - RFCTYPE_NUM\n - RFCTYPE_STRING\n - RFCTYPE_BYTE     is interpreted as IEEE 754r format\n - RFCTYPE_XSTRING  is interpreted as IEEE 754r format\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The (converted) decimal floating point value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetDecF16(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_DECF16,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field as an 8 byte IEEE 754r decimal floating point.\n \\ingroup container\n\n This function works exactly like RfcGetDecF16(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The (converted) decimal floating point value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetDecF16ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_DECF16,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field as a 16 byte IEEE 754r decimal floating point.\n \\ingroup container\n\n See the header sapdecf.h for how to work with RFC_DECF16 objects. If the field has a binary\n data type, its field length needs to be 16 bytes.\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_DECF16\n - RFCTYPE_DECF34\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_INT8\n - RFCTYPE_INT\n - RFCTYPE_INT2\n - RFCTYPE_INT1\n - RFCTYPE_CHAR\n - RFCTYPE_NUM\n - RFCTYPE_STRING\n - RFCTYPE_BYTE     is interpreted as IEEE 754r format\n - RFCTYPE_XSTRING  is interpreted as IEEE 754r format\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *value The (converted) decimal floating point value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetDecF34(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: *mut RFC_DECF34,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the field as a 16 byte IEEE 754r decimal floating point.\n \\ingroup container\n\n This function works exactly like RfcGetDecF34(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *value The (converted) decimal floating point value.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcGetDecF34ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: *mut RFC_DECF34,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a handle to a structure.\n \\ingroup container\n\n The field specified by name must be of type RFCTYPE_STRUCTURE. If that field has not yet\n been accessed/filled previously, a new empty structure is created from the metadata of the\n parent data container (\"dataHandle\") and returned.\n \\warning The memory of that data container will be released, when the parent container gets\n destroyed. So don't destroy the returned structure handle, nor continue to use it, after the\n parent has been destroyed!\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *structHandle A handle to the sub-structure.\n \\out *errorInfo Field does not exist, is of wrong type or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetStructure(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        structHandle: *mut RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a handle to a structure.\n \\ingroup container\n\n This function works exactly like RfcGetStructure(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *structHandle A handle to the sub-structure.\n \\out *errorInfo Field does not exist, is of wrong type or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetStructureByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        structHandle: *mut RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the entire structure value as a single char buffer.\n \\ingroup container\n\n The charBuffer will be filled with the data of the structure as if it were a single char field.\n\n In case the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL.\n The result will <b>not</b> be null-terminated.\n\n This mimics the way structures have been handled by the classic RFC library librfc32.\n It can conveniently be used for fetching an RFC structure into a C struct, which has been defined\n like in the ABAP DDIC.\n In addition to programming convenience, it should also improve runtime performance compared to fetching\n each single field one-by-one.\n\n This function can only be applied to structures/tables if they contain char-like fields (CHAR, NUMC, DATE, TIME)\n The result will be aligned exactly as on ABAP side, including padding bytes.\n\n \\in dataHandle A data container (structure handle or table handle). If dataHandle\n is a table handle, the function will read the structure data of the current row.\n \\out *charBuffer Pre-allocated buffer, which will receive the structure value.\n \\in bufferLength Size of the buffer in SAP_UC.\n \\out *errorInfo More information in case the structure cannot be returned as char buffer.\n \\return RFC_RC"]
    pub fn RfcGetStructureIntoCharBuffer(
        dataHandle: DATA_CONTAINER_HANDLE,
        charBuffer: *mut SAP_UC,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a handle to a table.\n \\ingroup container\n\n The field specified by name must be of type RFCTYPE_TABLE. If that field has not yet\n been accessed/filled previously, a new empty structure is created from the metadata of the\n parent data container (\"dataHandle\") and returned.\n \\warning The memory of that data container will be released, when the parent container gets\n destroyed. So don't destroy the returned table handle, nor continue to use it, after the\n parent has been destroyed!\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *tableHandle A handle to the sub-table.\n \\out *errorInfo Field does not exist, is of wrong type or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetTable(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        tableHandle: *mut RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a handle to a table.\n \\ingroup container\n\n This function works exactly like RfcGetTable(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *tableHandle A handle to the sub-table.\n \\out *errorInfo Field does not exist, is of wrong type or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetTableByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        tableHandle: *mut RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a handle to an abap object.\n \\ingroup container\n\n The field specified by name must be of type RFCTYPE_ABAPOBJECT. If that field has not yet\n been filled previously, NULL is returned.\n \\warning The memory of that data container will be released, when the parent container gets\n destroyed. So don't destroy the returned table handle, nor continue to use it, after the\n parent has been destroyed!\n\n\n \\in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of the field to read.\n \\out *objHandle A handle to the object.\n \\out *errorInfo Field does not exist, is of wrong type or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetAbapObject(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        objHandle: *mut RFC_ABAP_OBJECT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a handle to an abap object.\n \\ingroup container\n\n This function works exactly like RfcGetAbapObject(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of the field to read.\n \\out *objHandle A handle to the object.\n \\out *errorInfo Field does not exist, is of wrong type or out of memory.\n \\return RFC_RC"]
    pub fn RfcGetAbapObjectByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        objHandle: *mut RFC_ABAP_OBJECT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the length of the value of a STRING or XSTRING parameter.\n \\ingroup container\n\n The field specified by name must be of type RFCTYPE_STRING or RFCTYPE_XSTRING. If that field is\n of type STRING, the returned length is measured in characters, otherwise in bytes.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in *name The name of a STRING or XSTRING field.\n \\out *stringLength Length of the current field value.\n \\out *errorInfo Wrong field type?\n \\return RFC_RC"]
    pub fn RfcGetStringLength(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        stringLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the length of the value of a STRING or XSTRING parameter.\n \\ingroup container\n\n This function works exactly like RfcGetStringLength(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will read the field value of the current row.\n \\in index The index of a STRING or XSTRING field.\n \\out *stringLength Length of the current field value.\n \\out *errorInfo Wrong field type?\n \\return RFC_RC"]
    pub fn RfcGetStringLengthByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        stringLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given char value (charValue/valueLength) into the field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_UTCLONG\n\n \\note If the target field is a numerical type, the RFC library tries to convert the string\n to a number. If the target field has type BYTE or XSTRING, the char value will be interpreted as\n hex encoded string representation of the bytes. Its length needs to be even in that case.\\n\n Example: the 8 characters \"CAFEBABE\" will be converted to 4 bytes 0xCA 0xFE 0xBA 0xBE.\n\n If the value cannot be converted to the desired target type, RFC_CONVERSION_ERROR will be\n returned.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in *charValue The characters to write into the field.\n \\in valueLength The number of characters to read from charValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetChars(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        charValue: *const RFC_CHAR,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given char value (charValue/valueLength) into the field.\n \\ingroup container\n\n This function works exactly like RfcSetChars(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in *charValue The characters to write into the field.\n \\in valueLength The number of characters to read from charValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetCharsByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        charValue: *const RFC_CHAR,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a NUMC field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_INTx\n - RFCTYPE_UTCLONG\n - RFCTYPE_FLOAT\n - RFCTYPE_DECFxx\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in *charValue The digits [0..9] to write into the field.\n \\in valueLength The number of characters to read from charValue.\n \\out *errorInfo More information in case the field does not exist or the parameter value is invalid.\n \\return RFC_RC"]
    pub fn RfcSetNum(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        charValue: *const RFC_NUM,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a NUMC field.\n \\ingroup container\n\n This function works exactly like RfcSetNum(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in *charValue The digits [0..9] to write into the field.\n \\in valueLength The number of characters to read from charValue.\n \\out *errorInfo More information in case the field does not exist or the parameter value is invalid.\n \\return RFC_RC"]
    pub fn RfcSetNumByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        charValue: *const RFC_NUM,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given string value (stringValue/valueLength) into the field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_DATE\n - RFCTYPE_TIME\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_UTCLONG\n\n \\note If the target field is a numerical type, the RFC library tries to convert the string\n to a number. If the target field has type BYTE or XSTRING, the char value will be interpreted as\n hex encoded string representation of the bytes. Its length needs to be even in that case.\\n\n Example: the 8 characters \"CAFEBABE\" will be converted to 4 bytes 0xCA 0xFE 0xBA 0xBE.\n\n If the value cannot be converted to the desired target type, RFC_CONVERSION_ERROR will be\n returned.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in *stringValue The characters to write into the field.\n \\in valueLength The number of characters to read from stringValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetString(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        stringValue: *const SAP_UC,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given string value (stringValue/valueLength) into the field.\n \\ingroup container\n\n This function works exactly like RfcSetString(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in *stringValue The characters to write into the field.\n \\in valueLength The number of characters to read from stringValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetStringByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        stringValue: *const SAP_UC,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a DATE field.\n \\ingroup container\n\n The target field needs to be of type RFCTYPE_DATE.\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in date The date value to write into the field.\n \\out *errorInfo Is the field not of type DATE?\n \\return RFC_RC"]
    pub fn RfcSetDate(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        date: *const RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a DATE field.\n \\ingroup container\n\n This function works exactly like RfcSetDate(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in date The date value to write into the field.\n \\out *errorInfo Is the field not of type DATE?\n \\return RFC_RC"]
    pub fn RfcSetDateByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        date: *const RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a TIME field.\n \\ingroup container\n\n The target field needs to be of type RFCTYPE_TIME.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in time The time value to write into the field.\n \\out *errorInfo Is the field not of type TIME?\n \\return RFC_RC"]
    pub fn RfcSetTime(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        time: *const RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a TIME field.\n \\ingroup container\n\n This function works exactly like RfcSetTime(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in time The time value to write into the field.\n \\out *errorInfo Is the field not of type TIME?\n \\return RFC_RC"]
    pub fn RfcSetTimeByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        time: *const RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given byte value (byteValue/valueLength) into the field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n \\note: If the target field has type CHAR or STRING, the byte value\n will be stored as a hex representation of the bytes.\\n\n If the target field has a numerical type, the byte value will be\n assigned only if the given valueLength matches the field length.\n In order to use this feature, you need to know exactly what you are doing...\n E.g. when setting 8 bytes into an RFC_FLOAT field, you need to understand the\n IEEE floating point format. Better only use this function for setting RAW fields.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in *byteValue The byte value to write into the field.\n \\in valueLength The number of bytes to use from byteValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetBytes(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        byteValue: *const SAP_RAW,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given byte value (byteValue/valueLength) into the field.\n \\ingroup container\n\n This function works exactly like RfcSetBytes(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in *byteValue The byte value to write into the field.\n \\in valueLength The number of bytes to use from byteValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetBytesByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        byteValue: *const SAP_RAW,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given byte value (byteValue/valueLength) into the field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_BYTE\n - RFCTYPE_XSTRING\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_INTx\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_DECFxx\n \\note: If the target field has type CHAR or STRING, the byte value\n will be stored as a hex representation of the bytes.\\n\n If the target field has a numerical type, the byte value will be\n assigned only if the given valueLength matches the field length.\n In order to use this feature, you need to know exactly what you are doing...\n E.g. when setting 8 bytes into an RFC_FLOAT field, you need to understand the\n IEEE floating point format. Better only use this function for setting RAW fields.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in *byteValue The byte value to write into the field.\n \\in valueLength The number of bytes to use from byteValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetXString(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        byteValue: *const SAP_RAW,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the given byte value (byteValue/valueLength) into the field.\n \\ingroup container\n\n This function works exactly like RfcSetXString(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in *byteValue The byte value to write into the field.\n \\in valueLength The number of bytes to use from byteValue.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetXStringByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        byteValue: *const SAP_RAW,
        valueLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT4 field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_INTx\n - RFCTYPE_DECFxx\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_INT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT4 field.\n \\ingroup container\n\n This function works exactly like RfcSetInt(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetIntByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_INT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT1 field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_INTx\n - RFCTYPE_DECFxx\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt1(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_INT1,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT1 field.\n \\ingroup container\n\n This function works exactly like RfcSetInt1(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt1ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_INT1,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT2 field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_INTx\n - RFCTYPE_DECFxx\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt2(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_INT2,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT2 field.\n \\ingroup container\n\n This function works exactly like RfcSetInt2(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt2ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_INT2,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT8 field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_INTx\n - RFCTYPE_DECFxx\n - RFCTYPE_UTCLONG.\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt8(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_INT8,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an INT8 field.\n \\ingroup container\n\n This function works exactly like RfcSetInt8(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The integer value to set.\n \\out *errorInfo More information in case the field does not exist or a conversion fails.\n \\return RFC_RC"]
    pub fn RfcSetInt8ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_INT8,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets a floating point field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_CHAR\n - RFCTYPE_STRING\n - RFCTYPE_NUM\n - RFCTYPE_DECF16\n - RFCTYPE_DECF34\n \\note If the target field is CHAR or STRING, the value will be converted to a string in\n scientific notation. If it is NUMC, it will be truncated to the next integer.\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The double value to set.\n \\out *errorInfo Field does not exist or is not of a supported type?\n \\return RFC_RC"]
    pub fn RfcSetFloat(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_FLOAT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets a floating point field.\n \\ingroup container\n\n This function works exactly like RfcSetFloat(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The double value to set.\n \\out *errorInfo Field does not exist or is not of a supported type?\n \\return RFC_RC"]
    pub fn RfcSetFloatByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_FLOAT,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an 8 byte decfloat object into a field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_DECF16\n - RFCTYPE_DECF34\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_INT\n - RFCTYPE_INT2\n - RFCTYPE_INT1\n - RFCTYPE_CHAR\n - RFCTYPE_NUM\n - RFCTYPE_STRING\n - RFCTYPE_BYTE     Needs to be 8 byte long.\n - RFCTYPE_XSTRING\n \\note If the target field is CHAR or STRING, the value will be converted to a string in\n scientific notation. If it is NUMC, it will be truncated to the next integer.\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The decfloat value to set.\n \\out *errorInfo Field does not exist or is not of a supported type?\n \\return RFC_RC"]
    pub fn RfcSetDecF16(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_DECF16,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of an 8 byte decfloat object into a field.\n \\ingroup container\n\n This function works exactly like RfcSetDecF16(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The decfloat value to set.\n \\out *errorInfo Field does not exist or is not of a supported type?\n \\return RFC_RC"]
    pub fn RfcSetDecF16ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_DECF16,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a 16 byte decfloat object into a field.\n \\ingroup container\n\n The field specified by name needs to be of one of the following data types:\n - RFCTYPE_DECF16\n - RFCTYPE_DECF34\n - RFCTYPE_FLOAT\n - RFCTYPE_BCD\n - RFCTYPE_INT\n - RFCTYPE_INT2\n - RFCTYPE_INT1\n - RFCTYPE_CHAR\n - RFCTYPE_NUM\n - RFCTYPE_STRING\n - RFCTYPE_BYTE     Needs to be 8 byte long.\n - RFCTYPE_XSTRING\n \\note If the target field is CHAR or STRING, the value will be converted to a string in\n scientific notation. If it is NUMC, it will be truncated to the next integer.\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The decfloat value to set.\n \\out *errorInfo Field does not exist or is not of a supported type?\n \\return RFC_RC"]
    pub fn RfcSetDecF34(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_DECF34,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the value of a 16 byte decfloat object into a field.\n \\ingroup container\n\n This function works exactly like RfcSetDecF34(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The decfloat value to set.\n \\out *errorInfo Field does not exist or is not of a supported type?\n \\return RFC_RC"]
    pub fn RfcSetDecF34ByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_DECF34,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Copies the given structure into the target structure of the parent container.\n \\ingroup container\n\n The target field needs to be of type RFCTYPE_STRUCTURE.\n\n \\note If you want to avoid the copy operation, use RfcGetStructure() and set the subfields here,\n instead of the sequence RfcCreateStructure()/ setting the subfields/ #RfcSetStructure().\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The structure to copy.\n \\out *errorInfo Out of memory, field does not exist or is not of type RFCTYPE_STRUCTURE?\n \\return RFC_RC"]
    pub fn RfcSetStructure(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Copies the given structure into the target structure of the parent container.\n \\ingroup container\n\n This function works exactly like RfcSetStructure(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The structure to copy.\n \\out *errorInfo Out of memory, field does not exist or is not of type RFCTYPE_STRUCTURE?\n \\return RFC_RC"]
    pub fn RfcSetStructureByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_STRUCTURE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief Set single char value buffer to the entire structure.\n \\ingroup container\n\n The structure will be filled with the data of bufferas if it were a single char field.\n\n In case the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL.\n The result will <b>not</b> be null-terminated.\n\n This mimics the way structures have been handled by the classic RFC library librfc32.\n It can conveniently be used for fetching an RFC structure into a C struct, which has been defined\n like in the ABAP DDIC.\n In addition to programming convenience, it should also improve runtime performance compared to fetching\n each single field one-by-one.\n\n This function can only be applied to structures/tables if they contain char-like fields (CHAR, NUMC, DATE, TIME)\n The result will be aligned exactly as on ABAP side, including padding bytes.\n\n \\out dataHandle A data container (structure handle or table handle). If dataHandle\n is a table handle, the function will read the structure data of the current row.\n \\in *charBuffer Pre-allocated buffer, which will receive the structure value.\n \\in bufferLength Size of the buffer in SAP_UC.\n \\out *errorInfo More information in case the structure cannot be returned as char buffer.\n \\return RFC_RC"]
    pub fn RfcSetStructureFromCharBuffer(
        dataHandle: DATA_CONTAINER_HANDLE,
        charBuffer: *mut SAP_UC,
        bufferLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Copies the given table into the target table of the parent container.\n \\ingroup container\n\n The target field needs to be of type RFCTYPE_TABLE.\n\n \\note If you want to avoid the copy operation, use RfcGetTable() and set the subfields here,\n instead of the sequence RfcCreateTable()/ setting the subfields/ #RfcSetTable().\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The table to copy.\n \\out *errorInfo Field does not exist or is not of type RFCTYPE_TABLE?\n \\return RFC_RC"]
    pub fn RfcSetTable(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Copies the given table into the target table of the parent container.\n \\ingroup container\n\n This function works exactly like RfcSetTable(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle or table handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The table to copy.\n \\out *errorInfo Field does not exist or is not of type RFCTYPE_TABLE?\n \\return RFC_RC"]
    pub fn RfcSetTableByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_TABLE_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Copies the object into the target object of the parent container.\n \\ingroup container\n\n The target field needs to be of type RFCTYPE_ABAPOBJECT.\n\n \\note If you want to avoid the copy operation, use RfcGetAbapObject() and if the instance already exists set the subfields here,\n instead of the sequence RfcCreateAbapObject()/ setting the subfields/ #RfcSetAbapObject().\n\n \\in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *name The name of the field to set.\n \\in value The object to copy.\n \\out *errorInfo Field does not exist or is not of type RFCTYPE_ABAPOBJECT?\n \\return RFC_RC"]
    pub fn RfcSetAbapObject(
        dataHandle: DATA_CONTAINER_HANDLE,
        name: *const SAP_UC,
        value: RFC_ABAP_OBJECT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Copies the object into the target object of the parent container.\n \\ingroup container\n\n This function works exactly like RfcSetAbapObject(), the difference being that the field is\n addressed by its index within the structure/table/function module. The first field has index 0,\n last field has index n-1, the order of the fields is as defined in the ABAP DDIC.\n\n\n \\in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle\n is a table handle, the function will set the field value of the current row.\n \\in *index The index of the field to set.\n \\in value The object to copy.\n \\out *errorInfo Field does not exist or is not of type RFCTYPE_ABAPOBJECT?\n \\return RFC_RC"]
    pub fn RfcSetAbapObjectByIndex(
        dataHandle: DATA_CONTAINER_HANDLE,
        index: ::std::os::raw::c_uint,
        value: RFC_ABAP_OBJECT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the ABAP exception object handle from the given function handle.\n \\ingroup container\n\n If a call to #RfcInvoke() returned RFC_ABAP_CLASS_EXCEPTION, the RFC client calls this function afterwards with the original function handle\n in order to get access to the details of the class exception.\n \\in funcHandle   Function module data container.\n \\out *errorInfo  Should always return successfully.\n \\return A handle to an ABAP class exception object ."]
    pub fn RfcGetAbapClassException(
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_ABAP_OBJECT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the ABAP exception object handle to the given function handle.\n \\ingroup container\n\n If an RFC server function wants to throw an ABAP class exception, it calls this function before it returns with RFC_ABAP_CLASS_EXCEPTION.\n \\in funcHandle   Function module data container .\n \\in excpHandle   Object handle to the class exception to be thrown.\n \\in exceptionText  Exception text.\n \\out *errorInfo  Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcSetAbapClassException(
        funcHandle: RFC_FUNCTION_HANDLE,
        excpHandle: RFC_ABAP_OBJECT_HANDLE,
        exceptionText: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the metadata description for the given function module.\n \\ingroup container\n\n\n \\in funcHandle A function module.\n \\out *errorInfo Can't possibly go wrong...\n \\return The metadata description that had been used when creating the function module container."]
    pub fn RfcDescribeFunction(
        funcHandle: RFC_FUNCTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_FUNCTION_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the metadata description of the given structure or table (RFC_STRUCTURE_HANDLE or RFC_TABLE_HANDLE).\n \\ingroup container\n\n\n \\in dataHandle A structure or table.\n \\out *errorInfo Can't possibly go wrong...\n \\return The type description of the given structure (in case dataHandle is a structure), or the\n type description of the table line type (in case dataHandle is a table)."]
    pub fn RfcDescribeType(
        dataHandle: DATA_CONTAINER_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TYPE_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the function description that is valid for the system to which rfcHandle points to.\n \\ingroup repository\n\n If the function description is already in the repository cache for that system ID, it will be\n returned immediately (from the cache), otherwise it will be looked up in the system's DDIC using\n the rfcHandle. The result from the DDIC lookup will then be placed into the cache for later use.\n\n The RFC Runtime maintains a cache for every R/3 System ID, as the meta data could be different\n from R/3 release to R/3 release.\n This is the main API that should be used.\n\n \\in rfcHandle Open client connection to the R/3 System, for which you need the function module description.\n \\in *funcName Name of the function module to look up.\n \\out *errorInfo More error details in case something goes wrong.\n \\return The metadata description of the given function module."]
    pub fn RfcGetFunctionDesc(
        rfcHandle: RFC_CONNECTION_HANDLE,
        funcName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_FUNCTION_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Looks for a cached function description.\n \\ingroup repository\n\n This API should be used with care and is only for special scenarios, for example:\n 1. You know for sure, that a function description has already been cached via RfcGetFunctionDesc(),\n    and don't want to open an extra rfcHandle that will never be used.\n    In this case simply use the SAP System ID as the repositoryID.\n 2. You have created a hard-coded repository via RfcAddFunctionDesc(), which contains function modules\n    that do not exist in the backend's DDIC.\n\n If repositoryID is NULL, the \"default repository\" is used.\n\n \\in *repositoryID System ID of R/3 System, for which this function module description has been cached,\n or NULL in case you want to look for it in the default repository.\n \\in *funcName Name of the function module.\n \\out *errorInfo Requested function name not in cache?\n \\return The requested function description."]
    pub fn RfcGetCachedFunctionDesc(
        repositoryID: *const SAP_UC,
        funcName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_FUNCTION_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a function description to the cache for the specified R/3 System.\n \\ingroup repository\n\n This API should be used with care and is only for special scenarios, e.g. if you want to\n write an RFC server that offers function modules, which do not exist in the R/3 system's DDIC.\n If repositoryID is NULL, the description is added to the \"default repository\".\n\n\n \\in *repositoryID System ID of R/3 System, to whose cache you want to add the function description,\n or NULL for the default repository.\n \\in funcDesc The function description.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcAddFunctionDesc(
        repositoryID: *const SAP_UC,
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes a function description from the cache for the specified R/3 System.\n \\ingroup repository\n\n This API can be used, e.g. if the signature (imports, exports, etc.) of a function module has\n been changed in the backend, while the external RFC program is still running. If the RFC library\n continues using the old cached metadata description, garbage values (if fields have been deleted\n from the function module) or missing values (if new fields have been added to the function module)\n will result.\n If repositoryID is NULL, the description is removed from the \"default repository\".\n\n\n \\in *repositoryID System ID of R/3 System, to whose cache you want to add the function description,\n or NULL for the default repository.\n \\in *functionName The name of the function module, whose description is to be removed from the cache.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcRemoveFunctionDesc(
        repositoryID: *const SAP_UC,
        functionName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the structure description that is valid for the system to which rfcHandle points to.\n \\ingroup repository\n\n If the structure description is already in the repository cache for that system ID, it will be\n returned immediately (from the cache), otherwise it will be looked up in the system's DDIC using\n the rfcHandle. The result from the DDIC lookup will then be placed into the cache for later use.\n\n The RFC Runtime maintains a cache for every R/3 System ID, as the meta data could be different\n from R/3 release to R/3 release.\n \\note Normally it should not be necessary to lookup separate structure descriptions. They are\n already looked up as part of the function module, in which they are used.\n\n \\in rfcHandle Open client connection to the R/3 System, for which you need the structure description.\n \\in *typeName Name of a DDIC structure or table.\n \\out *errorInfo More error details in case something goes wrong.\n \\return The metadata description of the given structure/table."]
    pub fn RfcGetTypeDesc(
        rfcHandle: RFC_CONNECTION_HANDLE,
        typeName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TYPE_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Looks for a cached structure/table description.\n \\ingroup repository\n\n Similar to RfcGetTypeDesc(), but it only looks into the cache. Again it should almost never\n be necessary to get a metadata description of a single structure.\n\n \\in *repositoryID System ID of R/3 System, for which this type description has been cached,\n or NULL in case you want to look for it in the default repository.\n \\in *typeName Name of the DDIC structure/table.\n \\out *errorInfo Requested type name not in cache?\n \\return The requested type description."]
    pub fn RfcGetCachedTypeDesc(
        repositoryID: *const SAP_UC,
        typeName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TYPE_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a type description to the cache.\n \\ingroup repository\n\n\n \\in *repositoryID System ID of R/3 System, to whose cache you want to add the type description,\n or NULL for the default repository.\n \\in typeHandle The type description.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcAddTypeDesc(
        repositoryID: *const SAP_UC,
        typeHandle: RFC_TYPE_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes a type description from the cache.\n \\ingroup repository\n\n\n \\in *repositoryID System ID of R/3 System, from whose cache you want to remove the type description,\n or NULL for the default repository.\n \\in *typeName The name of the type, whose description is to be removed from the cache.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcRemoveTypeDesc(
        repositoryID: *const SAP_UC,
        typeName: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the class description that is valid for the system to which rfcHandle points to.\n \\ingroup repository\n\n If the class description is already in the repository cache for that system ID, it will be\n returned immediately (from the cache), otherwise it will be looked up in the system's DDIC using\n the rfcHandle. The result from the DDIC lookup will then be placed into the cache for later use.\n\n The RFC Runtime maintains a cache for every R/3 System ID, as the meta data could be different\n from R/3 release to R/3 release.\n This is the main API that should be used.\n\n \\in rfcHandle Open client connection to the R/3 System, for which you need the class description.\n \\in *className Name of the class to look up.\n \\out *errorInfo More error details in case something goes wrong.\n \\return The metadata description of the given function module."]
    pub fn RfcGetClassDesc(
        rfcHandle: RFC_CONNECTION_HANDLE,
        className: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CLASS_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Looks for a cached class description.\n \\ingroup repository\n\n This API should be used with care and is only for special scenarios, for example:\n 1. You know for sure, that a class description has already been cached via RfcGetClassDesc(),\n    and don't want to open an extra rfcHandle that will never be used.\n    In this case simply use the SAP System ID as the repositoryID.\n 2. You have created a hard-coded repository via RfcAddClassDesc(), which contains classes\n    that do not exist in the backend's DDIC.\n\n If repositoryID is NULL, the \"default repository\" is used.\n\n \\in *repositoryID System ID of R/3 System, for which this class description has been cached,\n or NULL in case you want to look for it in the default repository.\n \\in *className Name of the class.\n \\out *errorInfo Requested class name not in cache?\n \\return The requested class description."]
    pub fn RfcGetCachedClassDesc(
        repositoryID: *const SAP_UC,
        className: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CLASS_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the metadata description of the given ABAP object handle.\n \\ingroup container\n\n\n \\in objectHandle An ABAP object.\n \\out *errorInfo Can't possibly go wrong...\n \\return The class description of the given ABAP object."]
    pub fn RfcDescribeAbapObject(
        objectHandle: RFC_ABAP_OBJECT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CLASS_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a class description to the cache for the specified R/3 System.\n \\ingroup repository\n\n This API should be used with care and is only for special scenarios, e.g. if you want to\n write an RFC server that offers/uses classes, which do not exist in the R/3 system's DDIC.\n If repositoryID is NULL, the description is added to the \"default repository\".\n\n\n \\in *repositoryID System ID of R/3 System, to whose cache you want to add the class description,\n or NULL for the default repository.\n \\in classDesc The class description.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcAddClassDesc(
        repositoryID: *const SAP_UC,
        classDesc: RFC_CLASS_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes a class description from the cache for the specified R/3 System.\n \\ingroup repository\n\n If repositoryID is NULL, the description is removed from the \"default repository\".\n\n\n \\in *repositoryID System ID of R/3 System, from whose cache you want to remove the class description,\n or NULL for the default repository.\n \\in *className The name of the ABAP class, whose description you want to remove.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcRemoveClassDesc(
        repositoryID: *const SAP_UC,
        className: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes all metadata from the repository cache of the specified R/3 System.\n \\ingroup repository\n\n If repositoryID is NULL, the \"default repository\" is cleared.\n\n\n \\in *repositoryID System ID of R/3 System, whose cache you want to clear,\n or NULL for the default repository.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcClearRepository(
        repositoryID: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Stores the currently cached objects of a repository into a JSON formatted text file.\n \\ingroup repository\n\n This function will create a JSON formatted text file that contains all currently cached function module descriptions with their parameters,\n so it can be reloaded at another time (see RfcLoadRepository()) without opening connections to the backend and fetching metadata from the DDIC.\n This JSON file can also be used by the SAP .NET Connector and SAP Java Connector.\n\n \\in *repositoryID System ID of R/3 System, whose cache you want to save, or NULL for the default cache.\n \\in *targetStream FILE pointer opened by the user.\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcSaveRepository(
        repositoryID: *const SAP_UC,
        targetStream: *mut FILE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Retrieves metadata from a JSON formatted text file and creates the according repository to use for function calls.\n \\ingroup repository\n\n This function will create a repository with the given ID - or a default repository, if the ID is NULL - and populate it with\n the function descriptions and parameter descriptions contained in the JSON formatted text file (see RfcSaveRepository()).\n That way the RFC program does not need to fetch the metadata from the backend DDIC, which is useful, if you want to\n improve the startup performance of your program or if your program is an RFC server that does not have login parameters\n for the backend.\n It is also possible to use JSON files created by SAP .NET Connector and SAP Java Connector.\n\n \\note Special care needs to be taken to guarantee that the loaded metadata indeed matches the function and structure\n descriptions defined in the backend system(s) against which it is to be used. Otherwise the risk of data corruption is very high.\n \\note If a repository with the given ID already exists, %RfcLoadRepository() will delete it and replace it with the contents\n of the JSON file.\n\n\n \\in *repositoryID System ID of R/3 System, for which you want to use the metadata contained in the JSON file, or NULL\n for the default repository.\n \\in *targetStream FILE pointer opened by the user.\n \\out *errorInfo More error details in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcLoadRepository(
        repositoryID: *const SAP_UC,
        targetStream: *mut FILE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates an empty type description with the given name.\n \\ingroup structure\n\n API for creating hard-coded metadata descriptions, e.g. for function modules that\n don't exist in the R/3 backend.\n Add field descriptions to the type description using RfcAddTypeField() and at the end\n set the total byte length of the structure using RfcSetTypeLength().\n \\warning It is not easy to get the total length right, as you also need to take\n alignment bytes into account...\n\n Finished type definitions can then be used for creating data containers (RfcCreateStructure()\n or RfcCreateTable()) and for adding field/table descriptions to a function module description\n (in RFC_PARAMETER_DESCs in RfcAddParameter()).\n\n After the handle was used for creating a container, any modifications are forbidden.\n\n \\in *name An (arbitrary) name for the type.\n \\out *errorInfo Not enough memory?\n \\return The new type description."]
    pub fn RfcCreateTypeDesc(
        name: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_TYPE_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a new field to the type description.\n \\ingroup structure\n\n \\note After a type description has been used (e.g. via RfcCreateStructure(), RfcCreateTable() or\n RfcAddTypeDesc()), it can no longer be modified!\n\n \\in typeHandle\n \\in *fieldDescr\n \\out *errorInfo\n \\return RFC_RC"]
    pub fn RfcAddTypeField(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        fieldDescr: *const RFC_FIELD_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the total byte length of the type description.\n \\ingroup structure\n\n Before a type description can be used, this function needs to be called.\n The RFC library does not automatically calculate the correct length based on\n the fields that have been added, because this task is non-trivial and possibly\n platform dependend. (Especially if the structure contains sub-structures.)\\n\n For integer and floating point types the correct alignments need to be taken into\n account (start address divisible by 4 or 8), fixed sub-structures are inlined,\n complex structures are referenced by an 8-byte pointer, etc. In general you will need\n to do a bit of trial and error, before you get it right.\\n\n If you really need more details/tips for the process of hardcoding metadata, see\n <A HREF=\"https://wiki.scn.sap.com/wiki/x/FD67Gg\">this article</A>.\n\n\n \\in typeHandle The type description.\n \\in nucByteLength Total byte length of the structure in a non-Unicode system (1 byte per CHAR).\n \\in ucByteLength Total byte length of the structure in a Unicode system (2 bytes per CHAR).\n \\out *errorInfo The function returns an error, if the given byte lengths are smaller than\n the sum of all field lengths, or if the nucByteLength is smaller than the ucByteLength.\n \\return RFC_RC"]
    pub fn RfcSetTypeLength(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        nucByteLength: ::std::os::raw::c_uint,
        ucByteLength: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the name of the type.\n \\ingroup structure\n\n\n \\in typeHandle The type description.\n \\out bufferForName Will receive the null-terminated DDIC name of the structure definition.\n \\out *errorInfo Should always return successfully...\n \\return RFC_RC"]
    pub fn RfcGetTypeName(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        bufferForName: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of fields in a structure definition.\n \\ingroup structure\n\n\n \\in typeHandle The type description.\n \\out *count The number of (direct) fields of this structure.\n \\out *errorInfo Should always return successfully...\n \\return RFC_RC"]
    pub fn RfcGetFieldCount(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        count: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the field description of the structure's ith field.\n \\ingroup structure\n\n Useful mostly when looping over the fields of a structure.\n\n \\in typeHandle The type description.\n \\in index The index of the field you are interested in.\n \\out *fieldDescr Will be filled with field's description.\n \\out *errorInfo Index out of bounds?\n \\return RFC_RC"]
    pub fn RfcGetFieldDescByIndex(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        index: ::std::os::raw::c_uint,
        fieldDescr: *mut RFC_FIELD_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the field description of a field given by name.\n \\ingroup structure\n\n\n \\in typeHandle The type description.\n \\in *name The name of the field of interest.\n \\out *fieldDescr Will be filled with field's description.\n \\out *errorInfo No such field?\n \\return RFC_RC"]
    pub fn RfcGetFieldDescByName(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        name: *const SAP_UC,
        fieldDescr: *mut RFC_FIELD_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the total byte length of a structure definition.\n \\ingroup structure\n\n\n \\in typeHandle The type description.\n \\out nucByteLength Total byte length in a non-Unicode system.\n \\out ucByteLength Total byte length in a Unicode system.\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcGetTypeLength(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        nucByteLength: *mut ::std::os::raw::c_uint,
        ucByteLength: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Deletes the type description and releases the allocated resources.\n \\ingroup structure\n\n Only descriptions, which are not stored in a repository cache and not used by the application, can be deleted.\n Deleting a cached description will cause an error, and deleting a description that is still in use, will lead\n to a crash.\n\n\n \\inout typeHandle The type description to be deleted.\n \\out *errorInfo\n \\return"]
    pub fn RfcDestroyTypeDesc(
        typeHandle: RFC_TYPE_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates an empty function description with the given name.\n \\ingroup function\n\n Add parameter descriptions and exception descriptions to the new RFC_FUNCTION_DESC_HANDLE\n via RfcAddParameter() and RfcAddException().\\n\n\n After the handle was used for creating a container, any modifications are forbidden.\n\n \\in *name The name of the function module.\n \\out *errorInfo Probably not enough memory left?!\n \\return An empty function description that can be used for constructing hard-coded metadata."]
    pub fn RfcCreateFunctionDesc(
        name: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_FUNCTION_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a function module's DDIC name.\n \\ingroup function\n\n\n \\in funcDesc The function module description.\n \\out bufferForName Will receive the function module's DDIC name.\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcGetFunctionName(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        bufferForName: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a new parameter (IMPORTING, EXPORTING, CHANGING, TABLES) to the function description.\n \\ingroup function\n\n \\note After the function description has been used via RfcCreateFunction() or RfcAddFunctionDesc(),\n it can no longer be modified!\n\n \\in funcDesc The function module description.\n \\in *paramDescr Metadata description of the new parameter.\n \\out *errorInfo More details in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcAddParameter(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        paramDescr: *const RFC_PARAMETER_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of parameters in the function module definition.\n \\ingroup function\n\n\n \\in funcDesc The function module's metadata description.\n \\out *count The number of parameters (IMPORTING, EXPORTING, CHANGING, TABLES).\n \\out *errorInfo Nothing can go wrong here.\n \\return RFC_RC"]
    pub fn RfcGetParameterCount(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        count: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the metadata description of the function module's ith parameter.\n \\ingroup function\n\n \\note Mostly be useful when looping over all parameters of a function module.\n\n \\in funcDesc The function module's metadata description.\n \\in index The index of the parameter to describe.\n \\out *paramDesc Metadata description of the specified parameter.\n \\out *errorInfo Index out of bounds?\n \\return RFC_RC"]
    pub fn RfcGetParameterDescByIndex(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        index: ::std::os::raw::c_uint,
        paramDesc: *mut RFC_PARAMETER_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the metadata description of a function module parameter given by name.\n \\ingroup function\n\n\n \\in funcDesc The function module's metadata description.\n \\in *name The name of the parameter to describe.\n \\out *paramDesc Metadata description of the specified parameter.\n \\out *errorInfo No such parameter?\n \\return RFC_RC"]
    pub fn RfcGetParameterDescByName(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        name: *const SAP_UC,
        paramDesc: *mut RFC_PARAMETER_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a new ABAP Exception to the function description.\n \\ingroup function\n\n \\note After the function description has been used via RfcCreateFunction() or RfcAddFunctionDesc(),\n it can no longer be modified!\n\n\n \\in funcDesc The function module's metadata description.\n \\in *excDesc The description of the exception to add.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcAddException(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        excDesc: *const RFC_EXCEPTION_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of ABAP Exceptions of the function module.\n \\ingroup function\n\n\n \\in funcDesc The function module's metadata description.\n \\out *count The number of the function module's ABAP Exceptions.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcGetExceptionCount(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        count: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the metadata description of the function module's ith ABAP Exception.\n \\ingroup function\n\n\n \\in funcDesc The function module's metadata description.\n \\in index The index of the exception to describe.\n \\out *excDesc The ABAP Exception's metadata description.\n \\out *errorInfo Index out of bounds?\n \\return RFC_RC"]
    pub fn RfcGetExceptionDescByIndex(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        index: ::std::os::raw::c_uint,
        excDesc: *mut RFC_EXCEPTION_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the metadata description of a function module's ABAP Exception given by name.\n \\ingroup function\n\n\n \\in funcDesc The function module's metadata description.\n \\in *name The name of the exception to describe.\n \\out *excDesc The ABAP Exception's metadata description.\n \\out *errorInfo No such ABAP Exception?\n \\return RFC_RC"]
    pub fn RfcGetExceptionDescByName(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        name: *const SAP_UC,
        excDesc: *mut RFC_EXCEPTION_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Enables this function module for the basXML serialization format.\n \\ingroup function\n\n R/3 Systems from kernel release 7.10 on support a new serialization format: basXML (binary ABAP serialization).\n Calling %RfcEnableBASXML() allows the RFC library to transport this function module's data via the\n basXML format, if the target backend supports it and the connection parameter NO_BASXML is either not set or set to \"0\".\n\n \\in funcDesc The function module's metadata description.\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcEnableBASXML(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns whether this function module has been enabled for basXML.\n \\ingroup function\n\n See RfcEnableBASXML()\n\n \\in funcDesc The function module's metadata description.\n \\out *isEnabled 0 = false, 1 = true.\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcIsBASXMLSupported(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        isEnabled: *mut ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Deletes the function description and releases the allocated resources.\n \\ingroup function\n\n Only descriptions, which are not stored in a repository cache and not used by the application, can be deleted.\n Deleting a cached description will cause an error, and deleting a description that is still in use, will lead\n to a crash.\n\n\n \\in funcDesc A function description.\n \\out *errorInfo Should always return successfully...\n \\return RFC_RC"]
    pub fn RfcDestroyFunctionDesc(
        funcDesc: RFC_FUNCTION_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Enables this function handle for ABAP class exception support.\n \\ingroup function\n\n R/3 Systems from kernel release 7.11 on support ABAP class exceptions.\n Calling %RfcEnableAbapClassException() allows an RFC client to inform the ABAP backend that it can handle ABAP class exceptions\n for the current function call using this function handle. If the ABAP backend supports class-based exceptions as well,\n it can now safely throw such an exception.\\n\n Needs to be called before the corresponding RfcInvoke().\n\n \\in funcHandle Function module data container.\n \\in rfcHandleRepository RFC connection handle to the repository system from where the missing metadata can be\n dynamically retrieved during de-serializing the received ABAP class exceptions. This handle can be NULL but should not be\n the same that is used for the RFC call itself.\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcEnableAbapClassException(
        funcHandle: RFC_FUNCTION_HANDLE,
        rfcHandleRepository: RFC_CONNECTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Checks whether this function handle has been enabled for ABAP class exception support.\n \\ingroup function\n\n R/3 Systems from kernel release 7.11 on support ABAP class exception.\n Typically, an RFC server can use this function in order to find out, whether the function module currently being processed has\n ABAP class exceptions enabled in the ABAP backend. Only if this is the case, can the RFC Server safely throw an ABAP class exception.\n\n \\in funcHandle Function module data container.\n \\out *isEnabled Flag indicating whether the function handle has been enabled for ABAP class based exception support.\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcIsAbapClassExceptionEnabled(
        funcHandle: RFC_FUNCTION_HANDLE,
        isEnabled: *mut ::std::os::raw::c_int,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates an empty class description with the given name.\n \\ingroup class\n\n Add attribute descriptions to the new RFC_CLASS_DESC_HANDLE via RfcAddAttribute().\\n\n\n After the handle was used for creating a container, any modifications are forbidden.\n\n \\in *name The name of the ABAP class.\n \\out *errorInfo Probably not enough memory left?!\n \\return An empty function description that can be used for constructing hard-coded metadata."]
    pub fn RfcCreateClassDesc(
        name: *const SAP_UC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_CLASS_DESC_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the class's DDIC name.\n \\ingroup class\n\n\n \\in classDesc The class description.\n \\out bufferForName Will receive the function module's DDIC name (zero terminated).\n \\out *errorInfo Should always return successfully.\n \\return RFC_RC"]
    pub fn RfcGetClassName(
        classDesc: RFC_CLASS_DESC_HANDLE,
        bufferForName: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds a new attribute (field, structure, table, method) to the class description.\n \\ingroup class\n\n \\note After the function description has been used via RfcCreateAbapObject() or RfcAddClassDesc(),\n it can no longer be modified!\n\n \\in classDesc The class description.\n \\in *attrDesc Metadata description of the new class attribute.\n \\out *errorInfo More details in case something goes wrong.\n \\return RFC_RC"]
    pub fn RfcAddClassAttribute(
        classDesc: RFC_CLASS_DESC_HANDLE,
        attrDesc: *const RFC_CLASS_ATTRIBUTE_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of parameters in the function module definition.\n \\ingroup class\n\n\n \\in classDesc The class description.\n \\out *count The number of attributes.\n \\out *errorInfo Nothing can go wrong here.\n \\return RFC_RC"]
    pub fn RfcGetClassAttributesCount(
        classDesc: RFC_CLASS_DESC_HANDLE,
        count: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the metadata description of the class attribute.\n \\ingroup class\n\n \\note Is useful mostly when looping over all attributes of a class.\n\n \\in classDesc The class metadata description.\n \\in index The index of the attributes to describe.\n \\out *attrDesc Metadata description of the class attribute.\n \\out *errorInfo Index out of bounds?\n \\return RFC_RC"]
    pub fn RfcGetClassAttributeDescByIndex(
        classDesc: RFC_CLASS_DESC_HANDLE,
        index: ::std::os::raw::c_uint,
        attrDesc: *mut RFC_CLASS_ATTRIBUTE_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Reads the metadata description of a class attribute given by name.\n \\ingroup class\n\n\n \\in classDesc The class metadata description.\n \\in *name The name of the parameter to describe.\n \\out *attrDesc Metadata description of the class attribute.\n \\out *errorInfo No such parameter?\n \\return RFC_RC"]
    pub fn RfcGetClassAttributeDescByName(
        classDesc: RFC_CLASS_DESC_HANDLE,
        name: *const SAP_UC,
        attrDesc: *mut RFC_CLASS_ATTRIBUTE_DESC,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the parent classes of the given class.\n \\ingroup class\n\n \\in classDesc The class metadata description.\n \\in name The parent class name.\n \\in index Index of parent class.\n \\out *errorInfo Current class does not inherit from parent class?\n \\return RFC_RC"]
    pub fn RfcGetParentClassByIndex(
        classDesc: RFC_CLASS_DESC_HANDLE,
        name: *mut RFC_CHAR,
        index: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of parent classes of the given class.\n \\ingroup class\n\n\n \\in classDesc The class metadata description.\n \\out *parentClassesCount Number of parent classes in the list.\n \\out *errorInfo Should always be successful.\n \\return RFC_RC"]
    pub fn RfcGetParentClassesCount(
        classDesc: RFC_CLASS_DESC_HANDLE,
        parentClassesCount: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the parent classes of the given class.\n \\ingroup class\n\n\n \\in classDesc The class metadata description.\n \\in name Parent class name to be added.\n \\out *errorInfo No such parameter?\n \\return RFC_RC"]
    pub fn RfcAddParentClass(
        classDesc: RFC_CLASS_DESC_HANDLE,
        name: *const RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the implemented interfaces of the given class.\n \\ingroup class\n\n\n \\in classDesc The class metadata description.\n \\in index Index of the implemented interface.\n \\out name Buffer for the implemented interface's name.\n \\out *errorInfo Index out of bounds?\n \\return RFC_RC"]
    pub fn RfcGetImplementedInterfaceByIndex(
        classDesc: RFC_CLASS_DESC_HANDLE,
        index: ::std::os::raw::c_uint,
        name: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the number of parent interfaces of the given class.\n \\ingroup class\n\n\n \\in classDesc The class metadata description.\n \\out *implementedInterfacesCount Number of implemented interfaces.\n \\out *errorInfo Should always be successful.\n \\return RFC_RC"]
    pub fn RfcGetImplementedInterfacesCount(
        classDesc: RFC_CLASS_DESC_HANDLE,
        implementedInterfacesCount: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Adds an interface to the list of implemented interfaces of the given class.\n \\ingroup class\n\n\n \\in classDesc The class metadata description.\n \\in name Name of implemented interface to be added.\n \\out *errorInfo Not much can go wrong here except out of memory.\n \\return RFC_RC"]
    pub fn RfcAddImplementedInterface(
        classDesc: RFC_CLASS_DESC_HANDLE,
        name: *const RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Deletes the class description and releases the allocated resources.\n \\ingroup class\n\n Only descriptions, which are not stored in a repository cache and not used by the application, can be deleted.\n Deleting a cached description will cause an error, and deleting a description that is still in use, will lead\n to a crash.\n\n\n \\in classHandle The class description to be deleted.\n \\out *errorInfo More details in case the description can not be destroyed.\n \\return RFC_RC"]
    pub fn RfcDestroyClassDesc(
        classHandle: RFC_CLASS_DESC_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
pub type RFC_METADATA_QUERY_RESULT_HANDLE = *mut ::std::os::raw::c_void;
#[doc = " \\struct _RFC_METADATA_QUERY_RESULT_ENTRY\n \\ingroup repository\n\n Structure containing the error that occurred during the metadata query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RFC_METADATA_QUERY_RESULT_ENTRY {
    pub name: RFC_ABAP_NAME,
    pub errorMessage: [SAP_UC; 512usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RFC_METADATA_QUERY_RESULT_ENTRY"]
        [::std::mem::size_of::<_RFC_METADATA_QUERY_RESULT_ENTRY>() - 1086usize];
    ["Alignment of _RFC_METADATA_QUERY_RESULT_ENTRY"]
        [::std::mem::align_of::<_RFC_METADATA_QUERY_RESULT_ENTRY>() - 2usize];
    ["Offset of field: _RFC_METADATA_QUERY_RESULT_ENTRY::name"]
        [::std::mem::offset_of!(_RFC_METADATA_QUERY_RESULT_ENTRY, name) - 0usize];
    ["Offset of field: _RFC_METADATA_QUERY_RESULT_ENTRY::errorMessage"]
        [::std::mem::offset_of!(_RFC_METADATA_QUERY_RESULT_ENTRY, errorMessage) - 62usize];
};
#[doc = " \\struct _RFC_METADATA_QUERY_RESULT_ENTRY\n \\ingroup repository\n\n Structure containing the error that occurred during the metadata query."]
pub type RFC_METADATA_QUERY_RESULT_ENTRY = _RFC_METADATA_QUERY_RESULT_ENTRY;
pub const _RFC_METADATA_OBJ_TYPE_RFC_METADATA_FUNCTION: _RFC_METADATA_OBJ_TYPE = 0;
pub const _RFC_METADATA_OBJ_TYPE_RFC_METADATA_TYPE: _RFC_METADATA_OBJ_TYPE = 1;
pub const _RFC_METADATA_OBJ_TYPE_RFC_METADATA_CLASS: _RFC_METADATA_OBJ_TYPE = 2;
#[doc = " \\enum _RFC_METADATA_OBJ_TYPE\n \\ingroup repository\n\n An RFC_METADATA_OBJ_TYPE indicates whether in a call to RfcGetMetadataQueryFailedEntry() or RfcGetMetadataQuerySucceededEntry()\n you are interested in the error/success message for a function module (_FUNCTION), structure/table (_TYPE) or ABAP Class (_CLASS).\n It needs to be passed to the above two functions."]
pub type _RFC_METADATA_OBJ_TYPE = ::std::os::raw::c_uint;
#[doc = " \\enum _RFC_METADATA_OBJ_TYPE\n \\ingroup repository\n\n An RFC_METADATA_OBJ_TYPE indicates whether in a call to RfcGetMetadataQueryFailedEntry() or RfcGetMetadataQuerySucceededEntry()\n you are interested in the error/success message for a function module (_FUNCTION), structure/table (_TYPE) or ABAP Class (_CLASS).\n It needs to be passed to the above two functions."]
pub use self::_RFC_METADATA_OBJ_TYPE as RFC_METADATA_OBJ_TYPE;
unsafe extern "C" {
    #[doc = " \\brief  Creates the metadata query result\n \\ingroup repository\n\n Metadata query results contain the names of functions, types and classes queried successfully, and the corresponding\n errors, if the query failed.\n\n \\out *errorInfo More details in error case\n \\return Handle to a metadata query result"]
    pub fn RfcCreateMetadataQueryResult(
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_METADATA_QUERY_RESULT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Destroys the metadata query result\n \\ingroup repository\n\n Releases all resources allocated by the metadata query result.\n\n \\in handle Handle to a metadata query result\n \\out *errorInfo More details in error case\n \\return RFC_RC"]
    pub fn RfcDestroyMetadataQueryResult(
        handle: RFC_METADATA_QUERY_RESULT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Describes the metadata query result\n \\ingroup repository\n\n Returns the number of succeeded and failed entries in the metadata query result. The entries' content can be read with\n RfcGetMetadataQueryFailedEntry() and RfcGetMetadataQuerySucceededEntry().\n\n \\in handle Handle to a metadata query result\n \\in type Type of the metadata objects you are interested in\n \\out *successful Number of metadata objects queried successfully\n \\out *failed Number of metadata objects that could not be queried\n \\out *errorInfo More details in error case\n \\return RFC_RC"]
    pub fn RfcDescribeMetadataQueryResult(
        handle: RFC_METADATA_QUERY_RESULT_HANDLE,
        type_: RFC_METADATA_OBJ_TYPE,
        successful: *mut ::std::os::raw::c_uint,
        failed: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the error entry from the metadata query result\n \\ingroup repository\n\n Returns the object name and the error text, if an error occurred during the query.\n\n \\in handle Handle to a metadata query result\n \\in type Type of the requested object\n \\in index Index of the requested object. Must be between 0 and \"failed - 1\", where \"failed\" is the value\n returned from RfcDescribeMetadataQueryResult() for the given RFC_METADATA_OBJ_TYPE.\n \\inout *entry Pointer to the allocated structure to store the name of the metadata object and the error text\n \\out *errorInfo More details in error case\n \\return RFC_RC"]
    pub fn RfcGetMetadataQueryFailedEntry(
        handle: RFC_METADATA_QUERY_RESULT_HANDLE,
        type_: RFC_METADATA_OBJ_TYPE,
        index: ::std::os::raw::c_uint,
        entry: *mut RFC_METADATA_QUERY_RESULT_ENTRY,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns a succeeded entry from the metadata query result\n \\ingroup repository\n\n Returns the object name of a successfully queried object.\n\n \\in handle Handle to a metadata query result\n \\in type Type of the requested object\n \\in index Index of the requested object. Must be between 0 and \"successful - 1\", where \"successful\" is the value\n returned from RfcDescribeMetadataQueryResult() for the given RFC_METADATA_OBJ_TYPE.\n \\inout *succeedObj Pointer to the allocated buffer to store the name of the metadata object\n \\out *errorInfo More details in error case\n \\return RFC_RC"]
    pub fn RfcGetMetadataQuerySucceededEntry(
        handle: RFC_METADATA_QUERY_RESULT_HANDLE,
        type_: RFC_METADATA_OBJ_TYPE,
        index: ::std::os::raw::c_uint,
        succeedObj: *mut RFC_CHAR,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Queries the meta data for function, type and class lists.\n \\ingroup repository\n\n Queries the meta data for function, type and class lists. All meta data is fetched using one roundtrip,\n the result is cached in the repository cache.\n\n \\note You can use this feature only, if your backend system supports it. SAP Note 1456826 describes the\n required minimum support package level that the backend system must have. If the backend system supports\n it, open the RFC_CONNECTION_HANDLE with the additional logon parameter USE_REPOSITORY_ROUNDTRIP_OPTIMIZATION=1,\n before you pass it to %RfcMetadataBatchQuery().\n\n \\in rfcHandle Open client connection to the R/3 System, for which you need the function module, type or class descriptions.\n \\in *functionNames Names of the function modules to look up\n \\in functionCount Length of the function name list\n \\in *typeNames Names of the types (structures and tables) to look up\n \\in typeCount Length of the type name list\n \\in *classNames Names of the classes to look up\n \\in classCount Length of the class name list\n \\in handle Query result, may be null\n \\out *errorInfo More error details in case something goes wrong\n \\return RFC_RC"]
    pub fn RfcMetadataBatchQuery(
        rfcHandle: RFC_CONNECTION_HANDLE,
        functionNames: *mut *const SAP_UC,
        functionCount: ::std::os::raw::c_uint,
        typeNames: *mut *const SAP_UC,
        typeCount: ::std::os::raw::c_uint,
        classNames: *mut *const SAP_UC,
        classCount: ::std::os::raw::c_uint,
        handle: RFC_METADATA_QUERY_RESULT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Creates a throughput object that can be used to measure performance relevant data of connections and servers.\n \\ingroup throughput\n\n The created throughput object can be attached to a connection (via RfcSetThroughputOnConnection()) or an automated server (via RfcSetThroughputOnServer())\n and will collect performance relevant data from the outgoing or incoming calls. The throughput object will monitor all relevant data until it is removed from the\n connection or server or the object it is attached to is destroyed, i.e. the connection is closed. Note that only one throughput per connection (or server)\n is possible. On the contrary one throughput can be attached to many connections (and/or servers).\n There are serveral functions that handle the throughput and its lifetime like RfcRemoveThroughputFromConnection() or RfcResetThroughput().\n Additionally there are RfcGetX functions to obtain the aggregated data from the throughput.\n\n \\out *errorInfo Error information in case there's not enough memory.\n \\return A handle to the throughput object."]
    pub fn RfcCreateThroughput(errorInfo: *mut RFC_ERROR_INFO) -> RFC_THROUGHPUT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Releases all memory used by the throughput object.\n \\ingroup throughput\n\n \\warning Be careful: if you have attached the throughput to a connection (RFC_CONNECTION_HANDLE) or\n server (RFC_SERVER_HANDLE) you have to remove the throughput from the connection or server before deleting it.\n Alternatively you can close the connection or shutdown the server before destroying the throughput object.\n\n \\in throughput A handle to the throughput object.\n \\out *errorInfo Not much that can go wrong here.\n \\return RFC_RC"]
    pub fn RfcDestroyThroughput(
        throughput: RFC_THROUGHPUT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Attaches a throughput object to a connection to be monitored by the throughput object.\n \\ingroup throughput\n\n Once attached to a connection, the throughput object will collect data of the function calls invoked via this connection.\n If there is already another throughput obejct attached to the connection, the old one will be replaced by the given one.\n The below chart shows a simplified view how the different time measurements apply for a client call.\n\n Client                                            Server (backend)                                       Client\n\n\t     API begin   serialization   writing       server time        reading    deserialization   API end\n      ____________|_______________|_________   _|_____________|_   |__________|_________________|____________\n\n When using the column-based serialization, the monitoring is more fractured.\n\n Client                                            Server (backend)                                       Client\n\n       API begin   serialization                   server time           deserialization      API end\n      ____________|I___I   I___I   I___I|       _|_____________|_      |I___I   I___I   I___I|____________\n                         writing                                      reading\n                       |I_I     I_I     I_I||                       |I_I     I_I     I_I|\n\n\n \\in rfcHandle A handle to a currently open RFC connection (client or server connection).\n \\in throughput A handle to the throughput object.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcSetThroughputOnConnection(
        rfcHandle: RFC_CONNECTION_HANDLE,
        throughput: RFC_THROUGHPUT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the currently attached throughput object from a connection, if any.\n \\ingroup throughput\n\n Returns null if none is attached.\n\n \\in rfcHandle A handle to a currently open RFC connection (client or server connection).\n \\out *errorInfo More details in error case.\n \\return A handle to a throughput object."]
    pub fn RfcGetThroughputFromConnection(
        rfcHandle: RFC_CONNECTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_THROUGHPUT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes the throughput object from a connection. The connection will no longer be monitored.\n \\ingroup throughput\n\n \\in rfcHandle A handle to a currently open RFC connection (client or server connection).\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcRemoveThroughputFromConnection(
        rfcHandle: RFC_CONNECTION_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Attaches a throughput object to an automated server.\n \\ingroup throughput\n\n Once attached to a server the throughput object will collect data of the function calls received by this server.\n As the automated server handles its connections by itself, it will also attach the throughput to all of its connections\n and to all connections that might be re-opened.\n If there is already another throughput attached to the server, the old one will be replaced by the given one.\n The below chart shows a simplified view how the different time measurements apply for a call received by the server.\n\n Client                                            automated Server                                                    Client\n\n\t    call begin       (accepting)   reading   deserialization   C-application   serialization   writing       call end\n      ____________|_   _____________|_________|_________________|_______________|_______________|_________   _|___________\n\n\n \\in serverHandle A handle to the server object.\n \\in throughput A handle to the throughput object.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcSetThroughputOnServer(
        serverHandle: RFC_SERVER_HANDLE,
        throughput: RFC_THROUGHPUT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the currently attached throughput object from a server, if any.\n \\ingroup throughput\n\n Returns null if none is attached.\n\n \\in serverHandle A handle to the server object.\n \\out *errorInfo More details in error case.\n \\return A handle to a throughput object."]
    pub fn RfcGetThroughputFromServer(
        serverHandle: RFC_SERVER_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_THROUGHPUT_HANDLE;
}
unsafe extern "C" {
    #[doc = " \\brief  Removes the throughput from an automated server. The server will no longer be monitored.\n \\ingroup throughput\n\n \\in serverHandle A handle to the server from which the throughput shall be detached.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcRemoveThroughputFromServer(
        serverHandle: RFC_SERVER_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Resets the data so far collected and aggregated by the throughput object.\n \\ingroup throughput\n\n \\in throughput A handle to the throughput object.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcResetThroughput(
        throughput: RFC_THROUGHPUT_HANDLE,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated number of calls the throughput object recorded since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the amount of calls that all these connections\n and servers have processed up to now.\n\n \\in throughput A handle to the throughput object.\n \\out *numberOfCalls Number of all monitored calls.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetNumberOfCalls(
        throughput: RFC_THROUGHPUT_HANDLE,
        numberOfCalls: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated time of call durations the throughput object recorded since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the total time of all processed calls.\n This time includes serialization, deserialization, reading from network, writing to network and time consumed in the backend.\n In case of a server it also includes time accepting a connection.\n An approximation of the time for transmission and execution in the backend is defined by\n\n    totalTime - serializationTime - deserializationTime (- applicationTime)\n\n\n \\in throughput A handle to the throughput object.\n \\out *totalTime Cumulated time of all function module calls processed by the corresponding connections or servers. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetTotalTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        totalTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated serializationtime the throughput object recorded since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the serialization time of all processed calls.\n Serialization time is defined as the time needed for transforming C/C++ data types into a byte stream that can be sent\n over the network. This includes time needed for codepage conversions, endianness conversions etc., but not the time consumed\n by writing to the network.\n\n \\in throughput A handle to the throughput object.\n \\out *serializationTime Cumulated time all serialization processes took. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetSerializationTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        serializationTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated deserialization time the throughput object recorded since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the deserialization time of all processed calls.\n Deserialization time is defined as the time needed for transforming a byte stream received from the network connection into\n C/C++ data types that can be used by the application. This includes time needed for codepage conversions, endianness conversions etc.,\n but not the time consumed by reading from the network.\n\n \\in throughput A handle to the throughput object.\n \\out *deserializationTime Cumulated time all deserialization processes took. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetDeserializationTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        deserializationTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated time of the C implementations of ABAP function modules that the throughput object recorded\n since it was attached or since the last reset.\n \\ingroup throughput\n\n This value is collected only in the case of server connections. (In the client case, function modules are of course\n implemented in ABAP, not in C, and their time is included in the backend time.)\n If a throughput is attached to several connections or servers, this is the application time of all invoked calls.\n\n \\in throughput A handle to the throughput object.\n \\out *applicationTime Cumulated time all C impelementations of ABAP function modules took. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetApplicationTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        applicationTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated execution time of the requests at the server, that the throughput object recorded\n since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the server time of all processed calls.\n This value is measured at the backend by the partner and transmitted in the RFC data payload.\n\n \\in throughput A handle to the throughput object.\n \\out *serverTime Cumulated time spent at the server side for the requests. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetServerTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        serverTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated time that is used to write to network during the requests, that the throughput object recorded\n since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the time used to write to network of all processed calls.\n The time measures calls to underlying libraries such an NI functions and operating socket functions. Those times might not correctly represent the time\n that is needed to send the data, as there are asynchronous IO functions used or the OS is responsible for sending the data.\n\n \\in throughput A handle to the throughput object.\n \\out *writingTime Cumulated time spent writing to the network. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetNetworkWritingTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        writingTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated time that is used to read from the network during the requests, that the throughput object recorded\n since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput object is attached to several connections or servers, this is the time used to read from the network of all processed calls.\n The time measures calls to underlying libraries such an NI functions and operating socket functions. Those times might not correctly represent the time\n that is needed to receive the data, as there are asynchronous IO functions used or the OS is responsible for receiving the data.\n\n \\in throughput A handle to the throughput object.\n \\out *readingTime Cumulated time spent reading from the network. The unit is milliseconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetNetworkReadingTime(
        throughput: RFC_THROUGHPUT_HANDLE,
        readingTime: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated amount of sent bytes the throughput object recorded since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput is attached to several connections or servers, this is the amount of bytes sent by all processed calls.\n\n \\in throughput A handle to the throughput object.\n \\out *sentBytes Cumulated amount of bytes sent over the network.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetSentBytes(
        throughput: RFC_THROUGHPUT_HANDLE,
        sentBytes: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Returns the cumulated amount of received bytes the throughput object recorded since it was attached or since the last reset.\n \\ingroup throughput\n\n If a throughput is attached to several connections or servers, this is the amount of bytes received by all processed calls.\n\n \\in throughput A handle to the throughput object.\n \\out *receivedBytes Cumulated amount of bytes received from the network.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetReceivedBytes(
        throughput: RFC_THROUGHPUT_HANDLE,
        receivedBytes: *mut SAP_ULLONG,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Set Timeout for Message Server Response\n\n During Group Logon and during Group Registration (registration of an RFC server at multiple gateways),\n the NW RFC library sends requests to the message server, asking for the currently \"least busy\" application\n server (load balancing) or for a list of all application servers contained in a group.\n This timeout specifies, how long the NW RFC library will wait for the corresponding responses from the\n message server, before aborting with a timeout error.\n\n \\in timeout Timeout in seconds\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcSetMessageServerResponseTimeout(
        timeout: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the maximum number of concurrent CPIC conversations.\n\n The API can only be called if there are no current CPIC conversations active. A number smaller than the current maximum\n will be ignored.\n The default value is 203.\n\n The number can also be increased by setting MAX_CPIC_CONVERSATIONS in the DEFAULT section of the sapnwrfc.ini file.\n\n \\in maxCpicConversations Maximum of concurrent CPIC conversations\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcSetMaximumCpicConversations(
        maxCpicConversations: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Gets the maximum number of parallel CPIC conversations.\n\n The default value is 203.\n\n \\in *maxCpicConversations Current maximum of parallel CPIC conversations\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcGetMaximumCpicConversations(
        maxCpicConversations: *mut ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
unsafe extern "C" {
    #[doc = " \\brief  Sets the global logon timeout in seconds.\n\n Sets the timeout for how long the logon in the ABAP backend can take during RfcOpenConnection().\n The valid range of values is [1,3600].\n The default value is 60 seconds.\n\n The timeout can also be set via RFC_GLOBAL_LOGON_TIMEOUT in the DEFAULT section of the sapnwrfc.ini file.\n\n \\in logonTimeout gloabl logon timeout in seconds.\n \\out *errorInfo More details in error case.\n \\return RFC_RC"]
    pub fn RfcSetGlobalLogonTimeout(
        logonTimeout: ::std::os::raw::c_uint,
        errorInfo: *mut RFC_ERROR_INFO,
    ) -> RFC_RC;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
